From db0969fd816f76846e3daab8666a74bae9108083 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Mon, 6 Jul 2009 18:29:54 +0200
Subject: [PATCH] First implementation of SuspendUserThreads().
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |   43 ++++++
 backend/SingleSteppingEngine.cs |  298 ++++++++++++++++++++++++---------------
 backend/ThreadManager.cs        |   28 ++++
 backend/ThreadServant.cs        |    4 +
 backend/arch/CoreFile.cs        |   10 ++
 5 files changed, 271 insertions(+), 112 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="db0969fd816f76846e3daab8666a74bae9108083.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="db0969fd816f76846e3daab8666a74bae9108083.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 0023258..4397417 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -644,6 +644,49 @@ namespace Mono.Debugger.Backend
 			thread_lock_mutex.Unlock ();
 		}
 
+		internal void SuspendUserThreads (SingleSteppingEngine caller)
+		{
+			if (has_thread_lock)
+				throw new InternalError ("Recursive thread lock");
+
+			thread_lock_mutex.Lock ();
+			Report.Debug (DebugFlags.Threads,
+				      "Suspending user threads: {0}", caller);
+			has_thread_lock = true;
+			foreach (ThreadServant thread in thread_hash.Values) {
+				if (thread == caller)
+					continue;
+				thread.SuspendUserThread ();
+			}
+			Report.Debug (DebugFlags.Threads,
+				      "Done suspending user threads: {0}", caller);
+		}
+
+		internal void ResumeUserThreads (SingleSteppingEngine caller)
+		{
+			Report.Debug (DebugFlags.Threads,
+				      "Resuming user threads: {0}", caller);
+
+			foreach (ThreadServant thread in thread_hash.Values) {
+				if (thread == caller)
+					continue;
+				thread.ResumeUserThread ();
+			}
+			has_thread_lock = false;
+			thread_lock_mutex.Unlock ();
+			Report.Debug (DebugFlags.Threads,
+				      "Resumed user threads: {0}", caller);
+
+			foreach (ThreadServant thread in thread_hash.Values) {
+				if (thread == caller)
+					continue;
+				thread.ReleaseThreadLockDone ();
+			}
+
+			Report.Debug (DebugFlags.Threads,
+				      "Resumed user threads #1: {0}", caller);
+		}
+
 		public void ActivatePendingBreakpoints (CommandResult result)
 		{
 			((SingleSteppingEngine) main_thread).ManagedCallback (
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index d08d563..0812f5a 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -162,7 +162,7 @@ namespace Mono.Debugger.Backend
 			ProcessEvent (inferior.ProcessEvent (status));
 		}
 
-		public void ProcessEvent (Inferior.ChildEvent cevent)
+		public bool ProcessEvent (Inferior.ChildEvent cevent)
 		{
 			Report.Debug (DebugFlags.EventLoop, "{0} received event {1}",
 				      this, cevent);
@@ -170,39 +170,44 @@ namespace Mono.Debugger.Backend
 			if (killed) {
 				if (cevent.Type == Inferior.ChildEventType.CHILD_INTERRUPTED) {
 					inferior.Continue ();
-					return;
+					return true;
 				} else if (cevent.Type != Inferior.ChildEventType.CHILD_EXITED) {
 					Report.Debug (DebugFlags.EventLoop,
 						      "{0} received event {1} when already killed",
 						      this, cevent);
-					return;
+					return true;
 				}
 			}
 
+			string frame_text = "";
+			Inferior.StackFrame iframe = inferior.GetCurrentFrame (true);
+			if (iframe != null)
+				frame_text = "at " + iframe.Address.ToString ();
+
+			string running_text;
+			if (HasThreadLock)
+				running_text = String.Format ("being thread-locked ({0})", thread_lock);
+			else
+				running_text = String.Format ("running {0}", current_operation);
+
+			string event_text;
+			if (cevent.Type == Inferior.ChildEventType.CHILD_NOTIFICATION)
+				event_text = String.Format ("notification {0} ({1})", cevent, (NotificationType) cevent.Argument);
+			else
+				event_text = "event " + cevent.ToString ();
+
+			Report.Debug (DebugFlags.EventLoop, "{0} received {1} {2} while {3}",
+				      this, event_text, frame_text, running_text);
+
 			if (HasThreadLock) {
-				Report.Debug (DebugFlags.EventLoop,
-					      "{0} received event {1} at {3} while being thread-locked ({2})",
-					      this, cevent, thread_lock, inferior.CurrentFrame);
 				thread_lock.SetStopEvent (cevent);
-				return;
-			} else if (cevent.Type == Inferior.ChildEventType.CHILD_NOTIFICATION) {
-				Report.Debug (DebugFlags.Notification,
-					      "{0} received event {1} {2}",
-					      this, cevent, (NotificationType) cevent.Argument);
+				return false;
 			} else if ((cevent.Type == Inferior.ChildEventType.CHILD_EXITED) ||
 				   (cevent.Type == Inferior.ChildEventType.CHILD_SIGNALED)) {
-				Report.Debug (DebugFlags.SSE, "{0} is now dead: {1}", this, cevent);
+				// we can't remove the breakpoint anymore after
+				// the target exited, but we need to clear this id.
+				temp_breakpoint = null;
 				dead = true;
-			} else {
-				Inferior.StackFrame iframe = inferior.GetCurrentFrame (true);
-				if (iframe != null)
-					Report.Debug (DebugFlags.EventLoop,
-						      "{0} received event {1} at {2} while running {3}",
-						      this, cevent, iframe.Address, current_operation);
-				else
-					Report.Debug (DebugFlags.EventLoop,
-						      "{0} received event {1} while running {2}",
-						      this, cevent, current_operation);
 			}
 
 			if (ProcessServant.IsAttached && !attach_initialized) {
@@ -212,40 +217,82 @@ namespace Mono.Debugger.Backend
 					cevent = new Inferior.ChildEvent (Inferior.ChildEventType.CHILD_STOPPED, 0, 0, 0);
 			}
 
-			if (cevent.Type == Inferior.ChildEventType.CHILD_INTERRUPTED) {
-				frame_changed (inferior.CurrentFrame, null);
-
-				long abort_rti = -1;
-				lock (this) {
-					abort_rti = abort_requested;
-					abort_requested = -1;
-				}
-				Report.Debug (DebugFlags.SSE, "{0} interrupted: {1} - {2}", this, abort_rti, current_frame);
-				if (abort_rti >= 0) {
-					DoAbortInvocation (abort_rti);
-				} else {
-					OperationCompleted (new TargetEventArgs (TargetEventType.TargetInterrupted, 0, current_frame));
-				}
-				return;
-			}
-
 			bool resume_target;
 			if (manager.HandleChildEvent (this, inferior, ref cevent, out resume_target)) {
 				Report.Debug (DebugFlags.EventLoop,
 					      "{0} done handling event: {1} {2} {3}",
 					      this, cevent, resume_target, HasThreadLock);
-				if (!resume_target)
-					return;
-				if ((current_operation != null) && current_operation.ResumeOperation ())
-					return;
+				if (stop_requested) {
+					OperationInterrupted ();
+				} else if (resume_target) {
+					if (!current_operation.ResumeOperation ())
 				inferior.Continue ();
-				return;
+				}
+				return true;
 			}
 
 			Inferior.ChildEventType message = cevent.Type;
 			int arg = (int) cevent.Argument;
 
-			TargetEventArgs result = null;
+			switch (message) {
+			case Inferior.ChildEventType.CHILD_INTERRUPTED:
+				OperationInterrupted ();
+				return true;
+			case Inferior.ChildEventType.CHILD_SIGNALED:
+				if (killed)
+					OperationCompleted (new TargetEventArgs (TargetEventType.TargetExited, 0));
+				else
+					OperationCompleted (new TargetEventArgs (TargetEventType.TargetSignaled, arg));
+				return true;
+
+			case Inferior.ChildEventType.CHILD_EXITED:
+				OperationCompleted (new TargetEventArgs (TargetEventType.TargetExited, arg));
+				return true;
+
+			case Inferior.ChildEventType.CHILD_CALLBACK_COMPLETED:
+				frame_changed (inferior.CurrentFrame, null);
+				OperationCompleted (new TargetEventArgs (TargetEventType.TargetStopped, 0, current_frame));
+				return true;
+
+			case Inferior.ChildEventType.RUNTIME_INVOKE_DONE:
+				OperationRuntimeInvoke rti = rti_stack.Pop ();
+				if (rti.ID != cevent.Argument)
+					throw new InternalError ("{0} got unknown RUNTIME_INVOKE_DONE: {1} {2}", this, rti.ID, cevent);
+
+				frame_changed (inferior.CurrentFrame, null);
+				rti.Completed (cevent.Data1, cevent.Data2);
+
+				if (rti.IsSuspended) {
+					InterruptibleOperation io = nested_break_stack.Pop ();
+					if (io != rti)
+						throw new InternalError ("{0} unexpected item on nested break state stack: {1}", this, io);
+					process.OnLeaveNestedBreakState (this);
+				}
+
+				if (current_operation != rti)
+					current_operation.CompletedOperation ();
+				current_operation = rti;
+
+				TargetEventArgs args = null;
+				if ((rti.Flags & RuntimeInvokeFlags.SendEventOnCompletion) != 0)
+					args = new TargetEventArgs (TargetEventType.RuntimeInvokeDone, rti.Result, current_frame);
+				OperationCompleted (args);
+				return true;
+			}
+
+			if (stop_requested) {
+				OperationInterrupted ();
+				return false;
+			}
+
+			DoProcessEvent (cevent);
+			return true;
+		}
+
+		protected void DoProcessEvent (Inferior.ChildEvent cevent)
+		{
+			Inferior.ChildEventType message = cevent.Type;
+			int arg = (int) cevent.Argument;
 
 			if (message == Inferior.ChildEventType.THROW_EXCEPTION) {
 				TargetAddress info = new TargetAddress (inferior.AddressDomain, cevent.Data1);
@@ -343,14 +390,8 @@ namespace Mono.Debugger.Backend
 			// the target is to remain stopped.  Note that this piece of code
 			// here only deals with the temporary breakpoint, the handling of
 			// a signal or another breakpoint is done later.
-			if (temp_breakpoint != null) {
-				if ((message == Inferior.ChildEventType.CHILD_EXITED) ||
-				    (message == Inferior.ChildEventType.CHILD_SIGNALED))
-					// we can't remove the breakpoint anymore after
-					// the target exited, but we need to clear this id.
-					temp_breakpoint = null;
-				else if ((message == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) &&
-					 (arg == temp_breakpoint.ID)) {
+			if ((temp_breakpoint != null) &&
+			    (message == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) && (arg == temp_breakpoint.ID)) {
 					// we hit the temporary breakpoint; this'll always
 					// happen in the `correct' thread since the
 					// `temp_breakpoint_id' is only set in this
@@ -365,27 +406,19 @@ namespace Mono.Debugger.Backend
 					if ((bpt == null) || !bpt.Breaks (thread.ID) || bpt.HideFromUser) {
 						message = Inferior.ChildEventType.CHILD_STOPPED;
 						arg = 0;
-						cevent = new Inferior.ChildEvent (
-							Inferior.ChildEventType.CHILD_STOPPED, 0, 0, 0);
+					cevent = new Inferior.ChildEvent (Inferior.ChildEventType.CHILD_STOPPED, 0, 0, 0);
 					} else {
 						ProcessOperationEvent (cevent);
 						return;
 					}
 				}
-			}
-
-			switch (message) {
-			case Inferior.ChildEventType.CHILD_STOPPED:
-				break;
 
-			case Inferior.ChildEventType.UNHANDLED_EXCEPTION: {
+			if (message == Inferior.ChildEventType.UNHANDLED_EXCEPTION) {
 				TargetAddress exc = new TargetAddress (manager.AddressDomain, cevent.Data1);
 				TargetAddress ip = new TargetAddress (manager.AddressDomain, cevent.Data2);
 				PushOperation (new OperationException (this, ip, exc, true));
 				return;
-			}
-
-			case Inferior.ChildEventType.CHILD_HIT_BREAKPOINT: {
+			} else if (message == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) {
 				// Ok, the next thing we need to check is whether this is actually "our"
 				// breakpoint or whether it belongs to another thread.  In this case,
 				// `step_over_breakpoint' does everything for us and we can just continue
@@ -396,49 +429,6 @@ namespace Mono.Debugger.Backend
 					do_continue ();
 					return;
 				}
-				break;
-			}
-
-			case Inferior.ChildEventType.CHILD_SIGNALED:
-				if (killed)
-					OperationCompleted (new TargetEventArgs (TargetEventType.TargetExited, 0));
-				else
-					OperationCompleted (new TargetEventArgs (TargetEventType.TargetSignaled, arg));
-				return;
-
-			case Inferior.ChildEventType.CHILD_EXITED:
-				OperationCompleted (new TargetEventArgs (TargetEventType.TargetExited, arg));
-				return;
-
-			case Inferior.ChildEventType.CHILD_CALLBACK_COMPLETED:
-				frame_changed (inferior.CurrentFrame, null);
-				OperationCompleted (new TargetEventArgs (TargetEventType.TargetStopped, 0, current_frame));
-				return;
-
-			case Inferior.ChildEventType.RUNTIME_INVOKE_DONE:
-				OperationRuntimeInvoke rti = rti_stack.Pop ();
-				if (rti.ID != cevent.Argument)
-					throw new InternalError ("{0} got unknown RUNTIME_INVOKE_DONE: {1} {2}", this, rti.ID, cevent);
-
-				frame_changed (inferior.CurrentFrame, null);
-				rti.Completed (cevent.Data1, cevent.Data2);
-
-				if (rti.IsSuspended) {
-					InterruptibleOperation io = nested_break_stack.Pop ();
-					if (io != rti)
-						throw new InternalError ("{0} unexpected item on nested break state stack: {1}", this, io);
-					process.OnLeaveNestedBreakState (this);
-				}
-
-				if (current_operation != rti)
-					current_operation.CompletedOperation ();
-				current_operation = rti;
-
-				TargetEventArgs args = null;
-				if ((rti.Flags & RuntimeInvokeFlags.SendEventOnCompletion) != 0)
-					args = new TargetEventArgs (TargetEventType.RuntimeInvokeDone, rti.Result, current_frame);
-				OperationCompleted (args);
-				return;
 			}
 
 			ProcessOperationEvent (cevent);
@@ -514,6 +504,23 @@ namespace Mono.Debugger.Backend
 
 #endregion
 
+		void OperationInterrupted ()
+		{
+			frame_changed (inferior.CurrentFrame, null);
+
+			long abort_rti = -1;
+			lock (this) {
+				abort_rti = abort_requested;
+				abort_requested = -1;
+			}
+			Report.Debug (DebugFlags.SSE, "{0} operation interrupted: {1} - {2}", this, abort_rti, current_frame);
+			if (abort_rti >= 0) {
+				DoAbortInvocation (abort_rti);
+			} else {
+				OperationCompleted (new TargetEventArgs (TargetEventType.TargetInterrupted, 0, current_frame));
+			}
+		}
+
 		void AbortRuntimeInvoke (long rti_id)
 		{
 			OperationRuntimeInvoke rti = rti_stack.Pop ();
@@ -538,9 +545,14 @@ namespace Mono.Debugger.Backend
 		void OperationCompleted (TargetEventArgs result, bool suspended)
 		{
 			lock (this) {
+				if (!stop_requested)
+					manager.StopAllThreads (this);
+
 				remove_temporary_breakpoint ();
 				engine_stopped = true;
+				stop_requested = false;
 				last_target_event = result;
+
 				operation_completed_event.Set ();
 				Report.Debug (DebugFlags.EventLoop, "{0} {1} operation {2}: {3}",
 					      this, suspended ? "suspending" : "terminating", current_operation, result);
@@ -659,8 +671,11 @@ namespace Mono.Debugger.Backend
 		void StartOperation ()
 		{
 			lock (this) {
+				Report.Debug (DebugFlags.SSE, "{0} start operation: {1} {2} {3}",
+					      this, engine_stopped, HasThreadLock, pending_operation);
+
 				if (!engine_stopped || (HasThreadLock && (pending_operation != null))) {
-					Report.Debug (DebugFlags.Wait,
+					Report.Debug (DebugFlags.SSE,
 						      "{0} not stopped", this);
 					throw new TargetException (TargetError.NotStopped);
 				}
@@ -687,6 +702,8 @@ namespace Mono.Debugger.Backend
 			StartOperation ();
 
 			return (CommandResult) SendCommand (delegate {
+				manager.ResumeAllThreads (this);
+
 				return ProcessOperation (operation);
 			});
 		}
@@ -934,10 +951,7 @@ namespace Mono.Debugger.Backend
 
 				bool stopped = inferior.Stop ();
 				if (!Inferior.HasThreadEvents && !stopped)
-				{
-					ProcessEvent (new Inferior.ChildEvent (Inferior.ChildEventType.CHILD_INTERRUPTED, 0, 0, 0));
-					engine_stopped = true;
-				}	
+					OperationInterrupted ();
 				
 				Report.Debug (DebugFlags.EventLoop, "{0} interrupt #1: {1}",
 					      this, stopped);
@@ -1519,6 +1533,9 @@ namespace Mono.Debugger.Backend
 		// </summary>
 		internal override void AcquireThreadLock ()
 		{
+			if (HasThreadLock)
+				throw new InternalError ("Recursive thread lock");
+
 			Report.Debug (DebugFlags.Threads,
 				      "{0} acquiring thread lock: {1} {2}",
 				      this, engine_stopped, current_operation);
@@ -1545,6 +1562,9 @@ namespace Mono.Debugger.Backend
 
 			if (!EndStackAddress.IsNull)
 				inferior.WriteAddress (EndStackAddress, new_rsp);
+
+			frame_changed (inferior.CurrentFrame, null);
+			engine_stopped = true;
 		}
 
 		internal override void ReleaseThreadLock ()
@@ -1604,6 +1624,56 @@ namespace Mono.Debugger.Backend
 			ExecuteOperation (current_operation);
 		}
 
+		internal override void SuspendUserThread ()
+		{
+			if (HasThreadLock)
+				throw new InternalError ("Recursive thread lock");
+
+			Report.Debug (DebugFlags.Threads,
+				      "{0} suspend user thread: {1} {2}",
+				      this, engine_stopped, current_operation);
+
+			Inferior.ChildEvent stop_event;
+			bool stopped = inferior.Stop (out stop_event);
+
+			Report.Debug (DebugFlags.Threads,
+				      "{0} suspend user thread #1: {1} {2}",
+				      this, stopped, stop_event);
+
+			stop_requested = true;
+
+			if (stop_event != null) {
+				if (ProcessEvent (stop_event))
+					stop_event = null;
+			} else {
+				OperationInterrupted ();
+			}
+
+			thread_lock = new ThreadLockData (stopped, stop_event, true);
+		}
+
+		internal override void ResumeUserThread ()
+		{
+			if (thread_lock == null) {
+				Report.Debug (DebugFlags.Threads,
+					      "{0} thread lock already released!", this);
+				return;
+			}
+
+			Report.Debug (DebugFlags.Threads,
+				      "{0} resuming user thread: {1} {2} {3}", this, thread_lock,
+				      inferior.CurrentFrame, current_operation);
+
+			if (thread_lock.StopEvent != null)
+				manager.AddPendingEvent (this, thread_lock.StopEvent);
+
+			thread_lock = null;
+			engine_stopped = false;
+
+			CommandResult result = new ThreadCommandResult (thread);
+			pending_operation = new OperationRun (this, result);
+		}
+
 		internal bool OnModuleLoaded (Module module)
 		{
 			return ActivatePendingBreakpoints (module);
@@ -1706,6 +1776,7 @@ namespace Mono.Debugger.Backend
 
 		public override void StepInstruction (CommandResult result)
 		{
+			Report.Debug (DebugFlags.SSE, "{0} step instruction", this);
 			StartOperation (new OperationStep (this, StepMode.SingleInstruction, result));
 		}
 
@@ -2357,6 +2428,7 @@ namespace Mono.Debugger.Backend
 		bool engine_stopped;
 		bool reached_main;
 		bool killed, dead;
+		bool stop_requested;
 		bool attach_initialized;
 		long tid;
 		int pid;
@@ -3201,6 +3273,8 @@ namespace Mono.Debugger.Backend
 
 		protected override void DoExecute ()
 		{
+			Report.Debug (DebugFlags.SSE, "{0} step execute: {1}", sse, inferior.CurrentFrame);
+
 			switch (StepMode) {
 			case StepMode.NativeInstruction:
 				sse.do_step_native ();
diff --git a/backend/ThreadManager.cs b/backend/ThreadManager.cs
index 470a382..ef96721 100644
--- a/backend/ThreadManager.cs
+++ b/backend/ThreadManager.cs
@@ -625,6 +625,34 @@ namespace Mono.Debugger.Backend
 			}
 		}
 
+#region Stopping / Starting threads
+
+		bool stopped_all_threads;
+
+		internal void StopAllThreads (SingleSteppingEngine engine)
+		{
+			Report.Debug (DebugFlags.SSE, "Stopping all threads: {0}", engine);
+
+			engine.Process.SuspendUserThreads (engine);
+			stopped_all_threads = true;
+
+			Report.Debug (DebugFlags.SSE, "Stopped all threads: {0} {1}",
+				      engine, engine.Inferior.CurrentFrame);
+		}
+
+		internal void ResumeAllThreads (SingleSteppingEngine engine)
+		{
+			if (!stopped_all_threads)
+				return;
+
+			Report.Debug (DebugFlags.SSE, "Resuming all threads: {0}", engine);
+
+			engine.Process.ResumeUserThreads (engine);
+			stopped_all_threads = false;
+		}
+
+#endregion
+
 #region IDisposable implementation
 		private bool disposed = false;
 
diff --git a/backend/ThreadServant.cs b/backend/ThreadServant.cs
index 9244431..31c24cb 100644
--- a/backend/ThreadServant.cs
+++ b/backend/ThreadServant.cs
@@ -192,6 +192,10 @@ namespace Mono.Debugger.Backend
 
 		public abstract void Stop ();
 
+		internal abstract void SuspendUserThread ();
+
+		internal abstract void ResumeUserThread ();
+
 		internal abstract object Invoke (TargetAccessDelegate func, object data);
 
 		// <summary>
diff --git a/backend/arch/CoreFile.cs b/backend/arch/CoreFile.cs
index c19fdea..e57b01f 100644
--- a/backend/arch/CoreFile.cs
+++ b/backend/arch/CoreFile.cs
@@ -567,6 +567,16 @@ namespace Mono.Debugger.Backend
 				throw new InvalidOperationException ();
 			}
 
+			internal override void SuspendUserThread ()
+			{
+				throw new InvalidOperationException ();
+			}
+
+			internal override void ResumeUserThread ()
+			{
+				throw new InvalidOperationException ();
+			}
+
 			public override int AddEventHandler (Event handle)
 			{
 				throw new InvalidOperationException ();

--------------1.5.6--



From 2958be788af06ddc910db771ef63d0870c016fc4 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 7 Jul 2009 13:41:33 +0200
Subject: [PATCH] Kill ...
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |    4 ++++
 backend/SingleSteppingEngine.cs |   26 +++++++++++++++++---------
 2 files changed, 21 insertions(+), 9 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="2958be788af06ddc910db771ef63d0870c016fc4.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="2958be788af06ddc910db771ef63d0870c016fc4.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 4397417..5f64976 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -301,6 +301,8 @@ namespace Mono.Debugger.Backend
 
 		internal void OnProcessExitedEvent ()
 		{
+			DropGlobalThreadLock ();
+
 			if (!is_forked)
 				session.OnProcessExited (client);
 			client.OnProcessExited ();
@@ -640,9 +642,11 @@ namespace Mono.Debugger.Backend
 			if (thread_hash.Count != 0)
 				throw new InternalError ();
 
+			if (has_thread_lock) {
 			has_thread_lock = false;
 			thread_lock_mutex.Unlock ();
 		}
+		}
 
 		internal void SuspendUserThreads (SingleSteppingEngine caller)
 		{
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 0812f5a..32677e6 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -179,6 +179,14 @@ namespace Mono.Debugger.Backend
 				}
 			}
 
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_EXITED) ||
+			    (cevent.Type == Inferior.ChildEventType.CHILD_SIGNALED)) {
+				Report.Debug (DebugFlags.SSE, "{0} received {1}", this, cevent);
+				// we can't remove the breakpoint anymore after
+				// the target exited, but we need to clear this id.
+				temp_breakpoint = null;
+				dead = true;
+			} else {
 			string frame_text = "";
 			Inferior.StackFrame iframe = inferior.GetCurrentFrame (true);
 			if (iframe != null)
@@ -202,12 +210,7 @@ namespace Mono.Debugger.Backend
 			if (HasThreadLock) {
 				thread_lock.SetStopEvent (cevent);
 				return false;
-			} else if ((cevent.Type == Inferior.ChildEventType.CHILD_EXITED) ||
-				   (cevent.Type == Inferior.ChildEventType.CHILD_SIGNALED)) {
-				// we can't remove the breakpoint anymore after
-				// the target exited, but we need to clear this id.
-				temp_breakpoint = null;
-				dead = true;
+				}
 			}
 
 			if (ProcessServant.IsAttached && !attach_initialized) {
@@ -545,7 +548,7 @@ namespace Mono.Debugger.Backend
 		void OperationCompleted (TargetEventArgs result, bool suspended)
 		{
 			lock (this) {
-				if (!stop_requested)
+				if (!stop_requested && !dead)
 					manager.StopAllThreads (this);
 
 				remove_temporary_breakpoint ();
@@ -881,9 +884,14 @@ namespace Mono.Debugger.Backend
 			killed = true;
 			SendCommand (delegate {
 				Inferior.ChildEvent stop_event;
-				if (!engine_stopped)
-					inferior.Stop (out stop_event);
+				Report.Debug (DebugFlags.SSE, "{0} kill: {1}", this, engine_stopped);
+				if (!engine_stopped) {
+					bool stopped = inferior.Stop (out stop_event);
+					Report.Debug (DebugFlags.SSE, "{0} kill #1: {1} {2} {3}",
+						      this, engine_stopped, stopped, stop_event);
+				}
 				inferior.Kill ();
+				Report.Debug (DebugFlags.SSE, "{0} kill #2", this);
 				return null;
 			});
 		}

--------------1.5.6--



From 8054ca148eaa788a80cc47989273982c87b59935 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 7 Jul 2009 17:40:49 +0200
Subject: [PATCH] In stop_and_wait(): catch pending events
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/server/x86-linux-ptrace.c |   27 +++++++++++++++++++--------
 1 files changed, 19 insertions(+), 8 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="8054ca148eaa788a80cc47989273982c87b59935.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="8054ca148eaa788a80cc47989273982c87b59935.diff"

diff --git a/backend/server/x86-linux-ptrace.c b/backend/server/x86-linux-ptrace.c
index 560e1d1..2f77438 100644
--- a/backend/server/x86-linux-ptrace.c
+++ b/backend/server/x86-linux-ptrace.c
@@ -254,14 +254,17 @@ GStaticMutex wait_mutex_2 = G_STATIC_MUTEX_INIT;
 GStaticMutex wait_mutex_3 = G_STATIC_MUTEX_INIT;
 
 static int
-do_wait (int pid, guint32 *status)
+do_wait (int pid, guint32 *status, gboolean nohang)
 {
-	int ret;
+	int ret, flags;
 
 #if DEBUG_WAIT
-	g_message (G_STRLOC ": do_wait (%d)", pid);
+	g_message (G_STRLOC ": do_wait (%d%s)", pid, nohang ? ",nohang" : "");
 #endif
-	ret = waitpid (pid, status, WUNTRACED | __WALL | __WCLONE);
+	flags = WUNTRACED | __WALL | __WCLONE;
+	if (nohang)
+		flags |= WNOHANG;
+	ret = waitpid (pid, status, flags);
 #if DEBUG_WAIT
 	g_message (G_STRLOC ": do_wait (%d) finished: %d - %x", pid, ret, *status);
 #endif
@@ -287,7 +290,7 @@ server_ptrace_global_wait (guint32 *status_ret)
 
  again:
 	g_static_mutex_lock (&wait_mutex);
-	ret = do_wait (-1, &status);
+	ret = do_wait (-1, &status, FALSE);
 	if (ret <= 0)
 		goto out;
 
@@ -415,6 +418,7 @@ static ServerCommandError
 server_ptrace_stop_and_wait (ServerHandle *handle, guint32 *status)
 {
 	ServerCommandError result;
+	gboolean already_stopped = FALSE;
 	int ret;
 
 	/*
@@ -426,10 +430,16 @@ server_ptrace_stop_and_wait (ServerHandle *handle, guint32 *status)
 #endif
 	g_static_mutex_lock (&wait_mutex_2);
 	result = server_ptrace_stop (handle);
-	if (result != COMMAND_ERROR_NONE) {
+	if (result == COMMAND_ERROR_ALREADY_STOPPED) {
+#if DEBUG_WAIT
+		g_message (G_STRLOC ": %d - already stopped", handle->inferior->pid);
+#endif
+		already_stopped = TRUE;
+	} else if (result != COMMAND_ERROR_NONE) {
 #if DEBUG_WAIT
 		g_message (G_STRLOC ": %d - cannot stop %d", handle->inferior->pid, result);
 #endif
+
 		g_static_mutex_unlock (&wait_mutex_2);
 		return result;
 	}
@@ -440,6 +450,7 @@ server_ptrace_stop_and_wait (ServerHandle *handle, guint32 *status)
 	g_static_mutex_unlock (&wait_mutex_2);
 
 #if DEBUG_WAIT
+	if (!already_stopped)
 	g_message (G_STRLOC ": %d - sent SIGSTOP", handle->inferior->pid);
 #endif
 
@@ -461,7 +472,7 @@ server_ptrace_stop_and_wait (ServerHandle *handle, guint32 *status)
 #if DEBUG_WAIT
 		g_message (G_STRLOC ": %d - waiting", handle->inferior->pid);
 #endif
-		ret = do_wait (handle->inferior->pid, status);
+		ret = do_wait (handle->inferior->pid, status, already_stopped);
 #if DEBUG_WAIT
 		g_message (G_STRLOC ": %d - done waiting %d, %x",
 			   handle->inferior->pid, ret, status);
@@ -684,7 +695,7 @@ server_ptrace_detach_after_fork (ServerHandle *handle)
 	 * Make sure we're stopped.
 	 */
 	if (x86_arch_get_registers (handle) != COMMAND_ERROR_NONE)
-		do_wait (handle->inferior->pid, &status);
+		do_wait (handle->inferior->pid, &status, FALSE);
 
 	result = x86_arch_get_registers (handle);
 	if (result != COMMAND_ERROR_NONE)

--------------1.5.6--



From f0af195fc7bbc60aeff154b529e6bba52a615cc5 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 7 Jul 2009 18:09:44 +0200
Subject: [PATCH] Implement ResumeUserOperation().
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/Inferior.cs             |    1 +
 backend/SingleSteppingEngine.cs |  110 +++++++++++++++++++++++++++++++-------
 2 files changed, 90 insertions(+), 21 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="f0af195fc7bbc60aeff154b529e6bba52a615cc5.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="f0af195fc7bbc60aeff154b529e6bba52a615cc5.diff"

diff --git a/backend/Inferior.cs b/backend/Inferior.cs
index 59e41b8..531edb2 100644
--- a/backend/Inferior.cs
+++ b/backend/Inferior.cs
@@ -731,6 +731,7 @@ namespace Mono.Debugger.Backend
 			case ChildEventType.CHILD_STOPPED:
 			case ChildEventType.CHILD_INTERRUPTED:
 			case ChildEventType.CHILD_HIT_BREAKPOINT:
+			case ChildEventType.CHILD_NOTIFICATION:
 				change_target_state (TargetState.Stopped);
 				break;
 
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 32677e6..2f5b8b0 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -223,8 +223,10 @@ namespace Mono.Debugger.Backend
 			bool resume_target;
 			if (manager.HandleChildEvent (this, inferior, ref cevent, out resume_target)) {
 				Report.Debug (DebugFlags.EventLoop,
-					      "{0} done handling event: {1} {2} {3}",
-					      this, cevent, resume_target, HasThreadLock);
+					      "{0} done handling event: {1}{2}{3}{4}",
+					      this, cevent, resume_target ? " resume-target" : "" ,
+					      stop_requested ? " stop-requested" : "",
+					      HasThreadLock ? " thread-lock" : "");
 				if (stop_requested) {
 					OperationInterrupted ();
 				} else if (resume_target) {
@@ -548,7 +550,7 @@ namespace Mono.Debugger.Backend
 		void OperationCompleted (TargetEventArgs result, bool suspended)
 		{
 			lock (this) {
-				if (!stop_requested && !dead)
+				if (!stop_requested && !dead && (current_operation is SteppingOperation))
 					manager.StopAllThreads (this);
 
 				remove_temporary_breakpoint ();
@@ -705,7 +707,7 @@ namespace Mono.Debugger.Backend
 			StartOperation ();
 
 			return (CommandResult) SendCommand (delegate {
-				manager.ResumeAllThreads (this);
+				// manager.ResumeAllThreads (this);
 
 				return ProcessOperation (operation);
 			});
@@ -1634,6 +1636,8 @@ namespace Mono.Debugger.Backend
 
 		internal override void SuspendUserThread ()
 		{
+			if (!ThreadManager.InBackgroundThread)
+				throw new InternalError ();
 			if (HasThreadLock)
 				throw new InternalError ("Recursive thread lock");
 
@@ -1644,10 +1648,6 @@ namespace Mono.Debugger.Backend
 			Inferior.ChildEvent stop_event;
 			bool stopped = inferior.Stop (out stop_event);
 
-			Report.Debug (DebugFlags.Threads,
-				      "{0} suspend user thread #1: {1} {2}",
-				      this, stopped, stop_event);
-
 			stop_requested = true;
 
 			if (stop_event != null) {
@@ -1657,29 +1657,36 @@ namespace Mono.Debugger.Backend
 				OperationInterrupted ();
 			}
 
-			thread_lock = new ThreadLockData (stopped, stop_event, true);
+			Report.Debug (DebugFlags.Threads,
+				      "{0} suspend user thread done: {1} {2}",
+				      this, stopped, stop_event);
+
+			if (stop_event != null)
+				thread_lock = new ThreadLockData (stopped, stop_event, false);
 		}
 
 		internal override void ResumeUserThread ()
 		{
-			if (thread_lock == null) {
-				Report.Debug (DebugFlags.Threads,
-					      "{0} thread lock already released!", this);
-				return;
-			}
+			if (!ThreadManager.InBackgroundThread)
+				throw new InternalError ();
 
 			Report.Debug (DebugFlags.Threads,
-				      "{0} resuming user thread: {1} {2} {3}", this, thread_lock,
-				      inferior.CurrentFrame, current_operation);
+				      "{0} resume user thread: {1}", this, HasThreadLock);
+
+			if (thread_lock != null) {
+				if (thread_lock.PushedRegisters || (thread_lock.StopEvent == null))
+					throw new InternalError ();
 
-			if (thread_lock.StopEvent != null)
 				manager.AddPendingEvent (this, thread_lock.StopEvent);
 
 			thread_lock = null;
 			engine_stopped = false;
 
-			CommandResult result = new ThreadCommandResult (thread);
-			pending_operation = new OperationRun (this, result);
+				pending_operation = new OperationAutoRun (this);
+				return;
+			}
+
+			StartOperation (new OperationAutoRun (this));
 		}
 
 		internal bool OnModuleLoaded (Module module)
@@ -3225,7 +3232,21 @@ namespace Mono.Debugger.Backend
 		}
 	}
 
-	protected abstract class OperationStepBase : Operation
+	protected abstract class SteppingOperation : Operation
+	{
+		protected SteppingOperation (SingleSteppingEngine sse, CommandResult result)
+			: base (sse, result)
+		{ }
+
+		public override void Execute ()
+		{
+			Report.Debug (DebugFlags.SSE, "{0} start stepping operation: {1}", sse, this);
+			sse.manager.ResumeAllThreads (sse);
+			base.Execute ();
+		}
+	}
+
+	protected abstract class OperationStepBase : SteppingOperation
 	{
 		public override bool CheckBreakpointsOnCompletion {
 			get { return true; }
@@ -3522,7 +3543,54 @@ namespace Mono.Debugger.Backend
 		}
 	}
 
-	protected class OperationRun : Operation
+	protected class OperationAutoRun : Operation
+	{
+		public override bool CheckBreakpointsOnCompletion {
+			get { return true; }
+		}
+
+		public OperationAutoRun (SingleSteppingEngine sse)
+			: base (sse, null)
+		{ }
+
+		public override bool IsSourceOperation {
+			get { return true; }
+		}
+
+		protected override void DoExecute ()
+		{
+			sse.do_continue ();
+		}
+
+		public override bool ResumeOperation ()
+		{
+			Report.Debug (DebugFlags.SSE, "{0} resuming operation {1}", sse, this);
+
+			sse.do_continue ();
+			return true;
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			args = null;
+			Report.Debug (DebugFlags.EventLoop, "{0} received {1} at {2} in {3}",
+				      sse, cevent, inferior.CurrentFrame, this);
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) ||
+			    (cevent.Type == Inferior.ChildEventType.CHILD_CALLBACK) ||
+			    (cevent.Type == Inferior.ChildEventType.RUNTIME_INVOKE_DONE))
+				return EventResult.Completed;
+			Execute ();
+			return EventResult.Running;
+		}
+
+		public override bool HandleException (TargetAddress stack, TargetAddress exc)
+		{
+			return false;
+		}
+	}
+
+	protected class OperationRun : SteppingOperation
 	{
 		TargetAddress until;
 		bool in_background;

--------------1.5.6--



From b5ab60ac962764b73d2c33eedc5e54720b9176b5 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 7 Jul 2009 18:21:37 +0200
Subject: [PATCH] SuspendThreadsOnCompletion.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |   18 +++++++++++++++++-
 1 files changed, 17 insertions(+), 1 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="b5ab60ac962764b73d2c33eedc5e54720b9176b5.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="b5ab60ac962764b73d2c33eedc5e54720b9176b5.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 2f5b8b0..7a640ea 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -550,7 +550,7 @@ namespace Mono.Debugger.Backend
 		void OperationCompleted (TargetEventArgs result, bool suspended)
 		{
 			lock (this) {
-				if (!stop_requested && !dead && (current_operation is SteppingOperation))
+				if (!stop_requested && !dead && current_operation.SuspendThreadsOnCompletion)
 					manager.StopAllThreads (this);
 
 				remove_temporary_breakpoint ();
@@ -2583,6 +2583,10 @@ namespace Mono.Debugger.Backend
 			get { return false; }
 		}
 
+		public virtual bool SuspendThreadsOnCompletion {
+			get { return false; }
+		}
+
 		protected bool HasChild {
 			get { return child != null; }
 		}
@@ -2832,6 +2836,10 @@ namespace Mono.Debugger.Backend
 			get { return true; }
 		}
 
+		public override bool SuspendThreadsOnCompletion {
+			get { return true; }
+		}
+
 		protected override void DoExecute ()
 		{
 			Report.Debug (DebugFlags.SSE,
@@ -3252,6 +3260,10 @@ namespace Mono.Debugger.Backend
 			get { return true; }
 		}
 
+		public override bool SuspendThreadsOnCompletion {
+			get { return true; }
+		}
+
 		protected OperationStepBase (SingleSteppingEngine sse, CommandResult result)
 			: base (sse, result)
 		{ }
@@ -3599,6 +3611,10 @@ namespace Mono.Debugger.Backend
 			get { return true; }
 		}
 
+		public override bool SuspendThreadsOnCompletion {
+			get { return true; }
+		}
+
 		public OperationRun (SingleSteppingEngine sse, TargetAddress until,
 				     bool in_background, CommandResult result)
 			: base (sse, result)

--------------1.5.6--



From 23c0b58674410efa6d13519d1a1b8f91308f1080 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 7 Jul 2009 18:29:10 +0200
Subject: [PATCH] The operation is now responsible for resuming.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |  106 ++++++++++++---------------------------
 1 files changed, 32 insertions(+), 74 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="23c0b58674410efa6d13519d1a1b8f91308f1080.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="23c0b58674410efa6d13519d1a1b8f91308f1080.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 7a640ea..fad70bc 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1165,7 +1165,7 @@ namespace Mono.Debugger.Backend
 			registers = inferior.GetRegisters ();
 
 			if ((operation != null) && !main_retaddr.IsNull && (iframe.StackPointer >= main_retaddr))
-				return new OperationRun (this, false, operation.Result);
+				return new OperationRun (this, false, false, operation.Result);
 
 			// Compute the current stack frame.
 			if ((current_method != null) && current_method.HasLineNumbers) {
@@ -1673,6 +1673,8 @@ namespace Mono.Debugger.Backend
 			Report.Debug (DebugFlags.Threads,
 				      "{0} resume user thread: {1}", this, HasThreadLock);
 
+			CommandResult result = new ThreadCommandResult (thread);
+
 			if (thread_lock != null) {
 				if (thread_lock.PushedRegisters || (thread_lock.StopEvent == null))
 					throw new InternalError ();
@@ -1682,11 +1684,11 @@ namespace Mono.Debugger.Backend
 				thread_lock = null;
 				engine_stopped = false;
 
-				pending_operation = new OperationAutoRun (this);
+				pending_operation = new OperationRun (this, false, true, result);
 				return;
 			}
 
-			StartOperation (new OperationAutoRun (this));
+			StartOperation (new OperationRun (this, false, true, result));
 		}
 
 		internal bool OnModuleLoaded (Module module)
@@ -2885,7 +2887,7 @@ namespace Mono.Debugger.Backend
 			}
 
 			Report.Debug (DebugFlags.SSE, "{0} start #1: {1}", sse, cevent);
-			sse.PushOperation (new OperationRun (sse, true, Result));
+			sse.PushOperation (new OperationRun (sse, true, false, Result));
 			return EventResult.Running;
 		}
 
@@ -3240,21 +3242,7 @@ namespace Mono.Debugger.Backend
 		}
 	}
 
-	protected abstract class SteppingOperation : Operation
-	{
-		protected SteppingOperation (SingleSteppingEngine sse, CommandResult result)
-			: base (sse, result)
-		{ }
-
-		public override void Execute ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} start stepping operation: {1}", sse, this);
-			sse.manager.ResumeAllThreads (sse);
-			base.Execute ();
-		}
-	}
-
-	protected abstract class OperationStepBase : SteppingOperation
+	protected abstract class OperationStepBase : Operation
 	{
 		public override bool CheckBreakpointsOnCompletion {
 			get { return true; }
@@ -3268,6 +3256,13 @@ namespace Mono.Debugger.Backend
 			: base (sse, result)
 		{ }
 
+		public override void Execute ()
+		{
+			Report.Debug (DebugFlags.SSE, "{0} start stepping operation: {1}", sse, this);
+			sse.manager.ResumeAllThreads (sse);
+			base.Execute ();
+		}
+
 		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
 							       out TargetEventArgs args)
 		{
@@ -3555,57 +3550,9 @@ namespace Mono.Debugger.Backend
 		}
 	}
 
-	protected class OperationAutoRun : Operation
-	{
-		public override bool CheckBreakpointsOnCompletion {
-			get { return true; }
-		}
-
-		public OperationAutoRun (SingleSteppingEngine sse)
-			: base (sse, null)
-		{ }
-
-		public override bool IsSourceOperation {
-			get { return true; }
-		}
-
-		protected override void DoExecute ()
-		{
-			sse.do_continue ();
-		}
-
-		public override bool ResumeOperation ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} resuming operation {1}", sse, this);
-
-			sse.do_continue ();
-			return true;
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			args = null;
-			Report.Debug (DebugFlags.EventLoop, "{0} received {1} at {2} in {3}",
-				      sse, cevent, inferior.CurrentFrame, this);
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) ||
-			    (cevent.Type == Inferior.ChildEventType.CHILD_CALLBACK) ||
-			    (cevent.Type == Inferior.ChildEventType.RUNTIME_INVOKE_DONE))
-				return EventResult.Completed;
-			Execute ();
-			return EventResult.Running;
-		}
-
-		public override bool HandleException (TargetAddress stack, TargetAddress exc)
-		{
-			return false;
-		}
-	}
-
-	protected class OperationRun : SteppingOperation
+	protected class OperationRun : Operation
 	{
 		TargetAddress until;
-		bool in_background;
 
 		public override bool CheckBreakpointsOnCompletion {
 			get { return true; }
@@ -3620,21 +3567,26 @@ namespace Mono.Debugger.Backend
 			: base (sse, result)
 		{
 			this.until = until;
-			this.in_background = in_background;
+			this.InBackground = in_background;
 		}
 
 		public OperationRun (SingleSteppingEngine sse, bool in_background,
-				     CommandResult result)
+				     bool is_autorun, CommandResult result)
 			: this (sse, TargetAddress.Null, in_background, result)
-		{ }
+		{
+			this.IsAutoRun = is_autorun;
+		}
 
 		public OperationRun (SingleSteppingEngine sse, CommandResult result)
 			: this (sse, TargetAddress.Null, true, result)
 		{ }
 
-
 		public bool InBackground {
-			get { return in_background; }
+			get; private set;
+		}
+
+		public bool IsAutoRun {
+			get; private set;
 		}
 
 		public override bool IsSourceOperation {
@@ -3643,6 +3595,12 @@ namespace Mono.Debugger.Backend
 
 		protected override void DoExecute ()
 		{
+			Report.Debug (DebugFlags.SSE, "{0} run: {1} {2} {3}",
+				      sse, until, InBackground, IsAutoRun);
+
+			if (!IsAutoRun)
+				sse.manager.ResumeAllThreads (sse);
+
 			if (!until.IsNull)
 				sse.do_continue (until);
 			else
@@ -3669,7 +3627,7 @@ namespace Mono.Debugger.Backend
 			    (cevent.Type == Inferior.ChildEventType.CHILD_CALLBACK) ||
 			    (cevent.Type == Inferior.ChildEventType.RUNTIME_INVOKE_DONE))
 				return EventResult.Completed;
-			Execute ();
+			sse.do_continue ();
 			return EventResult.Running;
 		}
 

--------------1.5.6--



From 1f2cb0ee23f8af7a49e05a2f174455989c381503 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 7 Jul 2009 18:30:46 +0200
Subject: [PATCH] TargetState.Busy if we're thread-locked.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="1f2cb0ee23f8af7a49e05a2f174455989c381503.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="1f2cb0ee23f8af7a49e05a2f174455989c381503.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index fad70bc..08818dc 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -854,6 +854,8 @@ namespace Mono.Debugger.Backend
 			get {
 				if (inferior == null)
 					return TargetState.NoTarget;
+				else if (HasThreadLock)
+					return TargetState.Busy;
 				else
 					return inferior.State;
 			}

--------------1.5.6--



From 53db9cde865458e420afb250d244d2516d6caabd Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 7 Jul 2009 19:40:10 +0200
Subject: [PATCH] Refuse to start a new operation while being thread-locked.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |   14 ++++++--------
 1 files changed, 6 insertions(+), 8 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="53db9cde865458e420afb250d244d2516d6caabd.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="53db9cde865458e420afb250d244d2516d6caabd.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 08818dc..3efe4ee 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -716,14 +716,12 @@ namespace Mono.Debugger.Backend
 		CommandResult ProcessOperation (Operation operation)
 		{
 			if (HasThreadLock) {
-				Report.Debug (DebugFlags.SSE,
-					      "{0} starting {1} while being thread-locked",
-					      this, operation);
-				pending_operation = operation;
-				return operation.Result;
-			} else
-				Report.Debug (DebugFlags.SSE,
-					      "{0} starting {1}", this, operation);
+				throw new TargetException (TargetError.NotStopped,
+							   "Cannot start operation {0} on {1} while being thread-locked.",
+							   operation, this);
+			} else {
+				Report.Debug (DebugFlags.SSE, "{0} starting {1}", this, operation);
+			}
 
 			PushOperation (operation);
 			return operation.Result;

--------------1.5.6--



From 253231aff49ffda4379ab5c8fb24d2a18f118d9e Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 7 Jul 2009 21:23:16 +0200
Subject: [PATCH] Restart notifications.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/Inferior.cs             |    8 ++++++++
 backend/SingleSteppingEngine.cs |   17 +++++++++++++++++
 backend/server/i386-arch.c      |   13 +++++++++++++
 backend/server/library.c        |    9 +++++++++
 backend/server/server.h         |    5 +++++
 backend/server/x86-ptrace.c     |    1 +
 backend/server/x86_64-arch.c    |   13 +++++++++++++
 7 files changed, 66 insertions(+), 0 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="253231aff49ffda4379ab5c8fb24d2a18f118d9e.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="253231aff49ffda4379ab5c8fb24d2a18f118d9e.diff"

diff --git a/backend/Inferior.cs b/backend/Inferior.cs
index 531edb2..f29b785 100644
--- a/backend/Inferior.cs
+++ b/backend/Inferior.cs
@@ -193,6 +193,9 @@ namespace Mono.Debugger.Backend
 		static extern TargetError mono_debugger_server_get_callback_frame (IntPtr handle, long stack_pointer, bool exact_match, IntPtr info);
 
 		[DllImport("monodebuggerserver")]
+		static extern TargetError mono_debugger_server_restart_notification (IntPtr handle);
+
+		[DllImport("monodebuggerserver")]
 		static extern void mono_debugger_server_set_runtime_info (IntPtr handle, IntPtr mono_runtime_info);
 
 		[DllImport("monodebuggerserver")]
@@ -602,6 +605,11 @@ namespace Mono.Debugger.Backend
 				server_handle, breakpoint));
 		}
 
+		public void RestartNotification ()
+		{
+			check_error (mono_debugger_server_restart_notification (server_handle));
+		}
+
 		public ProcessStart ProcessStart {
 			get {
 				return start;
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 3efe4ee..9ca65cb 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -286,9 +286,26 @@ namespace Mono.Debugger.Backend
 			}
 
 			if (stop_requested) {
+				switch (message) {
+				case Inferior.ChildEventType.CHILD_STOPPED:
+				case Inferior.ChildEventType.CHILD_CALLBACK:
+				case Inferior.ChildEventType.CHILD_HIT_BREAKPOINT:
+					OperationInterrupted ();
+					return true;
+
+				case Inferior.ChildEventType.UNHANDLED_EXCEPTION:
+				case Inferior.ChildEventType.THROW_EXCEPTION:
+				case Inferior.ChildEventType.HANDLE_EXCEPTION:
+				case Inferior.ChildEventType.CHILD_NOTIFICATION:
+					inferior.RestartNotification ();
+					OperationInterrupted ();
+					return true;
+
+				default:
 				OperationInterrupted ();
 				return false;
 			}
+			}
 
 			DoProcessEvent (cevent);
 			return true;
diff --git a/backend/server/i386-arch.c b/backend/server/i386-arch.c
index 4c8b4a7..668e8bb 100644
--- a/backend/server/i386-arch.c
+++ b/backend/server/i386-arch.c
@@ -1334,3 +1334,16 @@ server_ptrace_get_callback_frame (ServerHandle *handle, guint64 stack_pointer,
 
 	return COMMAND_ERROR_NO_CALLBACK_FRAME;
 }
+
+static ServerCommandError
+server_ptrace_restart_notification (ServerHandle *handle)
+{
+	ServerCommandError result;
+
+	if (!handle->mono_runtime ||
+	    (INFERIOR_REG_EIP (handle->arch->current_regs) - 1 != handle->mono_runtime->notification_address))
+		return COMMAND_ERROR_INTERNAL_ERROR;
+
+	INFERIOR_REG_EIP (handle->arch->current_regs)--;
+	return _server_ptrace_set_registers (handle->inferior, &handle->arch->current_regs);
+}
diff --git a/backend/server/library.c b/backend/server/library.c
index 032b562..8f48607 100644
--- a/backend/server/library.c
+++ b/backend/server/library.c
@@ -501,6 +501,15 @@ mono_debugger_server_get_callback_frame (ServerHandle *handle, guint64 stack_poi
 		handle, stack_pointer, exact_match, info);
 }
 
+ServerCommandError
+mono_debugger_server_restart_notification (ServerHandle *handle)
+{
+	if (!global_vtable->restart_notification)
+		return COMMAND_ERROR_NOT_IMPLEMENTED;
+
+	return (* global_vtable->restart_notification) (handle);
+}
+
 void
 mono_debugger_server_get_registers_from_core_file (guint64 *values, const guint8 *buffer)
 {
diff --git a/backend/server/server.h b/backend/server/server.h
index a0b4eb2..7e2eda6 100644
--- a/backend/server/server.h
+++ b/backend/server/server.h
@@ -431,6 +431,8 @@ struct InferiorVTable {
 						       gboolean           exact_match,
 						       CallbackInfo      *info);
 
+	ServerCommandError    (* restart_notification) (ServerHandle      *handle);
+
 	void         (* get_registers_from_core_file) (guint64           *values,
 						       const guint8      *buffer);
 
@@ -698,6 +700,9 @@ mono_debugger_server_get_callback_frame  (ServerHandle        *handle,
 					  gboolean             exact_match,
 					  CallbackInfo        *info);
 
+ServerCommandError
+mono_debugger_server_restart_notification (ServerHandle        *handle);
+
 MonoRuntimeInfo *
 mono_debugger_server_initialize_mono_runtime (guint32 address_size,
 					      guint64 notification_address,
diff --git a/backend/server/x86-ptrace.c b/backend/server/x86-ptrace.c
index f23ccc0..48007c4 100644
--- a/backend/server/x86-ptrace.c
+++ b/backend/server/x86-ptrace.c
@@ -685,6 +685,7 @@ InferiorVTable i386_ptrace_inferior = {
 	server_ptrace_push_registers,
 	server_ptrace_pop_registers,
 	server_ptrace_get_callback_frame,
+	server_ptrace_restart_notification,
 	server_ptrace_get_registers_from_core_file,
 	server_ptrace_get_current_pid,
 	server_ptrace_get_current_thread,
diff --git a/backend/server/x86_64-arch.c b/backend/server/x86_64-arch.c
index c315089..b1ac457 100644
--- a/backend/server/x86_64-arch.c
+++ b/backend/server/x86_64-arch.c
@@ -1379,3 +1379,16 @@ server_ptrace_get_callback_frame (ServerHandle *handle, guint64 stack_pointer,
 
 	return COMMAND_ERROR_NO_CALLBACK_FRAME;
 }
+
+static ServerCommandError
+server_ptrace_restart_notification (ServerHandle *handle)
+{
+	ServerCommandError result;
+
+	if (!handle->mono_runtime ||
+	    (INFERIOR_REG_RIP (handle->arch->current_regs) - 1 != handle->mono_runtime->notification_address))
+		return COMMAND_ERROR_INTERNAL_ERROR;
+
+	INFERIOR_REG_RIP (handle->arch->current_regs)--;
+	return _server_ptrace_set_registers (handle->inferior, &handle->arch->current_regs);
+}

--------------1.5.6--



From 5197aeda7fe00906e423c436bbcd80864647ffac Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 8 Jul 2009 03:37:42 +0200
Subject: [PATCH] Set/reset Thread.Flags.AutoRun and don't use the process thread lock.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |   31 ++++++++++++++++++-------------
 backend/SingleSteppingEngine.cs |    2 +-
 backend/ThreadServant.cs        |    4 ++--
 classes/GUIManager.cs           |    2 +-
 classes/Thread.cs               |    6 +-----
 5 files changed, 23 insertions(+), 22 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="5197aeda7fe00906e423c436bbcd80864647ffac.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="5197aeda7fe00906e423c436bbcd80864647ffac.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 996920b..5cccf48 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -651,18 +651,18 @@ namespace Mono.Debugger.Backend
 
 		internal void SuspendUserThreads (SingleSteppingEngine caller)
 		{
-			if (has_thread_lock)
-				throw new InternalError ("Recursive thread lock");
-
-			thread_lock_mutex.Lock ();
 			Report.Debug (DebugFlags.Threads,
 				      "Suspending user threads: {0}", caller);
-			has_thread_lock = true;
-			foreach (ThreadServant thread in thread_hash.Values) {
-				if (thread == caller)
+
+			foreach (SingleSteppingEngine engine in thread_hash.Values) {
+				if (engine == caller)
 					continue;
-				thread.SuspendUserThread ();
+				engine.SuspendUserThread ();
+				engine.Thread.ThreadFlags |= Thread.Flags.AutoRun;
 			}
+
+			caller.Thread.ThreadFlags |= Thread.Flags.AutoRun;
+
 			Report.Debug (DebugFlags.Threads,
 				      "Done suspending user threads: {0}", caller);
 		}
@@ -672,13 +672,18 @@ namespace Mono.Debugger.Backend
 			Report.Debug (DebugFlags.Threads,
 				      "Resuming user threads: {0}", caller);
 
-			foreach (ThreadServant thread in thread_hash.Values) {
-				if (thread == caller)
+			foreach (SingleSteppingEngine engine in thread_hash.Values) {
+				if (engine == caller)
+					continue;
+				if ((engine.Thread.ThreadFlags & Thread.Flags.AutoRun) == 0)
 					continue;
-				thread.ResumeUserThread ();
+
+				engine.ResumeUserThread ();
+				engine.Thread.ThreadFlags &= ~Thread.Flags.AutoRun;
 			}
-			has_thread_lock = false;
-			thread_lock_mutex.Unlock ();
+
+			caller.Thread.ThreadFlags &= ~Thread.Flags.AutoRun;
+
 			Report.Debug (DebugFlags.Threads,
 				      "Resumed user threads: {0}", caller);
 		}
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index a96457a..0e70f88 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1666,7 +1666,7 @@ namespace Mono.Debugger.Backend
 				throw new InternalError ();
 
 			Report.Debug (DebugFlags.Threads,
-				      "{0} resume user thread: {1}", this, HasThreadLock);
+				      "{0} resume user thread: {1} {2}", this, HasThreadLock, thread.ThreadFlags);
 
 			CommandResult result = new ThreadCommandResult (thread);
 
diff --git a/backend/ThreadServant.cs b/backend/ThreadServant.cs
index a33c17a..00b648a 100644
--- a/backend/ThreadServant.cs
+++ b/backend/ThreadServant.cs
@@ -99,13 +99,13 @@ namespace Mono.Debugger.Backend
 		internal void SetDaemon ()
 		{
 			is_daemon = true;
-			thread.SetThreadFlags (thread.ThreadFlags | Thread.Flags.Daemon | Thread.Flags.Immutable);
+			thread.ThreadFlags |= Thread.Flags.Daemon | Thread.Flags.Immutable;
 		}
 
 		internal void SetManaged ()
 		{
 			is_daemon = false;
-			thread.SetThreadFlags (thread.ThreadFlags & ~(Thread.Flags.Daemon | Thread.Flags.Immutable));
+			thread.ThreadFlags &= ~(Thread.Flags.Daemon | Thread.Flags.Immutable);
 		}
 
 		public abstract TargetEventArgs LastTargetEvent {
diff --git a/classes/GUIManager.cs b/classes/GUIManager.cs
index 9abcef9..78a46d2 100644
--- a/classes/GUIManager.cs
+++ b/classes/GUIManager.cs
@@ -108,7 +108,7 @@ namespace Mono.Debugger
 
 				Report.Debug (DebugFlags.Threads, "Autostopping thread: {0}", thread);
 				thread.Stop ();
-				thread.SetThreadFlags (thread.ThreadFlags | Thread.Flags.AutoRun);
+				thread.ThreadFlags |= Thread.Flags.AutoRun;
 				stopped.Add (thread);
 			}
 
diff --git a/classes/Thread.cs b/classes/Thread.cs
index d6d0168..aaf8899 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -102,6 +102,7 @@ namespace Mono.Debugger
 
 		public Flags ThreadFlags {
 			get { return flags; }
+			internal set { flags = value; }
 		}
 
 		public string Name {
@@ -162,11 +163,6 @@ namespace Mono.Debugger
 			}
 		}
 
-		internal void SetThreadFlags (Flags flags)
-		{
-			this.flags = flags;
-		}
-
 		public ThreadGroup ThreadGroup {
 			get {
 				check_servant ();

--------------1.5.6--



From e4b35c7b3bc31baca72bb2c98329db5e62c263e5 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 8 Jul 2009 03:45:06 +0200
Subject: [PATCH] Can we move this down here ?
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="e4b35c7b3bc31baca72bb2c98329db5e62c263e5.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="e4b35c7b3bc31baca72bb2c98329db5e62c263e5.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 0e70f88..1455bd6 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -573,7 +573,6 @@ namespace Mono.Debugger.Backend
 				stop_requested = false;
 				last_target_event = result;
 
-				operation_completed_event.Set ();
 				Report.Debug (DebugFlags.EventLoop, "{0} {1} operation {2}: {3}",
 					      this, suspended ? "suspending" : "terminating", current_operation, result);
 
@@ -594,6 +593,8 @@ namespace Mono.Debugger.Backend
 						current_operation = null;
 					}
 				}
+
+				operation_completed_event.Set ();
 			}
 		}
 

--------------1.5.6--



From dfc1acf174e83050832beeb711765d98175d6d6e Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 8 Jul 2009 04:13:30 +0200
Subject: [PATCH] Started to work on the new WaitAll().
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |   11 ++++
 backend/SingleSteppingEngine.cs |    8 ++-
 classes/Process.cs              |    4 ++
 frontend/Command.cs             |    8 +--
 frontend/Interpreter.cs         |  103 ++++++++++++++-------------------------
 5 files changed, 59 insertions(+), 75 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="dfc1acf174e83050832beeb711765d98175d6d6e.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="dfc1acf174e83050832beeb711765d98175d6d6e.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 5cccf48..e778f02 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -26,6 +26,7 @@ namespace Mono.Debugger.Backend
 		SymbolTableManager symtab_manager;
 		MonoThreadManager mono_manager;
 		BreakpointManager breakpoint_manager;
+		ST.ManualResetEvent stopped_event;
 		Dictionary<int,ExceptionCatchPoint> exception_handlers;
 		ProcessStart start;
 		DebuggerSession session;
@@ -53,6 +54,8 @@ namespace Mono.Debugger.Backend
 
 			thread_lock_mutex = new DebuggerMutex ("thread_lock_mutex");
 
+			stopped_event = new ST.ManualResetEvent (false);
+
 			thread_hash = Hashtable.Synchronized (new Hashtable ());
 
 			target_info = Inferior.GetTargetInfo ();
@@ -183,6 +186,10 @@ namespace Mono.Debugger.Backend
 			get { return start.CommandLineArguments; }
 		}
 
+		internal ST.WaitHandle WaitHandle {
+			get { return stopped_event; }
+		}
+
 		internal void ThreadCreated (Inferior inferior, int pid, bool do_attach, bool resume_thread)
 		{
 			Inferior new_inferior = inferior.CreateThread (pid, do_attach);
@@ -665,10 +672,14 @@ namespace Mono.Debugger.Backend
 
 			Report.Debug (DebugFlags.Threads,
 				      "Done suspending user threads: {0}", caller);
+
+			stopped_event.Set ();
 		}
 
 		internal void ResumeUserThreads (SingleSteppingEngine caller)
 		{
+			stopped_event.Reset ();
+
 			Report.Debug (DebugFlags.Threads,
 				      "Resuming user threads: {0}", caller);
 
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 1455bd6..bc66019 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -565,14 +565,15 @@ namespace Mono.Debugger.Backend
 		void OperationCompleted (TargetEventArgs result, bool suspended)
 		{
 			lock (this) {
-				if (!stop_requested && !dead && current_operation.SuspendThreadsOnCompletion)
-					manager.StopAllThreads (this);
+				bool stop_all = !stop_requested && !dead && current_operation.SuspendThreadsOnCompletion;
 
 				remove_temporary_breakpoint ();
 				engine_stopped = true;
 				stop_requested = false;
 				last_target_event = result;
 
+				operation_completed_event.Set ();
+
 				Report.Debug (DebugFlags.EventLoop, "{0} {1} operation {2}: {3}",
 					      this, suspended ? "suspending" : "terminating", current_operation, result);
 
@@ -594,7 +595,8 @@ namespace Mono.Debugger.Backend
 					}
 				}
 
-				operation_completed_event.Set ();
+				if (stop_all)
+					manager.StopAllThreads (this);
 			}
 		}
 
diff --git a/classes/Process.cs b/classes/Process.cs
index 226b7b6..2357a84 100644
--- a/classes/Process.cs
+++ b/classes/Process.cs
@@ -76,6 +76,10 @@ namespace Mono.Debugger
 			get { return servant.NativeLanguage; }
 		}
 
+		public ST.WaitHandle WaitHandle {
+			get { return servant.WaitHandle; }
+		}
+
 		public void Kill ()
 		{
 			servant.Kill ();
diff --git a/frontend/Command.cs b/frontend/Command.cs
index 795c876..dd75c66 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -1312,13 +1312,11 @@ namespace Mono.Debugger.Frontend
 				return result;
 
 			if (context.Interpreter.DebuggerConfiguration.BrokenThreading) {
-				Thread ret = context.Interpreter.WaitAll (result.Thread, result, wait);
-				if (ret == null)
+				Process process = context.Interpreter.WaitAll (result.Thread.Process);
+				if (process == null)
 					return null;
 
-				if (ret.IsAlive)
-					context.Interpreter.CurrentThread = ret;
-				return ret;
+				return process;
 			}
 
 			context.Interpreter.WaitOne (result.Thread);
diff --git a/frontend/Interpreter.cs b/frontend/Interpreter.cs
index eee8b99..a940947 100644
--- a/frontend/Interpreter.cs
+++ b/frontend/Interpreter.cs
@@ -296,7 +296,7 @@ namespace Mono.Debugger.Frontend
 				current_process = main_process = debugger.Run (session);
 
 				current_thread = current_process.MainThread;
-				current_thread = WaitAll (current_thread) ?? current_process.MainThread;
+				WaitAll (current_process);
 
 				return current_process;
 			} catch (TargetException) {
@@ -379,7 +379,7 @@ namespace Mono.Debugger.Frontend
 				current_process = main_process = debugger.Run (session);
 
 				current_thread = current_process.MainThread;
-				current_thread = WaitAll (current_thread);
+				WaitAll (current_process);
 
 				return current_process;
 			} catch (TargetException ex) {
@@ -439,65 +439,59 @@ namespace Mono.Debugger.Frontend
 			return true;
 		}
 
-		public Thread WaitAll (Thread thread)
+		public Process WaitAll (Process process)
 		{
-			return WaitAll (thread, thread.GetWaitHandle (), false);
-		}
-
-		public Thread WaitAll (Thread thread, CommandResult result, bool wait)
-		{
-			if (result == null)
-				return null;
-
 			ClearInterrupt ();
 			process_event.Reset ();
 
 			Thread stopped;
 			Hashtable seen_threads = new Hashtable ();
-			Hashtable wait_list = new Hashtable ();
 
 			do {
 			again:
+				List<WaitHandle> wait_list = new List<WaitHandle> ();
+				wait_list.Add (interrupt_event);
+				wait_list.Add (process_event);
+				wait_list.Add (process.WaitHandle);
+
+#if FIXME
 				Process[] processes = HasTarget ? debugger.Processes : new Process [0];
 				foreach (Process process in processes) {
-					Thread[] the_threads = process.GetThreads ();
-					foreach (Thread t in the_threads) {
-						if ((t == thread) || seen_threads.Contains (t))
-							continue;
-
-						seen_threads.Add (t, null);
-						if (t.IsRunning)
-							wait_list.Add (t, false);
-						else if ((t.ThreadFlags & Thread.Flags.AutoRun) != 0) {
-							t.Continue ();
-							wait_list.Add (t, true);
-						}
-					}
+					wait_list.Add (process.WaitHandle);
 				}
+#endif
 
-				WaitHandle[] handles = new WaitHandle [wait_list.Count + 3];
-				handles [0] = interrupt_event;
-				handles [1] = process_event;
-				handles [2] = result.CompletedEvent;
+				Console.WriteLine ("WAIT ALL: {0}", process);
 
-				Thread[] threads = new Thread [wait_list.Count];
-				wait_list.Keys.CopyTo (threads, 0);
+				int ret = WaitHandle.WaitAny (wait_list.ToArray ());
 
-				for (int i = 0; i < wait_list.Count; i++)
-					handles [i + 3] = threads [i].WaitHandle;
+				Console.WriteLine ("WAIT ALL DONE: {0}", ret);
 
-				int ret = WaitHandle.WaitAny (handles);
+				if (ret == 0) {
+					Console.WriteLine ("NEED ABORT !!!");
+					return null;
+				} else if (ret == 1) {
+					seen_threads = new Hashtable ();
+					process_event.Reset ();
+					goto again;
+				} else {
+					return process;
+				}
 
+#if FIXME
 				if (ret == 0) {
+					Console.WriteLine ("INTERRUPT!");
+					return;
 					stopped = null;
 					result.Abort ();
 					result.CompletedEvent.WaitOne ();
 					break;
 				} else if (ret == 1) {
 					seen_threads = new Hashtable ();
-					wait_list = new Hashtable ();
 					process_event.Reset ();
 					goto again;
+				} else {
+					return thread;
 				}
 
 				if (result.Result is Exception)
@@ -505,40 +499,15 @@ namespace Mono.Debugger.Frontend
 
 				if (ret == 2)
 					stopped = thread;
-				else
-					stopped = threads [ret - 3];
-
-				CheckLastEvent (stopped);
-				wait_list.Remove (stopped);
-			} while ((stopped != null) && (stopped != thread) && (wait || !stopped.IsAlive));
-
-			if (!HasTarget)
-				return stopped;
-
-			List<WaitHandle> autostop_list = new List<WaitHandle> ();
-
-			foreach (Process process in Processes) {
-				foreach (Thread t in process.GetThreads ()) {
-					if (t == stopped)
-						continue;
-					// Never touch immutable threads.
-					if (!t.IsRunning)
-						continue;
-					if ((t.ThreadFlags & Thread.Flags.Immutable) != 0)
-						continue;
-					// Background thread -> keep running.
-					if ((t.ThreadFlags & Thread.Flags.Background) != 0)
-						continue;
-
-					// Stop and set AutoRun.
-					t.AutoStop ();
-					autostop_list.Add (t.WaitHandle);
-				}
+				else {
+					Console.WriteLine ("WAIT ALL FUCK!");
+					// stopped = threads [ret - 3];
+					stopped = thread;
 			}
 
-			WaitHandle.WaitAll (autostop_list.ToArray ());
-
-			return stopped;
+				CheckLastEvent (stopped);
+#endif
+			} while (true);
 		}
 
 		protected void Wait (Thread thread)

--------------1.5.6--



From ae5e7ca69509589767165bfc72ecf48bf19c2537 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 8 Jul 2009 04:22:52 +0200
Subject: [PATCH] Small fix.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 frontend/Interpreter.cs |   57 ++++++++++++++--------------------------------
 1 files changed, 18 insertions(+), 39 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="ae5e7ca69509589767165bfc72ecf48bf19c2537.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="ae5e7ca69509589767165bfc72ecf48bf19c2537.diff"

diff --git a/frontend/Interpreter.cs b/frontend/Interpreter.cs
index a940947..133f8d2 100644
--- a/frontend/Interpreter.cs
+++ b/frontend/Interpreter.cs
@@ -291,7 +291,6 @@ namespace Mono.Debugger.Frontend
 				debugger = new Debugger (config);
 
 				new InterpreterEventSink (this, debugger);
-				new ThreadEventSink (this, debugger);
 
 				current_process = main_process = debugger.Run (session);
 
@@ -318,7 +317,6 @@ namespace Mono.Debugger.Frontend
 				debugger = new Debugger (config);
 
 				new InterpreterEventSink (this, debugger);
-				new ThreadEventSink (this, debugger);
 
 				current_process = main_process = debugger.Attach (session, pid);
 				current_thread = current_process.MainThread;
@@ -343,7 +341,6 @@ namespace Mono.Debugger.Frontend
 				debugger = new Debugger (config);
 
 				new InterpreterEventSink (this, debugger);
-				new ThreadEventSink (this, debugger);
 
 				Thread[] threads;
 				current_process = main_process = debugger.OpenCoreFile (
@@ -374,7 +371,6 @@ namespace Mono.Debugger.Frontend
 				session = new DebuggerSession (config, stream, parser);
 
 				new InterpreterEventSink (this, debugger);
-				new ThreadEventSink (this, debugger);
 
 				current_process = main_process = debugger.Run (session);
 
@@ -634,11 +630,6 @@ namespace Mono.Debugger.Frontend
 
 		protected virtual void OnTargetEvent (Thread thread, TargetEventArgs args)
 		{
-			if (args.Type == TargetEventType.TargetInterrupted) {
-				;
-			} else if ((args.Type != TargetEventType.TargetStopped) || ((int) args.Data != 0))
-				Style.TargetEvent (thread, args);
-			else if ((thread.ThreadFlags & Thread.Flags.Background) != 0)
 				Style.TargetEvent (thread, args);
 		}
 
@@ -1024,6 +1015,24 @@ namespace Mono.Debugger.Frontend
 				debugger.ProcessCreatedEvent += process_created;
 				debugger.ProcessExitedEvent += process_exited;
 				debugger.ProcessExecdEvent += process_execd;
+				debugger.TargetEvent += target_event;
+				debugger.EnterNestedBreakStateEvent +=
+					delegate (Debugger unused, Thread thread) {
+						interpreter.OnEnterNestedBreakState (thread);
+					};
+				debugger.LeaveNestedBreakStateEvent +=
+					delegate (Debugger unused, Thread thread) {
+						interpreter.OnLeaveNestedBreakState (thread);
+					};
+			}
+
+			public void target_event (Thread thread, TargetEventArgs args)
+			{
+				if (((thread.ThreadFlags & Thread.Flags.Daemon) != 0) &&
+				    ((args.Type == TargetEventType.TargetExited) ||
+				     (args.Type == TargetEventType.TargetSignaled)))
+					return;
+				interpreter.OnTargetEvent (thread, args);
 			}
 
 			public void thread_created (Debugger debugger, Thread thread)
@@ -1090,35 +1099,5 @@ namespace Mono.Debugger.Frontend
 				interpreter.OnTargetOutput (is_stderr, line);
 			}
 		}
-
-		[Serializable]
-		protected class ThreadEventSink
-		{
-			Interpreter interpreter;
-
-			public ThreadEventSink (Interpreter interpreter, Debugger debugger)
-			{
-				this.interpreter = interpreter;
-
-				debugger.TargetEvent += target_event;
-				debugger.EnterNestedBreakStateEvent +=
-					delegate (Debugger unused, Thread thread) {
-						interpreter.OnEnterNestedBreakState (thread);
-					};
-				debugger.LeaveNestedBreakStateEvent +=
-					delegate (Debugger unused, Thread thread) {
-						interpreter.OnLeaveNestedBreakState (thread);
-					};
-			}
-
-			public void target_event (Thread thread, TargetEventArgs args)
-			{
-				if (((thread.ThreadFlags & Thread.Flags.Daemon) != 0) &&
-				    ((args.Type == TargetEventType.TargetExited) ||
-				     (args.Type == TargetEventType.TargetSignaled)))
-					return;
-				interpreter.OnTargetEvent (thread, args);
-			}
-		}
 	}
 }

--------------1.5.6--



From 1f9fbbbc8f528fc38f9809e15c51af3d8839ad8f Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 8 Jul 2009 15:54:34 +0200
Subject: [PATCH] Introduce a new Thread.Step() API and made 'StepMode' and 'StepFrame' public.
 2009-07-08  Martin Baulig  <martin@ximian.com>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit


	* backend/StepFrame.cs: Moved to ../classes/StepFrame.cs.

	* classes/StepFrame.cs
	(StepMode): Made this public.
	(StepFrame): Make this public and [Serializable].

	* classes/Thread.cs
	(Thread.Step): New public function.
	(Thread.StepInstruction): Obsolete, use the new Step() API.
	(Thread.StepNativeInstruction): Likewise.
	(Thread.NextInstruction): Likewise.
	(Thread.StepLine): Likewise.
	(Thread.NextLine): Likewise.

	* backend/ThreadServant.cs
	(ThreadServant.Step): New public function.
---
 ChangeLog                         |   19 +++++++++++++
 backend/SingleSteppingEngine.cs   |   14 ++++++++++
 backend/ThreadServant.cs          |    2 +
 backend/arch/CoreFile.cs          |    5 +++
 {backend => classes}/StepFrame.cs |    7 +++--
 classes/Thread.cs                 |   53 ++++++++++++++++---------------------
 6 files changed, 67 insertions(+), 33 deletions(-)
 rename {backend => classes}/StepFrame.cs (95%)
--------------1.5.6
Content-Type: text/x-patch; name="1f9fbbbc8f528fc38f9809e15c51af3d8839ad8f.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="1f9fbbbc8f528fc38f9809e15c51af3d8839ad8f.diff"

diff --git a/ChangeLog b/ChangeLog
index 4172420..5ed89af 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,22 @@
+2009-07-08  Martin Baulig  <martin@ximian.com>
+
+	* backend/StepFrame.cs: Moved to ../classes/StepFrame.cs.
+
+	* classes/StepFrame.cs
+	(StepMode): Made this public.
+	(StepFrame): Make this public and [Serializable].
+
+	* classes/Thread.cs
+	(Thread.Step): New public function.
+	(Thread.StepInstruction): Obsolete, use the new Step() API.
+	(Thread.StepNativeInstruction): Likewise.
+	(Thread.NextInstruction): Likewise.
+	(Thread.StepLine): Likewise.
+	(Thread.NextLine): Likewise.
+
+	* backend/ThreadServant.cs
+	(ThreadServant.Step): New public function.
+
 2009-07-07  Martin Baulig  <martin@ximian.com>
 
 	* backend/SingleSteppingEngine.cs
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index cb42d25..4b4189b 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1682,6 +1682,13 @@ namespace Mono.Debugger.Backend
 
 #region SSE Commands
 
+		public override ThreadCommandResult Step (StepMode mode, StepFrame frame)
+		{
+			ThreadCommandResult result = new OperationCommandResult (thread);
+			StartOperation (new OperationStep (this, mode, frame, result));
+			return result;
+		}
+
 		public override void StepInstruction (CommandResult result)
 		{
 			StartOperation (new OperationStep (this, StepMode.SingleInstruction, result));
@@ -3151,6 +3158,13 @@ namespace Mono.Debugger.Backend
 			this.StepMode = frame.Mode;
 		}
 
+		public OperationStep (SingleSteppingEngine sse, StepMode mode, StepFrame frame, CommandResult result)
+			: base (sse, result)
+		{
+			this.StepFrame = frame;
+			this.StepMode = mode;
+		}
+
 		public override bool IsSourceOperation {
 			get {
 				return (StepMode == StepMode.SourceLine) ||
diff --git a/backend/ThreadServant.cs b/backend/ThreadServant.cs
index d65cd30..d3433cb 100644
--- a/backend/ThreadServant.cs
+++ b/backend/ThreadServant.cs
@@ -150,6 +150,8 @@ namespace Mono.Debugger.Backend
 
 		public abstract Backtrace GetBacktrace (Backtrace.Mode mode, int max_frames);
 
+		public abstract ThreadCommandResult Step (StepMode mode, StepFrame frame);
+
 		// <summary>
 		//   Step one machine instruction, but don't step into trampolines.
 		// </summary>
diff --git a/backend/arch/CoreFile.cs b/backend/arch/CoreFile.cs
index 8b38e17..59979dc 100644
--- a/backend/arch/CoreFile.cs
+++ b/backend/arch/CoreFile.cs
@@ -504,6 +504,11 @@ namespace Mono.Debugger.Backend
 				throw new InvalidOperationException ();
 			}
 
+			public override ThreadCommandResult Step (StepMode mode, StepFrame frame)
+			{
+				throw new InvalidOperationException ();
+			}
+
 			public override void StepInstruction (CommandResult result)
 			{
 				throw new InvalidOperationException ();
diff --git a/backend/StepFrame.cs b/classes/StepFrame.cs
similarity index 95%
rename from backend/StepFrame.cs
rename to classes/StepFrame.cs
index e615e60..1ee0cf0 100644
--- a/backend/StepFrame.cs
+++ b/classes/StepFrame.cs
@@ -5,9 +5,9 @@ using System.Text;
 using Mono.Debugger;
 using Mono.Debugger.Languages;
 
-namespace Mono.Debugger.Backend
+namespace Mono.Debugger
 {
-	internal enum StepMode
+	public enum StepMode
 	{
 		// <summary>
 		//   Step a single machine instruction, but step over trampolines.
@@ -46,7 +46,8 @@ namespace Mono.Debugger.Backend
 		Finish
 	}
 
-	internal sealed class StepFrame
+	[Serializable]
+	public sealed class StepFrame
 	{
 		TargetAddress start, end;
 		Language language;
diff --git a/classes/Thread.cs b/classes/Thread.cs
index d6d0168..7067aed 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -290,69 +290,62 @@ namespace Mono.Debugger
 			}
 		}
 
+		public ThreadCommandResult Step (StepMode mode)
+		{
+			return Step (mode, null);
+		}
+
+		public ThreadCommandResult Step (StepMode mode, StepFrame frame)
+		{
+			lock (this) {
+				check_alive ();
+				return servant.Step (mode, frame);
+			}
+		}
+
 		// <summary>
 		//   Step one machine instruction, but don't step into trampolines.
 		// </summary>
+		[Obsolete("Use Step (StepMode.SingleInstruction)")]
 		public ThreadCommandResult StepInstruction ()
 		{
-			lock (this) {
-				check_alive ();
-				ThreadCommandResult result = new OperationCommandResult (this);
-				servant.StepInstruction (result);
-				return result;
-			}
+			return Step (StepMode.SingleInstruction);
 		}
 
 		// <summary>
 		//   Step one machine instruction, always step into method calls.
 		// </summary>
+		[Obsolete("Use Step (StepMode.NativeInstruction)")]
 		public ThreadCommandResult StepNativeInstruction ()
 		{
-			lock (this) {
-				check_alive ();
-				ThreadCommandResult result = new OperationCommandResult (this);
-				servant.StepNativeInstruction (result);
-				return result;
-			}
+			return Step (StepMode.NativeInstruction);
 		}
 
 		// <summary>
 		//   Step one machine instruction, but step over method calls.
 		// </summary>
+		[Obsolete("Use Step (StepMode.NextInstruction)")]
 		public ThreadCommandResult NextInstruction ()
 		{
-			lock (this) {
-				check_alive ();
-				ThreadCommandResult result = new OperationCommandResult (this);
-				servant.NextInstruction (result);
-				return result;
-			}
+			return Step (StepMode.NextInstruction);
 		}
 
 		// <summary>
 		//   Step one source line.
 		// </summary>
+		[Obsolete("Use Step (StepMode.SourceLine)")]
 		public ThreadCommandResult StepLine ()
 		{
-			lock (this) {
-				check_alive ();
-				ThreadCommandResult result = new OperationCommandResult (this);
-				servant.StepLine (result);
-				return result;
-			}
+			return Step (StepMode.SourceLine);
 		}
 
 		// <summary>
 		//   Step one source line, but step over method calls.
 		// </summary>
+		[Obsolete("Use Step (StepMode.NextLine)")]
 		public ThreadCommandResult NextLine ()
 		{
-			lock (this) {
-				check_alive ();
-				ThreadCommandResult result = new OperationCommandResult (this);
-				servant.NextLine (result);
-				return result;
-			}
+			return Step (StepMode.NextLine);
 		}
 
 		// <summary>

--------------1.5.6--



From 95cecbd510a7f633f805af34012339bff02d9594 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 8 Jul 2009 15:57:40 +0200
Subject: [PATCH] Add 'StepMode.Run'.
 2009-07-08  Martin Baulig  <martin@ximian.com>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit


	* classes/StepFrame.cs
	(StepMode.Run): Added.
	(StepFrame.Until): New public property; only valid in`
	StepMode.Run'.

	* classes/Thread.cs
	(Thread.Continue): Use `Step (StepMode.Run)'.
	(Thread.Background): Obsolete; this was never implemented and
	always the same as Continue().

	* backend/SingleSteppingEngine.cs
	(SSE.OperationStep): Add support for `StepMode.Run'; this
	obsoletes `OperationRun'.
---
 ChangeLog                       |   16 +++++++++++++++
 backend/SingleSteppingEngine.cs |   41 +++++++++++++++++++++++++++++++++++---
 classes/StepFrame.cs            |   18 +++++++++++++++++
 classes/Thread.cs               |   23 +++++++--------------
 4 files changed, 79 insertions(+), 19 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="95cecbd510a7f633f805af34012339bff02d9594.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="95cecbd510a7f633f805af34012339bff02d9594.diff"

diff --git a/ChangeLog b/ChangeLog
index 5ed89af..fc3d591 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,5 +1,21 @@
 2009-07-08  Martin Baulig  <martin@ximian.com>
 
+	* classes/StepFrame.cs
+	(StepMode.Run): Added.
+	(StepFrame.Until): New public property; only valid in`
+	StepMode.Run'.
+
+	* classes/Thread.cs
+	(Thread.Continue): Use `Step (StepMode.Run)'.
+	(Thread.Background): Obsolete; this was never implemented and
+	always the same as Continue().
+
+	* backend/SingleSteppingEngine.cs
+	(SSE.OperationStep): Add support for `StepMode.Run'; this
+	obsoletes `OperationRun'.
+
+2009-07-08  Martin Baulig  <martin@ximian.com>
+
 	* backend/StepFrame.cs: Moved to ../classes/StepFrame.cs.
 
 	* classes/StepFrame.cs
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 4b4189b..f10f36c 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -3169,13 +3169,21 @@ namespace Mono.Debugger.Backend
 			get {
 				return (StepMode == StepMode.SourceLine) ||
 					(StepMode == StepMode.NextLine) ||
-					(StepMode == StepMode.Finish);
+					(StepMode == StepMode.Finish) ||
+					(StepMode == StepMode.Run);
 			}
 		}
 
 		protected override void DoExecute ()
 		{
 			switch (StepMode) {
+			case StepMode.Run:
+				if (StepFrame != null)
+					sse.do_continue (StepFrame.Until);
+				else
+					sse.do_continue ();
+				break;
+
 			case StepMode.NativeInstruction:
 				sse.do_step_native ();
 				break;
@@ -3228,7 +3236,7 @@ namespace Mono.Debugger.Backend
 			Report.Debug (DebugFlags.SSE, "{0} resuming operation {1}", sse, this);
 
 			if (sse.temp_breakpoint != null) {
-				inferior.Continue ();
+				sse.do_continue ();
 				return true;
 			}
 
@@ -3237,6 +3245,8 @@ namespace Mono.Debugger.Backend
 
 		public override bool HandleException (TargetAddress stack, TargetAddress exc)
 		{
+			if (StepMode == StepMode.Run)
+				return false;
 			if ((StepMode != StepMode.SourceLine) && (StepMode != StepMode.NextLine) &&
 			    (StepMode != StepMode.StepFrame))
 				return true;
@@ -3305,10 +3315,16 @@ namespace Mono.Debugger.Backend
 
 		protected bool Step (bool first)
 		{
-			if (StepFrame == null)
+			TargetAddress current_frame = inferior.CurrentFrame;
+
+			if (StepMode == StepMode.Run) {
+				TargetAddress until = StepFrame != null ? StepFrame.Until : TargetAddress.Null;
+				if (!until.IsNull && (current_frame == until))
 				return true;
+				sse.do_continue ();
+				return false;
+			}
 
-			TargetAddress current_frame = inferior.CurrentFrame;
 			again:
 			bool in_frame = sse.is_in_step_frame (StepFrame, current_frame);
 			Report.Debug (DebugFlags.SSE, "{0} stepping at {1} in {2} ({3}in frame)",
@@ -3401,6 +3417,23 @@ namespace Mono.Debugger.Backend
 			return false;
 		}
 
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.EventLoop, "{0} received {1} at {2} in {3}",
+				      sse, cevent, inferior.CurrentFrame, this);
+
+			if ((StepMode == StepMode.Run) &&
+			    ((cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) ||
+			     (cevent.Type == Inferior.ChildEventType.CHILD_CALLBACK) ||
+			     (cevent.Type == Inferior.ChildEventType.RUNTIME_INVOKE_DONE))) {
+				args = null;
+				return EventResult.Completed;
+			}
+
+			return base.DoProcessEvent (cevent, out args);
+		}
+
 		protected override bool DoProcessEvent ()
 		{
 			Report.Debug (DebugFlags.SSE, "{0} processing {1} event.",
diff --git a/classes/StepFrame.cs b/classes/StepFrame.cs
index 1ee0cf0..732798b 100644
--- a/classes/StepFrame.cs
+++ b/classes/StepFrame.cs
@@ -10,6 +10,11 @@ namespace Mono.Debugger
 	public enum StepMode
 	{
 		// <summary>
+		//   Resume the target and run until an optional end location.
+		// </summary>
+		Run,
+
+		// <summary>
 		//   Step a single machine instruction, but step over trampolines.
 		// </summary>
 		SingleInstruction,
@@ -58,6 +63,10 @@ namespace Mono.Debugger
 			: this (TargetAddress.Null, TargetAddress.Null, null, language, mode)
 		{ }
 
+		internal StepFrame (Language language, TargetAddress until)
+			: this (TargetAddress.Null, until, null, language, StepMode.Run)
+		{ }
+
 		internal StepFrame (TargetAddress start, TargetAddress end, StackFrame stack,
 				    Language language, StepMode mode)
 		{
@@ -86,6 +95,15 @@ namespace Mono.Debugger
 			}
 		}
 
+		public TargetAddress Until {
+			get {
+				if (mode != StepMode.Run)
+					throw new InvalidOperationException ();
+
+				return end;
+			}
+		}
+
 		public StackFrame StackFrame {
 			get {
 				return stack;
diff --git a/classes/Thread.cs b/classes/Thread.cs
index 7067aed..340af9e 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -361,35 +361,28 @@ namespace Mono.Debugger
 			}
 		}
 
+		[Obsolete("Use Step (StepMode.Run)")]
 		public ThreadCommandResult Continue ()
 		{
-			return Continue (TargetAddress.Null);
+			return Step (StepMode.Run);
 		}
 
+		[Obsolete("Use the new Step() API")]
 		public ThreadCommandResult Continue (TargetAddress until)
 		{
-			lock (this) {
-				check_alive ();
-				ThreadCommandResult result = new OperationCommandResult (this);
-				servant.Continue (until, result);
-				return result;
-			}
+			return Step (StepMode.Run, new StepFrame (NativeLanguage, until));
 		}
 
+		[Obsolete("Background() and Continue() are the same")]
 		public ThreadCommandResult Background ()
 		{
-			return Background (TargetAddress.Null);
+			return Continue ();
 		}
 
+		[Obsolete("Background() and Continue() are the same")]
 		public ThreadCommandResult Background (TargetAddress until)
 		{
-			lock (this) {
-				check_alive ();
-				flags |= Flags.Background;
-				ThreadCommandResult result = new OperationCommandResult (this);
-				servant.Background (until, result);
-				return result;
-			}
+			return Continue (until);
 		}
 
 		internal void Kill ()

--------------1.5.6--



From 7dc483c876129824139c776e70ff04c0d77cdce7 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 8 Jul 2009 16:08:37 +0200
Subject: [PATCH] Removed 'SSE.OperationRun'; use 'OperationStep' with 'StepMode.Run' instead.
 2009-07-08  Martin Baulig  <martin@ximian.com>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit


	* backend/SingleSteppingEngine.cs
	(SSE.OperationRun): Removed; use `OperationStep' with `StepMode.Run'.

	* backend/ThreadServant.cs
	(ThreadServant.StepInstruction): Removed, use the new Step() API.
	(ThreadServant.StepNativeInstruction): Likewise.
	(ThreadServant.NextInstruction): Likewise.
	(ThreadServant.StepLine): Likewise.
	(ThreadServant.NextLine): Likewise.
---
 ChangeLog                       |   12 ++++
 backend/SingleSteppingEngine.cs |  116 +-------------------------------------
 backend/ThreadServant.cs        |   34 ++----------
 backend/arch/CoreFile.cs        |   35 ------------
 classes/GUIManager.cs           |    6 +-
 5 files changed, 24 insertions(+), 179 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="7dc483c876129824139c776e70ff04c0d77cdce7.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="7dc483c876129824139c776e70ff04c0d77cdce7.diff"

diff --git a/ChangeLog b/ChangeLog
index fc3d591..08eafa7 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,5 +1,17 @@
 2009-07-08  Martin Baulig  <martin@ximian.com>
 
+	* backend/SingleSteppingEngine.cs
+	(SSE.OperationRun): Removed; use `OperationStep' with `StepMode.Run'.
+
+	* backend/ThreadServant.cs
+	(ThreadServant.StepInstruction): Removed, use the new Step() API.
+	(ThreadServant.StepNativeInstruction): Likewise.
+	(ThreadServant.NextInstruction): Likewise.
+	(ThreadServant.StepLine): Likewise.
+	(ThreadServant.NextLine): Likewise.
+
+2009-07-08  Martin Baulig  <martin@ximian.com>
+
 	* classes/StepFrame.cs
 	(StepMode.Run): Added.
 	(StepFrame.Until): New public property; only valid in`
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index f10f36c..dbb362b 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -124,7 +124,7 @@ namespace Mono.Debugger.Backend
 		{
 			CommandResult result = new ThreadCommandResult (thread);
 			if (resume_thread)
-				current_operation = new OperationRun (this, result);
+				current_operation = new OperationStep (this, StepMode.Run, result);
 			else
 				current_operation = new OperationInitialize (this, result);
 			current_operation.Execute ();
@@ -134,7 +134,7 @@ namespace Mono.Debugger.Backend
 		public CommandResult StartForkedChild ()
 		{
 			CommandResult result = new ThreadCommandResult (thread);
-			current_operation = new OperationRun (this, result);
+			current_operation = new OperationStep (this, StepMode.Run, result);
 			PushOperation (new OperationInitAfterFork (this));
 			return result;
 		}
@@ -1132,7 +1132,7 @@ namespace Mono.Debugger.Backend
 			registers = inferior.GetRegisters ();
 
 			if ((operation != null) && !main_retaddr.IsNull && (iframe.StackPointer >= main_retaddr))
-				return new OperationRun (this, false, operation.Result);
+				return new OperationStep (this, StepMode.Run, operation.Result);
 
 			// Compute the current stack frame.
 			if ((current_method != null) && current_method.HasLineNumbers) {
@@ -1689,46 +1689,11 @@ namespace Mono.Debugger.Backend
 			return result;
 		}
 
-		public override void StepInstruction (CommandResult result)
-		{
-			StartOperation (new OperationStep (this, StepMode.SingleInstruction, result));
-		}
-
-		public override void StepNativeInstruction (CommandResult result)
-		{
-			StartOperation (new OperationStep (this, StepMode.NativeInstruction, result));
-		}
-
-		public override void NextInstruction (CommandResult result)
-		{
-			StartOperation (new OperationStep (this, StepMode.NextInstruction, result));
-		}
-
-		public override void StepLine (CommandResult result)
-		{
-			StartOperation (new OperationStep (this, StepMode.SourceLine, result));
-		}
-
-		public override void NextLine (CommandResult result)
-		{
-			StartOperation (new OperationStep (this, StepMode.NextLine, result));
-		}
-
 		public override void Finish (bool native, CommandResult result)
 		{
 			StartOperation (new OperationFinish (this, native, result));
 		}
 
-		public override void Continue (TargetAddress until, CommandResult result)
-		{
-			StartOperation (new OperationRun (this, until, false, result));
-		}
-
-		public override void Background (TargetAddress until, CommandResult result)
-		{
-			StartOperation (new OperationRun (this, until, true, result));
-		}
-
 		public override void RuntimeInvoke (TargetFunctionType function,
 						    TargetStructObject object_argument,
 						    TargetObject[] param_objects,
@@ -2757,7 +2722,7 @@ namespace Mono.Debugger.Backend
 			}
 
 			Report.Debug (DebugFlags.SSE, "{0} start #1: {1}", sse, cevent);
-			sse.PushOperation (new OperationRun (sse, true, Result));
+			sse.PushOperation (new OperationStep (sse, StepMode.Run, Result));
 			return EventResult.Running;
 		}
 
@@ -3447,79 +3412,6 @@ namespace Mono.Debugger.Backend
 		}
 	}
 
-	protected class OperationRun : Operation
-	{
-		TargetAddress until;
-		bool in_background;
-
-		public override bool CheckBreakpointsOnCompletion {
-			get { return true; }
-		}
-
-		public OperationRun (SingleSteppingEngine sse, TargetAddress until,
-				     bool in_background, CommandResult result)
-			: base (sse, result)
-		{
-			this.until = until;
-			this.in_background = in_background;
-		}
-
-		public OperationRun (SingleSteppingEngine sse, bool in_background,
-				     CommandResult result)
-			: this (sse, TargetAddress.Null, in_background, result)
-		{ }
-
-		public OperationRun (SingleSteppingEngine sse, CommandResult result)
-			: this (sse, TargetAddress.Null, true, result)
-		{ }
-
-
-		public bool InBackground {
-			get { return in_background; }
-		}
-
-		public override bool IsSourceOperation {
-			get { return true; }
-		}
-
-		protected override void DoExecute ()
-		{
-			if (!until.IsNull)
-				sse.do_continue (until);
-			else
-				sse.do_continue ();
-		}
-
-		public override bool ResumeOperation ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} resuming operation {1}", sse, this);
-
-			sse.do_continue ();
-			return true;
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			args = null;
-			if (!until.IsNull && inferior.CurrentFrame == until)
-				return EventResult.Completed;
-			Report.Debug (DebugFlags.EventLoop, "{0} received {1} at {2} in {3}",
-				      sse, cevent, inferior.CurrentFrame, this);
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) ||
-			    (cevent.Type == Inferior.ChildEventType.CHILD_CALLBACK) ||
-			    (cevent.Type == Inferior.ChildEventType.RUNTIME_INVOKE_DONE))
-				return EventResult.Completed;
-			Execute ();
-			return EventResult.Running;
-		}
-
-		public override bool HandleException (TargetAddress stack, TargetAddress exc)
-		{
-			return false;
-		}
-	}
-
 	protected class OperationFinish : OperationStepBase
 	{
 		public readonly bool Native;
diff --git a/backend/ThreadServant.cs b/backend/ThreadServant.cs
index d3433cb..3399ff6 100644
--- a/backend/ThreadServant.cs
+++ b/backend/ThreadServant.cs
@@ -150,42 +150,18 @@ namespace Mono.Debugger.Backend
 
 		public abstract Backtrace GetBacktrace (Backtrace.Mode mode, int max_frames);
 
-		public abstract ThreadCommandResult Step (StepMode mode, StepFrame frame);
-
-		// <summary>
-		//   Step one machine instruction, but don't step into trampolines.
-		// </summary>
-		public abstract void StepInstruction (CommandResult result);
-
-		// <summary>
-		//   Step one machine instruction, always step into method calls.
-		// </summary>
-		public abstract void StepNativeInstruction (CommandResult result);
-
-		// <summary>
-		//   Step one machine instruction, but step over method calls.
-		// </summary>
-		public abstract void NextInstruction (CommandResult result);
-
-		// <summary>
-		//   Step one source line.
-		// </summary>
-		public abstract void StepLine (CommandResult result);
+		public ThreadCommandResult Step (StepMode mode)
+		{
+			return Step (mode, null);
+		}
 
-		// <summary>
-		//   Step one source line, but step over method calls.
-		// </summary>
-		public abstract void NextLine (CommandResult result);
+		public abstract ThreadCommandResult Step (StepMode mode, StepFrame frame);
 
 		// <summary>
 		//   Continue until leaving the current method.
 		// </summary>
 		public abstract void Finish (bool native, CommandResult result);
 
-		public abstract void Continue (TargetAddress until, CommandResult result);
-
-		public abstract void Background (TargetAddress until, CommandResult result);
-
 		public abstract void Kill ();
 
 		public abstract void Detach ();
diff --git a/backend/arch/CoreFile.cs b/backend/arch/CoreFile.cs
index 59979dc..d48c9f2 100644
--- a/backend/arch/CoreFile.cs
+++ b/backend/arch/CoreFile.cs
@@ -509,46 +509,11 @@ namespace Mono.Debugger.Backend
 				throw new InvalidOperationException ();
 			}
 
-			public override void StepInstruction (CommandResult result)
-			{
-				throw new InvalidOperationException ();
-			}
-
-			public override void StepNativeInstruction (CommandResult result)
-			{
-				throw new InvalidOperationException ();
-			}
-
-			public override void NextInstruction (CommandResult result)
-			{
-				throw new InvalidOperationException ();
-			}
-
-			public override void StepLine (CommandResult result)
-			{
-				throw new InvalidOperationException ();
-			}
-
-			public override void NextLine (CommandResult result)
-			{
-				throw new InvalidOperationException ();
-			}
-
 			public override void Finish (bool native, CommandResult result)
 			{
 				throw new InvalidOperationException ();
 			}
 
-			public override void Continue (TargetAddress until, CommandResult result)
-			{
-				throw new InvalidOperationException ();
-			}
-
-			public override void Background (TargetAddress until, CommandResult result)
-			{
-				throw new InvalidOperationException ();
-			}
-
 			public override void Kill ()
 			{ }
 
diff --git a/classes/GUIManager.cs b/classes/GUIManager.cs
index 9abcef9..87f0a75 100644
--- a/classes/GUIManager.cs
+++ b/classes/GUIManager.cs
@@ -352,7 +352,7 @@ namespace Mono.Debugger
 		{
 			protected override void DoRun ()
 			{
-				Thread.ThreadServant.Continue (TargetAddress.Null, null);
+				Thread.ThreadServant.Step (StepMode.Run);
 			}
 		}
 
@@ -360,7 +360,7 @@ namespace Mono.Debugger
 		{
 			protected override void DoRun ()
 			{
-				Thread.ThreadServant.StepLine (null);
+				Thread.ThreadServant.Step (StepMode.SourceLine);
 			}
 		}
 
@@ -368,7 +368,7 @@ namespace Mono.Debugger
 		{
 			protected override void DoRun ()
 			{
-				Thread.ThreadServant.NextLine (null);
+				Thread.ThreadServant.Step (StepMode.NextLine);
 			}
 		}
 

--------------1.5.6--



From 6f14a6db78f2d8002feaf06522efb8eaa8ad022d Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 8 Jul 2009 18:08:53 +0200
Subject: [PATCH] Merge 'SSE.OperationFinish' into 'OperationStep'; add 'StepMode.FinishNative'.
 2009-07-08  Martin Baulig  <martin@ximian.com>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit


	* classes/StepFrame.cs
	(StepMode.FinishNative): Added.

	* backend/SingleSteppingEngine.cs
	(SSE.OperationFinish): Removed; use `OperationStep' with
	`StepMode.Finish' or `StepMode.FinishNative'.

	* backend/ThreadServant.cs
	(ThreadServant.Finish): Removed, use the new Step() API.

	* classes/Thread.cs
	(Thread.Finish): Use the new Step() API.
---
 ChangeLog                       |   15 ++++++
 backend/SingleSteppingEngine.cs |  107 ++++++---------------------------------
 backend/ThreadServant.cs        |    5 --
 backend/arch/CoreFile.cs        |    5 --
 classes/GUIManager.cs           |    6 ++-
 classes/StepFrame.cs            |   22 ++++++---
 classes/Thread.cs               |   21 +++++++-
 7 files changed, 68 insertions(+), 113 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="6f14a6db78f2d8002feaf06522efb8eaa8ad022d.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="6f14a6db78f2d8002feaf06522efb8eaa8ad022d.diff"

diff --git a/ChangeLog b/ChangeLog
index 08eafa7..29b5e30 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,5 +1,20 @@
 2009-07-08  Martin Baulig  <martin@ximian.com>
 
+	* classes/StepFrame.cs
+	(StepMode.FinishNative): Added.
+
+	* backend/SingleSteppingEngine.cs
+	(SSE.OperationFinish): Removed; use `OperationStep' with
+	`StepMode.Finish' or `StepMode.FinishNative'.
+
+	* backend/ThreadServant.cs
+	(ThreadServant.Finish): Removed, use the new Step() API.
+
+	* classes/Thread.cs
+	(Thread.Finish): Use the new Step() API.
+
+2009-07-08  Martin Baulig  <martin@ximian.com>
+
 	* backend/SingleSteppingEngine.cs
 	(SSE.OperationRun): Removed; use `OperationStep' with `StepMode.Run'.
 
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index dbb362b..ff17575 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1689,11 +1689,6 @@ namespace Mono.Debugger.Backend
 			return result;
 		}
 
-		public override void Finish (bool native, CommandResult result)
-		{
-			StartOperation (new OperationFinish (this, native, result));
-		}
-
 		public override void RuntimeInvoke (TargetFunctionType function,
 						    TargetStructObject object_argument,
 						    TargetObject[] param_objects,
@@ -3188,6 +3183,7 @@ namespace Mono.Debugger.Backend
 				break;
 
 			case StepMode.Finish:
+			case StepMode.FinishNative:
 				Step (true);
 				break;
 
@@ -3290,6 +3286,20 @@ namespace Mono.Debugger.Backend
 				return false;
 			}
 
+			if (StepMode == StepMode.FinishNative) {
+				Inferior.StackFrame frame = inferior.GetCurrentFrame ();
+				TargetAddress stack = frame.StackPointer;
+
+				Report.Debug (DebugFlags.SSE,
+					      "{0} finish native: stack = {1}, " +
+					      "until = {2}", sse, stack, StepFrame.Until);
+
+				if (stack <= StepFrame.Until) {
+					sse.do_next ();
+					return false;
+				}
+			}
+
 		again:
 			bool in_frame = sse.is_in_step_frame (StepFrame, current_frame);
 			Report.Debug (DebugFlags.SSE, "{0} stepping at {1} in {2} ({3}in frame)",
@@ -3412,93 +3422,6 @@ namespace Mono.Debugger.Backend
 		}
 	}
 
-	protected class OperationFinish : OperationStepBase
-	{
-		public readonly bool Native;
-
-		public OperationFinish (SingleSteppingEngine sse, bool native, CommandResult result)
-			: base (sse, result)
-		{
-			this.Native = native;
-		}
-
-		public override bool IsSourceOperation {
-			get { return !Native; }
-		}
-
-		StepFrame step_frame;
-		TargetAddress until;
-
-		protected override void DoExecute ()
-		{
-			if (!Native) {
-				StackFrame frame = sse.CurrentFrame;
-				if (frame.Method == null)
-					throw new TargetException (TargetError.NoMethod);
-
-				step_frame = new StepFrame (
-					frame.Method.StartAddress, frame.Method.EndAddress,
-					frame, null, StepMode.Finish);
-			} else {
-				Inferior.StackFrame frame = inferior.GetCurrentFrame ();
-				until = frame.StackPointer;
-
-				Report.Debug (DebugFlags.SSE,
-					      "{0} starting finish native until {1} {2}",
-					      sse, until, sse.temp_breakpoint);
-			}
-
-			sse.do_next ();
-		}
-
-		public override bool ResumeOperation ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} resuming operation {1}", sse, this);
-
-			if (sse.temp_breakpoint != null) {
-				inferior.Continue ();
-				return true;
-			}
-
-			return !DoProcessEvent ();
-		}
-
-		protected override bool DoProcessEvent ()
-		{
-			if (step_frame != null) {
-				bool in_frame = sse.is_in_step_frame (step_frame, inferior.CurrentFrame);
-				Report.Debug (DebugFlags.SSE,
-					      "{0} finish {1} at {2} ({3}", sse, step_frame,
-					      inferior.CurrentFrame, in_frame);
-
-				if (!in_frame)
-					return true;
-
-				sse.do_next ();
-				return false;
-			}
-
-			Inferior.StackFrame frame = inferior.GetCurrentFrame ();
-			TargetAddress stack = frame.StackPointer;
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} finish native: stack = {1}, " +
-				      "until = {2}", sse, stack, until);
-
-			if (stack <= until) {
-				sse.do_next ();
-				return false;
-			}
-
-			return true;
-		}
-
-		protected override bool TrampolineHandler (Method method)
-		{
-			return false;
-		}
-	}
-
 	protected abstract class OperationCallback : Operation
 	{
 		public readonly long ID = ++next_id;
diff --git a/backend/ThreadServant.cs b/backend/ThreadServant.cs
index 3399ff6..3976a12 100644
--- a/backend/ThreadServant.cs
+++ b/backend/ThreadServant.cs
@@ -157,11 +157,6 @@ namespace Mono.Debugger.Backend
 
 		public abstract ThreadCommandResult Step (StepMode mode, StepFrame frame);
 
-		// <summary>
-		//   Continue until leaving the current method.
-		// </summary>
-		public abstract void Finish (bool native, CommandResult result);
-
 		public abstract void Kill ();
 
 		public abstract void Detach ();
diff --git a/backend/arch/CoreFile.cs b/backend/arch/CoreFile.cs
index d48c9f2..abb741e 100644
--- a/backend/arch/CoreFile.cs
+++ b/backend/arch/CoreFile.cs
@@ -509,11 +509,6 @@ namespace Mono.Debugger.Backend
 				throw new InvalidOperationException ();
 			}
 
-			public override void Finish (bool native, CommandResult result)
-			{
-				throw new InvalidOperationException ();
-			}
-
 			public override void Kill ()
 			{ }
 
diff --git a/classes/GUIManager.cs b/classes/GUIManager.cs
index 87f0a75..88fe107 100644
--- a/classes/GUIManager.cs
+++ b/classes/GUIManager.cs
@@ -376,7 +376,11 @@ namespace Mono.Debugger
 		{
 			protected override void DoRun ()
 			{
-				Thread.ThreadServant.Finish (false, null);
+				StepFrame step_frame = new StepFrame (
+					Thread.CurrentMethod.StartAddress, Thread.CurrentMethod.EndAddress,
+					Thread.CurrentFrame, null, StepMode.Finish);
+
+				Thread.ThreadServant.Step (StepMode.Finish, step_frame);
 			}
 		}
 
diff --git a/classes/StepFrame.cs b/classes/StepFrame.cs
index 732798b..b8a4074 100644
--- a/classes/StepFrame.cs
+++ b/classes/StepFrame.cs
@@ -48,7 +48,9 @@ namespace Mono.Debugger
 		//   Single-step until leaving the specified step frame and never enter any
 		//   methods.
 		// </summary>
-		Finish
+		Finish,
+
+		FinishNative
 	}
 
 	[Serializable]
@@ -59,16 +61,16 @@ namespace Mono.Debugger
 		StackFrame stack;
 		StepMode mode;
 
-		internal StepFrame (Language language, StepMode mode)
+		public StepFrame (Language language, StepMode mode)
 			: this (TargetAddress.Null, TargetAddress.Null, null, language, mode)
 		{ }
 
-		internal StepFrame (Language language, TargetAddress until)
-			: this (TargetAddress.Null, until, null, language, StepMode.Run)
+		public StepFrame (Language language, StepMode mode, TargetAddress until)
+			: this (TargetAddress.Null, until, null, language, mode)
 		{ }
 
-		internal StepFrame (TargetAddress start, TargetAddress end, StackFrame stack,
-				    Language language, StepMode mode)
+		public StepFrame (Language language, StepMode mode, StackFrame stack,
+				  TargetAddress start, TargetAddress end)
 		{
 			this.start = start;
 			this.end = end;
@@ -77,6 +79,12 @@ namespace Mono.Debugger
 			this.mode = mode;
 		}
 
+		[Obsolete]
+		internal StepFrame (TargetAddress start, TargetAddress end, StackFrame stack,
+				    Language language, StepMode mode)
+			: this (language, mode, stack, start, end)
+		{ }
+
 		public StepMode Mode {
 			get {
 				return mode;
@@ -97,7 +105,7 @@ namespace Mono.Debugger
 
 		public TargetAddress Until {
 			get {
-				if (mode != StepMode.Run)
+				if ((mode != StepMode.Run) && (mode != StepMode.FinishNative))
 					throw new InvalidOperationException ();
 
 				return end;
diff --git a/classes/Thread.cs b/classes/Thread.cs
index 340af9e..6959f77 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -356,8 +356,23 @@ namespace Mono.Debugger
 			lock (this) {
 				check_alive ();
 				ThreadCommandResult result = new OperationCommandResult (this);
-				servant.Finish (native, result);
-				return result;
+
+				if (!native) {
+					if (CurrentMethod == null)
+						throw new TargetException (TargetError.NoMethod);
+
+					StepFrame step_frame = new StepFrame (
+						CurrentMethod.StartAddress, CurrentMethod.EndAddress,
+						CurrentFrame, null, StepMode.Finish);
+
+					return Step (StepMode.Finish, step_frame);
+				} else {
+					StepFrame step_frame = new StepFrame (
+						CurrentFrame.Language, StepMode.FinishNative,
+						CurrentFrame.StackPointer);
+
+					return Step (StepMode.FinishNative, step_frame);
+				}
 			}
 		}
 
@@ -370,7 +385,7 @@ namespace Mono.Debugger
 		[Obsolete("Use the new Step() API")]
 		public ThreadCommandResult Continue (TargetAddress until)
 		{
-			return Step (StepMode.Run, new StepFrame (NativeLanguage, until));
+			return Step (StepMode.Run, new StepFrame (NativeLanguage, StepMode.Run, until));
 		}
 
 		[Obsolete("Background() and Continue() are the same")]

--------------1.5.6--



From d3468a18ed9f298fb1123839d324f3c93daf5360 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 8 Jul 2009 18:20:16 +0200
Subject: [PATCH] Remove the StepFrame's obsolete .ctor.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |   31 +++++++++++++++++--------------
 classes/GUIManager.cs           |    4 ++--
 classes/StepFrame.cs            |   10 ++--------
 classes/Thread.cs               |    6 +++---
 4 files changed, 24 insertions(+), 27 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="d3468a18ed9f298fb1123839d324f3c93daf5360.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="d3468a18ed9f298fb1123839d324f3c93daf5360.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index ff17575..c7af647 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1223,23 +1223,26 @@ namespace Mono.Debugger.Backend
 				// happens when returning from a method call; in this
 				// case, we need to continue stepping until we reach the
 				// next source line.
-				return new OperationStep (this, new StepFrame (
-					address - source.LineOffset, address + source.LineRange,
-					null, language, StepMode.SourceLine), operation.Result);
+				StepFrame sframe = new StepFrame (
+					language, StepMode.SourceLine, null,
+					address - source.LineOffset, address + source.LineRange);
+				return new OperationStep (this, sframe, operation.Result);
 			}
 
 			LineNumberTable lnt = method.LineNumberTable;
 			if (lnt.HasMethodBounds && (address < lnt.MethodStartAddress)) {
-				return new OperationStep (this, new StepFrame (
-					method.StartAddress, lnt.MethodStartAddress, null,
-					null, StepMode.Finish), operation.Result);
+				StepFrame sframe = new StepFrame (
+					null, StepMode.Finish, null,
+					method.StartAddress, lnt.MethodStartAddress);
+				return new OperationStep (this, sframe, operation.Result);
 			} else if (method.HasMethodBounds && (address < method.MethodStartAddress)) {
 				// Do not stop inside a method's prologue code, but stop
 				// immediately behind it (on the first instruction of the
 				// method's actual code).
-				return new OperationStep (this, new StepFrame (
-					method.StartAddress, method.MethodStartAddress, null,
-					null, StepMode.Finish), operation.Result);
+				StepFrame sframe = new StepFrame (
+					null, StepMode.Finish, null,
+					method.StartAddress, method.MethodStartAddress);
+				return new OperationStep (this, sframe, operation.Result);
 			}
 
 			return null;
@@ -1454,7 +1457,7 @@ namespace Mono.Debugger.Backend
 			TargetAddress start = frame.TargetAddress - offset;
 			TargetAddress end = frame.TargetAddress + range;
 
-			return new StepFrame (start, end, frame, language, StepMode.StepFrame);
+			return new StepFrame (language, StepMode.StepFrame, frame, start, end);
 		}
 
 		// <summary>
@@ -3171,8 +3174,8 @@ namespace Mono.Debugger.Backend
 					sse.do_next ();
 				else {
 					StepFrame = new StepFrame (
-						frame.Start, frame.End, frame.StackFrame,
-						null, StepMode.Finish);
+						null, StepMode.Finish, frame.StackFrame,
+						frame.Start, frame.End);
 					Step (true);
 				}
 				break;
@@ -3266,8 +3269,8 @@ namespace Mono.Debugger.Backend
 				Report.Debug (DebugFlags.SSE, "{0} reached method epilogue: {1} {2} {3}",
 					      sse, current_frame, lnt.MethodEndAddress, method.EndAddress);
 				StepFrame = new StepFrame (
-					lnt.MethodEndAddress, method.EndAddress,
-					null, null, StepMode.Finish);
+					null, StepMode.Finish, null,
+					lnt.MethodEndAddress, method.EndAddress);
 				return true;
 			}
 
diff --git a/classes/GUIManager.cs b/classes/GUIManager.cs
index 88fe107..bc3696d 100644
--- a/classes/GUIManager.cs
+++ b/classes/GUIManager.cs
@@ -377,8 +377,8 @@ namespace Mono.Debugger
 			protected override void DoRun ()
 			{
 				StepFrame step_frame = new StepFrame (
-					Thread.CurrentMethod.StartAddress, Thread.CurrentMethod.EndAddress,
-					Thread.CurrentFrame, null, StepMode.Finish);
+					null, StepMode.Finish, null,
+					Thread.CurrentMethod.StartAddress, Thread.CurrentMethod.EndAddress);
 
 				Thread.ThreadServant.Step (StepMode.Finish, step_frame);
 			}
diff --git a/classes/StepFrame.cs b/classes/StepFrame.cs
index b8a4074..52aa2a3 100644
--- a/classes/StepFrame.cs
+++ b/classes/StepFrame.cs
@@ -62,11 +62,11 @@ namespace Mono.Debugger
 		StepMode mode;
 
 		public StepFrame (Language language, StepMode mode)
-			: this (TargetAddress.Null, TargetAddress.Null, null, language, mode)
+			: this (language, mode, null, TargetAddress.Null, TargetAddress.Null)
 		{ }
 
 		public StepFrame (Language language, StepMode mode, TargetAddress until)
-			: this (TargetAddress.Null, until, null, language, mode)
+			: this (language, mode, null, TargetAddress.Null, until)
 		{ }
 
 		public StepFrame (Language language, StepMode mode, StackFrame stack,
@@ -79,12 +79,6 @@ namespace Mono.Debugger
 			this.mode = mode;
 		}
 
-		[Obsolete]
-		internal StepFrame (TargetAddress start, TargetAddress end, StackFrame stack,
-				    Language language, StepMode mode)
-			: this (language, mode, stack, start, end)
-		{ }
-
 		public StepMode Mode {
 			get {
 				return mode;
diff --git a/classes/Thread.cs b/classes/Thread.cs
index 6959f77..4ef21b0 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -362,13 +362,13 @@ namespace Mono.Debugger
 						throw new TargetException (TargetError.NoMethod);
 
 					StepFrame step_frame = new StepFrame (
-						CurrentMethod.StartAddress, CurrentMethod.EndAddress,
-						CurrentFrame, null, StepMode.Finish);
+						null, StepMode.Finish, null,
+						CurrentMethod.StartAddress, CurrentMethod.EndAddress);
 
 					return Step (StepMode.Finish, step_frame);
 				} else {
 					StepFrame step_frame = new StepFrame (
-						CurrentFrame.Language, StepMode.FinishNative,
+						null, StepMode.FinishNative,
 						CurrentFrame.StackPointer);
 
 					return Step (StepMode.FinishNative, step_frame);

--------------1.5.6--



From d159731d62b93432627a1fbaa0cd8a6fbaf360e1 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 9 Jul 2009 05:49:01 +0200
Subject: [PATCH] Start to introduce new Step() API.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |   39 ++++++++++++++++++++++++++++-
 backend/ThreadServant.cs        |    7 +----
 backend/arch/CoreFile.cs        |    7 ++++-
 classes/GUIManager.cs           |    8 +++---
 classes/Thread.cs               |   51 ++++++++++++++++++++++++++-------------
 5 files changed, 83 insertions(+), 29 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="d159731d62b93432627a1fbaa0cd8a6fbaf360e1.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="d159731d62b93432627a1fbaa0cd8a6fbaf360e1.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index d57f82b..fc4ae88 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1792,13 +1792,18 @@ namespace Mono.Debugger.Backend
 
 #region SSE Commands
 
-		public override ThreadCommandResult Step (StepMode mode, StepFrame frame)
+		internal override ThreadCommandResult Old_Step (StepMode mode, StepFrame frame)
 		{
-			ThreadCommandResult result = new OperationCommandResult (thread);
+			ThreadCommandResult result = new OldOperationCommandResult (thread);
 			StartOperation (new OperationStep (this, mode, frame, result));
 			return result;
 		}
 
+		public override CommandResult Step (ThreadingModel model, StepMode mode, StepFrame frame)
+		{
+			return StartOperation (new OperationStep (this, model, mode, frame));
+		}
+
 		public override void RuntimeInvoke (TargetFunctionType function,
 						    TargetStructObject object_argument,
 						    TargetObject[] param_objects,
@@ -2514,6 +2519,32 @@ namespace Mono.Debugger.Backend
 #endregion
 
 #region SSE Operations
+	protected class OperationCommandResult : CommandResult
+	{
+		public SingleSteppingEngine SSE;
+
+		protected ManualResetEvent completed_event = new ManualResetEvent (false);
+
+		internal OperationCommandResult (SingleSteppingEngine sse)
+		{
+			this.SSE = sse;
+		}
+
+		public override WaitHandle CompletedEvent {
+			get { return completed_event; }
+		}
+
+		internal override void Completed ()
+		{
+			completed_event.Set ();
+		}
+
+		public override void Abort ()
+		{
+			throw new NotImplementedException ("FUCK");
+		}
+	}
+
 	protected abstract class Operation {
 		public enum EventResult
 		{
@@ -3255,6 +3286,10 @@ namespace Mono.Debugger.Backend
 			this.StepMode = mode;
 		}
 
+		public OperationStep (SingleSteppingEngine sse, ThreadingModel model, StepMode mode, StepFrame frame)
+			: this (sse, mode, frame, new OperationCommandResult (sse))
+		{ }
+
 		public override bool IsSourceOperation {
 			get {
 				return (StepMode == StepMode.SourceLine) ||
diff --git a/backend/ThreadServant.cs b/backend/ThreadServant.cs
index 13ff534..aff9e80 100644
--- a/backend/ThreadServant.cs
+++ b/backend/ThreadServant.cs
@@ -150,12 +150,9 @@ namespace Mono.Debugger.Backend
 
 		public abstract Backtrace GetBacktrace (Backtrace.Mode mode, int max_frames);
 
-		public ThreadCommandResult Step (StepMode mode)
-		{
-			return Step (mode, null);
-		}
+		public abstract CommandResult Step (ThreadingModel model, StepMode mode, StepFrame frame);
 
-		public abstract ThreadCommandResult Step (StepMode mode, StepFrame frame);
+		internal abstract ThreadCommandResult Old_Step (StepMode mode, StepFrame frame);
 
 		public abstract void Kill ();
 
diff --git a/backend/arch/CoreFile.cs b/backend/arch/CoreFile.cs
index cfcb2cb..97dcbcd 100644
--- a/backend/arch/CoreFile.cs
+++ b/backend/arch/CoreFile.cs
@@ -504,7 +504,12 @@ namespace Mono.Debugger.Backend
 				throw new InvalidOperationException ();
 			}
 
-			public override ThreadCommandResult Step (StepMode mode, StepFrame frame)
+			public override CommandResult Step (ThreadingModel model, StepMode mode, StepFrame frame)
+			{
+				throw new InvalidOperationException ();
+			}
+
+			internal override ThreadCommandResult Old_Step (StepMode mode, StepFrame frame)
 			{
 				throw new InvalidOperationException ();
 			}
diff --git a/classes/GUIManager.cs b/classes/GUIManager.cs
index 1173508..ae46c6c 100644
--- a/classes/GUIManager.cs
+++ b/classes/GUIManager.cs
@@ -352,7 +352,7 @@ namespace Mono.Debugger
 		{
 			protected override void DoRun ()
 			{
-				Thread.ThreadServant.Step (StepMode.Run);
+				Thread.ThreadServant.Old_Step (StepMode.Run, null);
 			}
 		}
 
@@ -360,7 +360,7 @@ namespace Mono.Debugger
 		{
 			protected override void DoRun ()
 			{
-				Thread.ThreadServant.Step (StepMode.SourceLine);
+				Thread.ThreadServant.Old_Step (StepMode.SourceLine, null);
 			}
 		}
 
@@ -368,7 +368,7 @@ namespace Mono.Debugger
 		{
 			protected override void DoRun ()
 			{
-				Thread.ThreadServant.Step (StepMode.NextLine);
+				Thread.ThreadServant.Old_Step (StepMode.NextLine, null);
 			}
 		}
 
@@ -380,7 +380,7 @@ namespace Mono.Debugger
 					null, StepMode.Finish, null,
 					Thread.CurrentMethod.StartAddress, Thread.CurrentMethod.EndAddress);
 
-				Thread.ThreadServant.Step (StepMode.Finish, step_frame);
+				Thread.ThreadServant.Old_Step (StepMode.Finish, step_frame);
 			}
 		}
 
diff --git a/classes/Thread.cs b/classes/Thread.cs
index bb04971..f303d1b 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -18,6 +18,16 @@ namespace Mono.Debugger
 	[Serializable]
 	internal delegate object TargetAccessDelegate (Thread target, object user_data);
 
+	[Flags]
+	public enum ThreadingModel
+	{
+		Default			= 0,
+		Single			= 1,
+		Process			= 2,
+		Global			= 4,
+		SuspendAll		= 8
+	}
+
 	public class Thread : DebuggerMarshalByRefObject
 	{
 		[Flags]
@@ -286,16 +296,24 @@ namespace Mono.Debugger
 			}
 		}
 
-		public ThreadCommandResult Step (StepMode mode)
+		public CommandResult Step (ThreadingModel model, StepMode mode, StepFrame frame)
+		{
+			lock (this) {
+				check_alive ();
+				return servant.Step (model, mode, frame);
+			}
+		}
+
+		protected ThreadCommandResult Old_Step (StepMode mode)
 		{
-			return Step (mode, null);
+			return Old_Step (mode, null);
 		}
 
-		public ThreadCommandResult Step (StepMode mode, StepFrame frame)
+		protected ThreadCommandResult Old_Step (StepMode mode, StepFrame frame)
 		{
 			lock (this) {
 				check_alive ();
-				return servant.Step (mode, frame);
+				return servant.Old_Step (mode, frame);
 			}
 		}
 
@@ -305,7 +323,7 @@ namespace Mono.Debugger
 		[Obsolete("Use Step (StepMode.SingleInstruction)")]
 		public ThreadCommandResult StepInstruction ()
 		{
-			return Step (StepMode.SingleInstruction);
+			return Old_Step (StepMode.SingleInstruction);
 		}
 
 		// <summary>
@@ -314,7 +332,7 @@ namespace Mono.Debugger
 		[Obsolete("Use Step (StepMode.NativeInstruction)")]
 		public ThreadCommandResult StepNativeInstruction ()
 		{
-			return Step (StepMode.NativeInstruction);
+			return Old_Step (StepMode.NativeInstruction);
 		}
 
 		// <summary>
@@ -323,7 +341,7 @@ namespace Mono.Debugger
 		[Obsolete("Use Step (StepMode.NextInstruction)")]
 		public ThreadCommandResult NextInstruction ()
 		{
-			return Step (StepMode.NextInstruction);
+			return Old_Step (StepMode.NextInstruction);
 		}
 
 		// <summary>
@@ -332,7 +350,7 @@ namespace Mono.Debugger
 		[Obsolete("Use Step (StepMode.SourceLine)")]
 		public ThreadCommandResult StepLine ()
 		{
-			return Step (StepMode.SourceLine);
+			return Old_Step (StepMode.SourceLine);
 		}
 
 		// <summary>
@@ -341,7 +359,7 @@ namespace Mono.Debugger
 		[Obsolete("Use Step (StepMode.NextLine)")]
 		public ThreadCommandResult NextLine ()
 		{
-			return Step (StepMode.NextLine);
+			return Old_Step (StepMode.NextLine);
 		}
 
 		// <summary>
@@ -351,7 +369,6 @@ namespace Mono.Debugger
 		{
 			lock (this) {
 				check_alive ();
-				ThreadCommandResult result = new OperationCommandResult (this);
 
 				if (!native) {
 					if (CurrentMethod == null)
@@ -361,13 +378,13 @@ namespace Mono.Debugger
 						null, StepMode.Finish, null,
 						CurrentMethod.StartAddress, CurrentMethod.EndAddress);
 
-					return Step (StepMode.Finish, step_frame);
+					return Old_Step (StepMode.Finish, step_frame);
 				} else {
 					StepFrame step_frame = new StepFrame (
 						null, StepMode.FinishNative,
 						CurrentFrame.StackPointer);
 
-					return Step (StepMode.FinishNative, step_frame);
+					return Old_Step (StepMode.FinishNative, step_frame);
 				}
 			}
 		}
@@ -375,13 +392,13 @@ namespace Mono.Debugger
 		[Obsolete("Use Step (StepMode.Run)")]
 		public ThreadCommandResult Continue ()
 		{
-			return Step (StepMode.Run);
+			return Old_Step (StepMode.Run);
 		}
 
 		[Obsolete("Use the new Step() API")]
 		public ThreadCommandResult Continue (TargetAddress until)
 		{
-			return Step (StepMode.Run, new StepFrame (NativeLanguage, StepMode.Run, until));
+			return Old_Step (StepMode.Run, new StepFrame (NativeLanguage, StepMode.Run, until));
 		}
 
 		[Obsolete("Background() and Continue() are the same")]
@@ -840,11 +857,11 @@ namespace Mono.Debugger
 		}
 	}
 
-	public class OperationCommandResult : ThreadCommandResult
+	public class OldOperationCommandResult : ThreadCommandResult
 	{
 		protected ST.ManualResetEvent completed_event = new ST.ManualResetEvent (false);
 
-		internal OperationCommandResult (Thread thread)
+		internal OldOperationCommandResult (Thread thread)
 			: base (thread)
 		{ }
 
@@ -858,7 +875,7 @@ namespace Mono.Debugger
 		}
 	}
 
-	public class RuntimeInvokeResult : OperationCommandResult
+	public class RuntimeInvokeResult : OldOperationCommandResult
 	{
 		internal RuntimeInvokeResult (Thread thread)
 			: base (thread)

--------------1.5.6--



From 7972990eda6ec1fefacc07390eb3888d84c71697 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 9 Jul 2009 05:56:26 +0200
Subject: [PATCH] Use the new Step() API here.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 frontend/Command.cs          |   41 +++++++++++++++--------------------------
 frontend/ScriptingContext.cs |    9 +++++++++
 2 files changed, 24 insertions(+), 26 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="7972990eda6ec1fefacc07390eb3888d84c71697.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="7972990eda6ec1fefacc07390eb3888d84c71697.diff"

diff --git a/frontend/Command.cs b/frontend/Command.cs
index dd75c66..a6ec805 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -1307,30 +1307,22 @@ namespace Mono.Debugger.Frontend
 		protected override object DoExecute (ScriptingContext context)
 		{
 			Thread thread = CurrentThread;
-			ThreadCommandResult result = DoStep (thread, context);
+			CommandResult result = DoStep (thread, context);
 			if (in_background)
 				return result;
 
-			if (context.Interpreter.DebuggerConfiguration.BrokenThreading) {
-				Process process = context.Interpreter.WaitAll (result.Thread.Process);
-				if (process == null)
-					return null;
-
-				return process;
-			}
-
-			context.Interpreter.WaitOne (result.Thread);
-			return result.Thread;
+			context.Interpreter.Wait (result);
+			return result;
 		}
 
-		protected abstract ThreadCommandResult DoStep (Thread thread, ScriptingContext context);
+		protected abstract CommandResult DoStep (Thread thread, ScriptingContext context);
 	}
 
 	public class ContinueCommand : SteppingCommand, IDocumentableCommand
 	{
-		protected override ThreadCommandResult DoStep (Thread thread, ScriptingContext context)
+		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
 		{
-			return thread.Continue ();
+			return thread.Step (context.ThreadingModel, StepMode.Run, null);
 		}
 
 		// IDocumentableCommand
@@ -1341,10 +1333,10 @@ namespace Mono.Debugger.Frontend
 
 	public class StepCommand : SteppingCommand, IDocumentableCommand
 	{
-		protected override ThreadCommandResult DoStep (Thread thread, ScriptingContext context)
+		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
 		{
 			context.Interpreter.Style.IsNative = false;
-			return thread.StepLine ();
+			return thread.Step (context.ThreadingModel, StepMode.SourceLine, null);
 		}
 
 		// IDocumentableCommand
@@ -1355,10 +1347,10 @@ namespace Mono.Debugger.Frontend
 
 	public class NextCommand : SteppingCommand, IDocumentableCommand
 	{
-		protected override ThreadCommandResult DoStep (Thread thread, ScriptingContext context)
+		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
 		{
 			context.Interpreter.Style.IsNative = false;
-			return thread.NextLine ();
+			return thread.Step (context.ThreadingModel, StepMode.NextLine, null);
 		}
 
 		// IDocumentableCommand
@@ -1376,13 +1368,10 @@ namespace Mono.Debugger.Frontend
 			set { native = value; }
 		}
 
-		protected override ThreadCommandResult DoStep (Thread thread, ScriptingContext context)
+		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
 		{
 			context.Interpreter.Style.IsNative = true;
-			if (Native)
-				return thread.StepNativeInstruction ();
-			else
-				return thread.StepInstruction ();
+			return thread.Step (context.ThreadingModel, Native ? StepMode.NativeInstruction : StepMode.SingleInstruction, null);
 		}
 
 		// IDocumentableCommand
@@ -1393,10 +1382,10 @@ namespace Mono.Debugger.Frontend
 
 	public class NextInstructionCommand : SteppingCommand, IDocumentableCommand
 	{
-		protected override ThreadCommandResult DoStep (Thread thread, ScriptingContext context)
+		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
 		{
 			context.Interpreter.Style.IsNative = true;
-			return thread.NextInstruction ();
+			return thread.Step (context.ThreadingModel, StepMode.NextInstruction, null);
 		}
 
 		// IDocumentableCommand
@@ -1414,7 +1403,7 @@ namespace Mono.Debugger.Frontend
 			set { native = value; }
 		}
 
-		protected override ThreadCommandResult DoStep (Thread thread, ScriptingContext context)
+		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
 		{
 			return thread.Finish (Native);
 		}
diff --git a/frontend/ScriptingContext.cs b/frontend/ScriptingContext.cs
index f9f9d9e..6290b32 100644
--- a/frontend/ScriptingContext.cs
+++ b/frontend/ScriptingContext.cs
@@ -185,6 +185,15 @@ namespace Mono.Debugger.Frontend
 			}
 		}
 
+		public ThreadingModel ThreadingModel {
+			get {
+				if (Interpreter.DebuggerConfiguration.BrokenThreading)
+					return ThreadingModel.Process;
+				else
+					return ThreadingModel.Single;
+			}
+		}
+
 		public string[] GetNamespaces ()
 		{
 			if (HasFrame) {

--------------1.5.6--



From 68460005450faa08b86f8843f66de2ebbfe22efb Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 9 Jul 2009 05:56:54 +0200
Subject: [PATCH] Use the new Step() API here.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="68460005450faa08b86f8843f66de2ebbfe22efb.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="68460005450faa08b86f8843f66de2ebbfe22efb.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index fc4ae88..b47b285 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1801,6 +1801,7 @@ namespace Mono.Debugger.Backend
 
 		public override CommandResult Step (ThreadingModel model, StepMode mode, StepFrame frame)
 		{
+			Console.WriteLine ("STEP: {0} {1} {2} {3}", this, model, mode, frame);
 			return StartOperation (new OperationStep (this, model, mode, frame));
 		}
 

--------------1.5.6--



From d5f7c77a89d417dfa8f863e37e69c6a43bc50af1 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 9 Jul 2009 06:21:50 +0200
Subject: [PATCH] Some more work ...
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |   11 ++++++--
 backend/SingleSteppingEngine.cs |   49 +++++++++++++++++++++++++++++++++-----
 backend/ThreadManager.cs        |    8 +++---
 3 files changed, 54 insertions(+), 14 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="d5f7c77a89d417dfa8f863e37e69c6a43bc50af1.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="d5f7c77a89d417dfa8f863e37e69c6a43bc50af1.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index e778f02..f2fff5a 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -656,22 +656,27 @@ namespace Mono.Debugger.Backend
 			}
 		}
 
-		internal void SuspendUserThreads (SingleSteppingEngine caller)
+		internal void SuspendUserThreads (ThreadingModel model, SingleSteppingEngine caller)
 		{
 			Report.Debug (DebugFlags.Threads,
-				      "Suspending user threads: {0}", caller);
+				      "Suspending user threads: {0} {1}", model, caller);
 
+			if ((model & ThreadingModel.Process) != 0) {
 			foreach (SingleSteppingEngine engine in thread_hash.Values) {
 				if (engine == caller)
 					continue;
+					if (((engine.Thread.ThreadFlags & Thread.Flags.Immutable) != 0) &&
+					    ((model & ThreadingModel.SuspendAll) == 0))
+						continue;
 				engine.SuspendUserThread ();
 				engine.Thread.ThreadFlags |= Thread.Flags.AutoRun;
 			}
+			}
 
 			caller.Thread.ThreadFlags |= Thread.Flags.AutoRun;
 
 			Report.Debug (DebugFlags.Threads,
-				      "Done suspending user threads: {0}", caller);
+				      "Done suspending user threads: {0} {1}", model, caller);
 
 			stopped_event.Set ();
 		}
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index b47b285..31379a9 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -273,7 +273,7 @@ namespace Mono.Debugger.Backend
 				}
 
 				if (current_operation != rti)
-					current_operation.CompletedOperation ();
+					current_operation.Result.Completed ();
 				current_operation = rti;
 
 				TargetEventArgs args = null;
@@ -583,6 +583,7 @@ namespace Mono.Debugger.Backend
 					process.OnEnterNestedBreakState (this);
 					((InterruptibleOperation) current_operation).IsSuspended = true;
 					nested_break_stack.Push ((InterruptibleOperation) current_operation);
+					current_operation.CompletedOperation (true);
 					current_operation = null;
 				} else {
 					if (result != null)
@@ -590,13 +591,15 @@ namespace Mono.Debugger.Backend
 					if (current_operation != null) {
 						Report.Debug (DebugFlags.EventLoop, "{0} setting completed: {1} {2}",
 							      this, current_operation, current_operation.Result);
-						current_operation.CompletedOperation ();
+						current_operation.CompletedOperation (false);
 						current_operation = null;
 					}
 				}
 
+#if FIXME
 				if (stop_all)
 					manager.StopAllThreads (this);
+#endif
 			}
 		}
 
@@ -2625,11 +2628,13 @@ namespace Mono.Debugger.Backend
 				child = op;
 		}
 
-		public void CompletedOperation ()
+		public virtual void CompletedOperation (bool suspended)
 		{
+			if (!suspended) {
 			Result.Completed ();
 			child = null;
 		}
+		}
 
 		public virtual EventResult ProcessEvent (Inferior.ChildEvent cevent,
 							 out TargetEventArgs args)
@@ -2835,6 +2840,12 @@ namespace Mono.Debugger.Backend
 				sse.ProcessEvent (new Inferior.ChildEvent (Inferior.ChildEventType.CHILD_STOPPED, 0, 0, 0));
 		}
 
+		public override void CompletedOperation (bool suspended)
+		{
+			sse.manager.StopAllThreads (ThreadingModel.Process, sse);
+			base.CompletedOperation (suspended);
+		}
+
 		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
 							       out TargetEventArgs args)
 		{
@@ -3240,7 +3251,6 @@ namespace Mono.Debugger.Backend
 		public override void Execute ()
 		{
 			Report.Debug (DebugFlags.SSE, "{0} start stepping operation: {1}", sse, this);
-			sse.manager.ResumeAllThreads (sse);
 			base.Execute ();
 		}
 
@@ -3264,8 +3274,11 @@ namespace Mono.Debugger.Backend
 
 	protected class OperationStep : OperationStepBase
 	{
-		public StepMode StepMode;
-		public StepFrame StepFrame;
+		public readonly ThreadingModel ThreadingModel = ThreadingModel.Default;
+		public readonly StepMode StepMode;
+		public StepFrame StepFrame {
+			get; private set;
+		}
 
 		public OperationStep (SingleSteppingEngine sse, StepMode mode, CommandResult result)
 			: base (sse, result)
@@ -3289,7 +3302,9 @@ namespace Mono.Debugger.Backend
 
 		public OperationStep (SingleSteppingEngine sse, ThreadingModel model, StepMode mode, StepFrame frame)
 			: this (sse, mode, frame, new OperationCommandResult (sse))
-		{ }
+		{
+			this.ThreadingModel = model;
+		}
 
 		public override bool IsSourceOperation {
 			get {
@@ -3300,6 +3315,26 @@ namespace Mono.Debugger.Backend
 			}
 		}
 
+		public override void Execute ()
+		{
+			if (ThreadingModel == ThreadingModel.Process) {
+				sse.manager.ResumeAllThreads (sse);
+			}
+
+			base.Execute ();
+		}
+
+		public override void CompletedOperation (bool suspended)
+		{
+			Report.Debug (DebugFlags.SSE, "{0} step completed - {1} {2}", sse, suspended, ThreadingModel);
+
+			if (ThreadingModel == ThreadingModel.Process) {
+				sse.manager.StopAllThreads (ThreadingModel, sse);
+			}
+
+			base.CompletedOperation (suspended);
+		}
+
 		protected override void DoExecute ()
 		{
 			Report.Debug (DebugFlags.SSE, "{0} step execute: {1}", sse, inferior.CurrentFrame);
diff --git a/backend/ThreadManager.cs b/backend/ThreadManager.cs
index ef96721..0354e6b 100644
--- a/backend/ThreadManager.cs
+++ b/backend/ThreadManager.cs
@@ -629,15 +629,15 @@ namespace Mono.Debugger.Backend
 
 		bool stopped_all_threads;
 
-		internal void StopAllThreads (SingleSteppingEngine engine)
+		internal void StopAllThreads (ThreadingModel model, SingleSteppingEngine caller)
 		{
-			Report.Debug (DebugFlags.SSE, "Stopping all threads: {0}", engine);
+			Report.Debug (DebugFlags.SSE, "Stopping all threads: {0} {1}", model, caller);
 
-			engine.Process.SuspendUserThreads (engine);
+			caller.Process.SuspendUserThreads (model, caller);
 			stopped_all_threads = true;
 
 			Report.Debug (DebugFlags.SSE, "Stopped all threads: {0} {1}",
-				      engine, engine.Inferior.CurrentFrame);
+				      model, caller.Inferior.CurrentFrame);
 		}
 
 		internal void ResumeAllThreads (SingleSteppingEngine engine)

--------------1.5.6--



From 7e9560d0f905325033c347cd68c0707d61fc2b84 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 9 Jul 2009 16:01:26 +0200
Subject: [PATCH] la la la
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |   90 +++++++++++++++++++++++++++++++++++++-
 backend/SingleSteppingEngine.cs |   33 +++------------
 backend/ThreadManager.cs        |    4 ++
 classes/Thread.cs               |    9 +++-
 4 files changed, 104 insertions(+), 32 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="7e9560d0f905325033c347cd68c0707d61fc2b84.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="7e9560d0f905325033c347cd68c0707d61fc2b84.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index f2fff5a..810d41d 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -313,7 +313,10 @@ namespace Mono.Debugger.Backend
 			session.OnMainProcessCreated (client);
 			manager.Debugger.OnMainProcessCreatedEvent (this);
 
-			engine.StartApplication ();
+			current_state = ProcessState.Running;
+			current_model = ThreadingModel.Process;
+
+			current_operation = engine.StartApplication ();
 		}
 
 		internal void OnProcessExitedEvent ()
@@ -656,7 +659,86 @@ namespace Mono.Debugger.Backend
 			}
 		}
 
-		internal void SuspendUserThreads (ThreadingModel model, SingleSteppingEngine caller)
+#region User Threads
+
+		internal enum ProcessState
+		{
+			Unknown,
+			SingleThreaded,
+			Running,
+			Stopped
+		}
+
+		ProcessState current_state = ProcessState.Unknown;
+		ThreadingModel current_model = ThreadingModel.Default;
+		CommandResult current_operation = null;
+
+		internal void StartOperation (ThreadingModel model, SingleSteppingEngine caller, CommandResult result)
+		{
+			Console.WriteLine ("START PROCESS: {0} {1} - {2} {3}", current_model, current_state, caller, model);
+
+#if FIXME
+			if ((model != ThreadingModel.Default) && current_model != ThreadingModel.Default)
+				throw new TargetException (TargetError.NotStopped, "Cannot start new process operation.");
+#endif
+
+			switch (model & ThreadingModel.ThreadingMode) {
+			case ThreadingModel.Default:
+				break;
+				goto case ThreadingModel.Single;
+
+			case ThreadingModel.Single:
+				current_model = model & ThreadingModel.ThreadingMode; // ThreadingModel.Default;
+				current_state = ProcessState.SingleThreaded;
+				return;
+
+			case ThreadingModel.Process:
+				current_model = ThreadingModel.Process;
+				current_state = ProcessState.Running;
+				current_operation = result;
+				ResumeUserThreads (caller);
+				break;
+
+			default:
+				throw new InternalError ();
+			}
+		}
+
+		internal void OperationCompleted (SingleSteppingEngine caller)
+		{
+			Console.WriteLine ("PROCESS COMPLETED: {0} {1} - {2}", current_model, current_state, caller);
+
+			if (current_state == ProcessState.Running) {
+				current_model = ThreadingModel.Default;
+				current_state = ProcessState.Stopped;
+				SuspendUserThreads (ThreadingModel.Process, caller);
+				current_operation.Completed ();
+				current_operation = null;
+			}
+
+			return;
+
+			switch (current_model & ThreadingModel.ThreadingMode) {
+			case ThreadingModel.Default:
+				goto case ThreadingModel.Single;
+
+			case ThreadingModel.Single:
+				return;
+
+			case ThreadingModel.Process:
+				current_model = ThreadingModel.Default;
+				current_state = ProcessState.Stopped;
+				SuspendUserThreads (ThreadingModel.Process, caller);
+				current_operation.Completed ();
+				current_operation = null;
+				break;
+
+			default:
+				throw new InternalError ();
+			}
+		}
+
+		protected void SuspendUserThreads (ThreadingModel model, SingleSteppingEngine caller)
 		{
 			Report.Debug (DebugFlags.Threads,
 				      "Suspending user threads: {0} {1}", model, caller);
@@ -681,7 +763,7 @@ namespace Mono.Debugger.Backend
 			stopped_event.Set ();
 		}
 
-		internal void ResumeUserThreads (SingleSteppingEngine caller)
+		protected void ResumeUserThreads (SingleSteppingEngine caller)
 		{
 			stopped_event.Reset ();
 
@@ -704,6 +786,8 @@ namespace Mono.Debugger.Backend
 				      "Resumed user threads: {0}", caller);
 		}
 
+#endregion
+
 		public void ActivatePendingBreakpoints (CommandResult result)
 		{
 			((SingleSteppingEngine) main_thread).ManagedCallback (
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 31379a9..a11eef6 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -122,13 +122,12 @@ namespace Mono.Debugger.Backend
 
 		public CommandResult StartThread (bool resume_thread)
 		{
-			CommandResult result = new ThreadCommandResult (thread);
 			if (resume_thread)
-				current_operation = new OperationStep (this, StepMode.Run, result);
+				current_operation = new OperationStep (this, ThreadingModel.Default, StepMode.Run, null);
 			else
-				current_operation = new OperationInitialize (this, result);
+				current_operation = new OperationInitialize (this, new ThreadCommandResult (thread));
 			current_operation.Execute ();
-			return result;
+			return current_operation.Result;
 		}
 
 		public CommandResult StartForkedChild ()
@@ -596,6 +595,8 @@ namespace Mono.Debugger.Backend
 					}
 				}
 
+				process.OperationCompleted (this);
+
 #if FIXME
 				if (stop_all)
 					manager.StopAllThreads (this);
@@ -728,8 +729,6 @@ namespace Mono.Debugger.Backend
 			StartOperation ();
 
 			return (CommandResult) SendCommand (delegate {
-				// manager.ResumeAllThreads (this);
-
 				return ProcessOperation (operation);
 			});
 		}
@@ -2840,12 +2839,6 @@ namespace Mono.Debugger.Backend
 				sse.ProcessEvent (new Inferior.ChildEvent (Inferior.ChildEventType.CHILD_STOPPED, 0, 0, 0));
 		}
 
-		public override void CompletedOperation (bool suspended)
-		{
-			sse.manager.StopAllThreads (ThreadingModel.Process, sse);
-			base.CompletedOperation (suspended);
-		}
-
 		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
 							       out TargetEventArgs args)
 		{
@@ -3317,24 +3310,10 @@ namespace Mono.Debugger.Backend
 
 		public override void Execute ()
 		{
-			if (ThreadingModel == ThreadingModel.Process) {
-				sse.manager.ResumeAllThreads (sse);
-			}
-
+			sse.process.StartOperation (ThreadingModel, sse, Result);
 			base.Execute ();
 		}
 
-		public override void CompletedOperation (bool suspended)
-		{
-			Report.Debug (DebugFlags.SSE, "{0} step completed - {1} {2}", sse, suspended, ThreadingModel);
-
-			if (ThreadingModel == ThreadingModel.Process) {
-				sse.manager.StopAllThreads (ThreadingModel, sse);
-			}
-
-			base.CompletedOperation (suspended);
-		}
-
 		protected override void DoExecute ()
 		{
 			Report.Debug (DebugFlags.SSE, "{0} step execute: {1}", sse, inferior.CurrentFrame);
diff --git a/backend/ThreadManager.cs b/backend/ThreadManager.cs
index 0354e6b..7c096c5 100644
--- a/backend/ThreadManager.cs
+++ b/backend/ThreadManager.cs
@@ -627,6 +627,8 @@ namespace Mono.Debugger.Backend
 
 #region Stopping / Starting threads
 
+#if FIXME
+
 		bool stopped_all_threads;
 
 		internal void StopAllThreads (ThreadingModel model, SingleSteppingEngine caller)
@@ -651,6 +653,8 @@ namespace Mono.Debugger.Backend
 			stopped_all_threads = false;
 		}
 
+#endif
+
 #endregion
 
 #region IDisposable implementation
diff --git a/classes/Thread.cs b/classes/Thread.cs
index f303d1b..ec5107f 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -24,8 +24,13 @@ namespace Mono.Debugger
 		Default			= 0,
 		Single			= 1,
 		Process			= 2,
-		Global			= 4,
-		SuspendAll		= 8
+		Global			= 3,
+
+		SuspendAll		= 0x0100,
+		ResumeThreads		= 0x0200,
+
+		ThreadingMode		= 0x00FF,
+		ThreadingFlags		= 0xFF00
 	}
 
 	public class Thread : DebuggerMarshalByRefObject

--------------1.5.6--



From 99ece38450b9f9bcaf55cd4d6fb8105b6d30d668 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 9 Jul 2009 16:25:58 +0200
Subject: [PATCH] la la la
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |   68 +++++++++++++++++++++++++++++++++++---
 backend/SingleSteppingEngine.cs |   37 ++++++++++++--------
 2 files changed, 84 insertions(+), 21 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="99ece38450b9f9bcaf55cd4d6fb8105b6d30d668.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="99ece38450b9f9bcaf55cd4d6fb8105b6d30d668.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 810d41d..9fe031c 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -26,7 +26,6 @@ namespace Mono.Debugger.Backend
 		SymbolTableManager symtab_manager;
 		MonoThreadManager mono_manager;
 		BreakpointManager breakpoint_manager;
-		ST.ManualResetEvent stopped_event;
 		Dictionary<int,ExceptionCatchPoint> exception_handlers;
 		ProcessStart start;
 		DebuggerSession session;
@@ -316,7 +315,8 @@ namespace Mono.Debugger.Backend
 			current_state = ProcessState.Running;
 			current_model = ThreadingModel.Process;
 
-			current_operation = engine.StartApplication ();
+			current_operation = new ProcessOperationResult (this);
+			engine.StartApplication (current_operation);
 		}
 
 		internal void OnProcessExitedEvent ()
@@ -666,13 +666,18 @@ namespace Mono.Debugger.Backend
 			Unknown,
 			SingleThreaded,
 			Running,
+			Stopping,
 			Stopped
 		}
 
+		protected ST.ManualResetEvent stopped_event;
+
 		ProcessState current_state = ProcessState.Unknown;
 		ThreadingModel current_model = ThreadingModel.Default;
 		CommandResult current_operation = null;
 
+#if FIXME
+
 		internal void StartOperation (ThreadingModel model, SingleSteppingEngine caller, CommandResult result)
 		{
 			Console.WriteLine ("START PROCESS: {0} {1} - {2} {3}", current_model, current_state, caller, model);
@@ -704,14 +709,21 @@ namespace Mono.Debugger.Backend
 			}
 		}
 
+#endif
+
 		internal void OperationCompleted (SingleSteppingEngine caller)
 		{
+			if (!ThreadManager.InBackgroundThread)
+				throw new InternalError ();
+
 			Console.WriteLine ("PROCESS COMPLETED: {0} {1} - {2}", current_model, current_state, caller);
 
 			if (current_state == ProcessState.Running) {
-				current_model = ThreadingModel.Default;
-				current_state = ProcessState.Stopped;
+				current_state = ProcessState.Stopping;
+				Console.WriteLine ("SUSPEND THREADS: {0}", caller);
 				SuspendUserThreads (ThreadingModel.Process, caller);
+				Console.WriteLine ("SUSPEND THREADS DONE: {0} {1}", caller, current_operation);
+				current_state = ProcessState.Stopped;
 				current_operation.Completed ();
 				current_operation = null;
 			}
@@ -760,12 +772,12 @@ namespace Mono.Debugger.Backend
 			Report.Debug (DebugFlags.Threads,
 				      "Done suspending user threads: {0} {1}", model, caller);
 
-			stopped_event.Set ();
+			// stopped_event.Set ();
 		}
 
 		protected void ResumeUserThreads (SingleSteppingEngine caller)
 		{
-			stopped_event.Reset ();
+			// stopped_event.Reset ();
 
 			Report.Debug (DebugFlags.Threads,
 				      "Resuming user threads: {0}", caller);
@@ -786,6 +798,50 @@ namespace Mono.Debugger.Backend
 				      "Resumed user threads: {0}", caller);
 		}
 
+		internal CommandResult StartOperation (ThreadingModel model, SingleSteppingEngine caller)
+		{
+			if (!ThreadManager.InBackgroundThread)
+				throw new InternalError ();
+			if ((model & ThreadingModel.ThreadingMode) != ThreadingModel.Process)
+				throw new ArgumentException ();
+			if (current_state != ProcessState.Stopped)
+				throw new TargetException (TargetError.NotStopped);
+
+			current_model = ThreadingModel.Process;
+			current_state = ProcessState.Running;
+
+			stopped_event.Reset ();
+
+			current_operation = new ProcessOperationResult (this);
+			ResumeUserThreads (caller);
+			return current_operation;
+		}
+
+		internal class ProcessOperationResult : CommandResult
+		{
+			public readonly ProcessServant Process;
+
+			internal ProcessOperationResult (ProcessServant process)
+			{
+				this.Process = process;
+			}
+
+			public override ST.WaitHandle CompletedEvent {
+				get { return Process.WaitHandle; }
+			}
+
+			internal override void Completed ()
+			{
+				Console.WriteLine ("PROCESS RESULT SET COMPLETED");
+				Process.stopped_event.Set ();
+			}
+
+			public override void Abort ()
+			{
+				throw new NotImplementedException ("FUCK");
+			}
+		}
+
 #endregion
 
 		public void ActivatePendingBreakpoints (CommandResult result)
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index a11eef6..575ef7c 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -112,6 +112,14 @@ namespace Mono.Debugger.Backend
 			manager.AddEngine (this);
 		}
 
+		public CommandResult StartApplication (CommandResult result)
+		{
+			// CommandResult result = new ThreadCommandResult (thread);
+			current_operation = new OperationStart (this, result);
+			current_operation.Execute ();
+			return result;
+		}
+
 		public CommandResult StartApplication ()
 		{
 			CommandResult result = new ThreadCommandResult (thread);
@@ -123,7 +131,7 @@ namespace Mono.Debugger.Backend
 		public CommandResult StartThread (bool resume_thread)
 		{
 			if (resume_thread)
-				current_operation = new OperationStep (this, ThreadingModel.Default, StepMode.Run, null);
+				current_operation = new OperationStep (this, StepMode.Run, new ThreadCommandResult (thread));
 			else
 				current_operation = new OperationInitialize (this, new ThreadCommandResult (thread));
 			current_operation.Execute ();
@@ -1803,8 +1811,20 @@ namespace Mono.Debugger.Backend
 
 		public override CommandResult Step (ThreadingModel model, StepMode mode, StepFrame frame)
 		{
+			StartOperation ();
+
+			return (CommandResult) SendCommand (delegate {
 			Console.WriteLine ("STEP: {0} {1} {2} {3}", this, model, mode, frame);
-			return StartOperation (new OperationStep (this, model, mode, frame));
+
+				CommandResult result;
+				if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Process) {
+					result = process.StartOperation (model, this);
+					result = new OperationCommandResult (this);
+				} else
+					result = new ThreadCommandResult (thread);
+
+				return ProcessOperation (new OperationStep (this, mode, frame, result));
+			});
 		}
 
 		public override void RuntimeInvoke (TargetFunctionType function,
@@ -3267,7 +3287,6 @@ namespace Mono.Debugger.Backend
 
 	protected class OperationStep : OperationStepBase
 	{
-		public readonly ThreadingModel ThreadingModel = ThreadingModel.Default;
 		public readonly StepMode StepMode;
 		public StepFrame StepFrame {
 			get; private set;
@@ -3293,12 +3312,6 @@ namespace Mono.Debugger.Backend
 			this.StepMode = mode;
 		}
 
-		public OperationStep (SingleSteppingEngine sse, ThreadingModel model, StepMode mode, StepFrame frame)
-			: this (sse, mode, frame, new OperationCommandResult (sse))
-		{
-			this.ThreadingModel = model;
-		}
-
 		public override bool IsSourceOperation {
 			get {
 				return (StepMode == StepMode.SourceLine) ||
@@ -3308,12 +3321,6 @@ namespace Mono.Debugger.Backend
 			}
 		}
 
-		public override void Execute ()
-		{
-			sse.process.StartOperation (ThreadingModel, sse, Result);
-			base.Execute ();
-		}
-
 		protected override void DoExecute ()
 		{
 			Report.Debug (DebugFlags.SSE, "{0} step execute: {1}", sse, inferior.CurrentFrame);

--------------1.5.6--



From 5d99d7973d76e1ae55954e1d80d47215987b43c0 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Fri, 10 Jul 2009 20:14:00 +0200
Subject: [PATCH] Remove some dead code.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |   62 +--------------------------------------
 backend/SingleSteppingEngine.cs |    3 +-
 frontend/Interpreter.cs         |   30 -------------------
 3 files changed, 2 insertions(+), 93 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="5d99d7973d76e1ae55954e1d80d47215987b43c0.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="5d99d7973d76e1ae55954e1d80d47215987b43c0.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 9fe031c..a9e1d0b 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -292,7 +292,7 @@ namespace Mono.Debugger.Backend
 			manager.Debugger.OnThreadCreatedEvent (new_thread.Thread);
 			initialized = is_forked = false;
 
-			new_thread.StartApplication ();
+			new_thread.StartExecedChild ();
 		}
 
 		internal void StartApplication ()
@@ -676,41 +676,6 @@ namespace Mono.Debugger.Backend
 		ThreadingModel current_model = ThreadingModel.Default;
 		CommandResult current_operation = null;
 
-#if FIXME
-
-		internal void StartOperation (ThreadingModel model, SingleSteppingEngine caller, CommandResult result)
-		{
-			Console.WriteLine ("START PROCESS: {0} {1} - {2} {3}", current_model, current_state, caller, model);
-
-#if FIXME
-			if ((model != ThreadingModel.Default) && current_model != ThreadingModel.Default)
-				throw new TargetException (TargetError.NotStopped, "Cannot start new process operation.");
-#endif
-
-			switch (model & ThreadingModel.ThreadingMode) {
-			case ThreadingModel.Default:
-				break;
-				goto case ThreadingModel.Single;
-
-			case ThreadingModel.Single:
-				current_model = model & ThreadingModel.ThreadingMode; // ThreadingModel.Default;
-				current_state = ProcessState.SingleThreaded;
-				return;
-
-			case ThreadingModel.Process:
-				current_model = ThreadingModel.Process;
-				current_state = ProcessState.Running;
-				current_operation = result;
-				ResumeUserThreads (caller);
-				break;
-
-			default:
-				throw new InternalError ();
-			}
-		}
-
-#endif
-
 		internal void OperationCompleted (SingleSteppingEngine caller)
 		{
 			if (!ThreadManager.InBackgroundThread)
@@ -727,27 +692,6 @@ namespace Mono.Debugger.Backend
 				current_operation.Completed ();
 				current_operation = null;
 			}
-
-			return;
-
-			switch (current_model & ThreadingModel.ThreadingMode) {
-			case ThreadingModel.Default:
-				goto case ThreadingModel.Single;
-
-			case ThreadingModel.Single:
-				return;
-
-			case ThreadingModel.Process:
-				current_model = ThreadingModel.Default;
-				current_state = ProcessState.Stopped;
-				SuspendUserThreads (ThreadingModel.Process, caller);
-				current_operation.Completed ();
-				current_operation = null;
-				break;
-
-			default:
-				throw new InternalError ();
-			}
 		}
 
 		protected void SuspendUserThreads (ThreadingModel model, SingleSteppingEngine caller)
@@ -771,14 +715,10 @@ namespace Mono.Debugger.Backend
 
 			Report.Debug (DebugFlags.Threads,
 				      "Done suspending user threads: {0} {1}", model, caller);
-
-			// stopped_event.Set ();
 		}
 
 		protected void ResumeUserThreads (SingleSteppingEngine caller)
 		{
-			// stopped_event.Reset ();
-
 			Report.Debug (DebugFlags.Threads,
 				      "Resuming user threads: {0}", caller);
 
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 575ef7c..830478b 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -120,12 +120,11 @@ namespace Mono.Debugger.Backend
 			return result;
 		}
 
-		public CommandResult StartApplication ()
+		public void StartExecedChild ()
 		{
 			CommandResult result = new ThreadCommandResult (thread);
 			current_operation = new OperationStart (this, result);
 			current_operation.Execute ();
-			return result;
 		}
 
 		public CommandResult StartThread (bool resume_thread)
diff --git a/frontend/Interpreter.cs b/frontend/Interpreter.cs
index 133f8d2..59112d0 100644
--- a/frontend/Interpreter.cs
+++ b/frontend/Interpreter.cs
@@ -473,36 +473,6 @@ namespace Mono.Debugger.Frontend
 				} else {
 					return process;
 				}
-
-#if FIXME
-				if (ret == 0) {
-					Console.WriteLine ("INTERRUPT!");
-					return;
-					stopped = null;
-					result.Abort ();
-					result.CompletedEvent.WaitOne ();
-					break;
-				} else if (ret == 1) {
-					seen_threads = new Hashtable ();
-					process_event.Reset ();
-					goto again;
-				} else {
-					return thread;
-				}
-
-				if (result.Result is Exception)
-					throw (Exception) result.Result;
-
-				if (ret == 2)
-					stopped = thread;
-				else {
-					Console.WriteLine ("WAIT ALL FUCK!");
-					// stopped = threads [ret - 3];
-					stopped = thread;
-				}
-
-				CheckLastEvent (stopped);
-#endif
 			} while (true);
 		}
 

--------------1.5.6--



From 3895a1d0d3528ee2f8ad2b8f0f10b497289acbe0 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Fri, 10 Jul 2009 20:34:41 +0200
Subject: [PATCH] Obsolete GUIManager.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |   10 +-
 backend/SingleSteppingEngine.cs |   10 +-
 classes/Debugger.cs             |   17 ++-
 classes/GUIManager.cs           |  489 +++++++-------------------------------
 classes/Process.cs              |   20 ++-
 5 files changed, 130 insertions(+), 416 deletions(-)
 rewrite classes/GUIManager.cs (83%)
--------------1.5.6
Content-Type: text/x-patch; name="3895a1d0d3528ee2f8ad2b8f0f10b497289acbe0.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="3895a1d0d3528ee2f8ad2b8f0f10b497289acbe0.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index a9e1d0b..1ed5790 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -676,7 +676,7 @@ namespace Mono.Debugger.Backend
 		ThreadingModel current_model = ThreadingModel.Default;
 		CommandResult current_operation = null;
 
-		internal void OperationCompleted (SingleSteppingEngine caller)
+		internal void OperationCompleted (SingleSteppingEngine caller, TargetEventArgs result)
 		{
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
@@ -690,6 +690,8 @@ namespace Mono.Debugger.Backend
 				Console.WriteLine ("SUSPEND THREADS DONE: {0} {1}", caller, current_operation);
 				current_state = ProcessState.Stopped;
 				current_operation.Completed ();
+				stopped_event.Set ();
+				OnProcessEvent (caller, result);
 				current_operation = null;
 			}
 		}
@@ -773,7 +775,6 @@ namespace Mono.Debugger.Backend
 			internal override void Completed ()
 			{
 				Console.WriteLine ("PROCESS RESULT SET COMPLETED");
-				Process.stopped_event.Set ();
 			}
 
 			public override void Abort ()
@@ -822,6 +823,11 @@ namespace Mono.Debugger.Backend
 			client.OnTargetEvent (sse, args);
 		}
 
+		internal void OnProcessEvent (SingleSteppingEngine sse, TargetEventArgs args)
+		{
+			client.OnProcessEvent (sse, args);
+		}
+
 		internal void OnEnterNestedBreakState (SingleSteppingEngine sse)
 		{
 			client.OnEnterNestedBreakState (sse);
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 830478b..b0ed5dc 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -114,7 +114,6 @@ namespace Mono.Debugger.Backend
 
 		public CommandResult StartApplication (CommandResult result)
 		{
-			// CommandResult result = new ThreadCommandResult (thread);
 			current_operation = new OperationStart (this, result);
 			current_operation.Execute ();
 			return result;
@@ -571,8 +570,6 @@ namespace Mono.Debugger.Backend
 		void OperationCompleted (TargetEventArgs result, bool suspended)
 		{
 			lock (this) {
-				bool stop_all = !stop_requested && !dead && current_operation.SuspendThreadsOnCompletion;
-
 				remove_temporary_breakpoint ();
 				engine_stopped = true;
 				stop_requested = false;
@@ -602,12 +599,7 @@ namespace Mono.Debugger.Backend
 					}
 				}
 
-				process.OperationCompleted (this);
-
-#if FIXME
-				if (stop_all)
-					manager.StopAllThreads (this);
-#endif
+				process.OperationCompleted (this, result);
 			}
 		}
 
diff --git a/classes/Debugger.cs b/classes/Debugger.cs
index 9c275d2..393b0f8 100644
--- a/classes/Debugger.cs
+++ b/classes/Debugger.cs
@@ -59,9 +59,18 @@ namespace Mono.Debugger
 		public event ModuleEventHandler ModuleLoadedEvent;
 		public event ModuleEventHandler ModuleUnLoadedEvent;
 		public event DebuggerEventHandler TargetExitedEvent;
-		public event TargetEventHandler TargetEvent;
 		public event SymbolTableChangedHandler SymbolTableChanged;
 
+		//
+		// TargetEvent is sent when one thread stopped.
+		//
+		public event TargetEventHandler TargetEvent;
+
+		//
+		// ProcessEvent is sent after stopping all threads in a process.
+		//
+		public event TargetEventHandler ProcessEvent;
+
 		public event ThreadEventHandler EnterNestedBreakStateEvent;
 		public event ThreadEventHandler LeaveNestedBreakStateEvent;
 
@@ -139,6 +148,12 @@ namespace Mono.Debugger
 				TargetEvent (thread, args);
 		}
 
+		internal void OnProcessEvent (Thread thread, TargetEventArgs args)
+		{
+			if (ProcessEvent != null)
+				ProcessEvent (thread, args);
+		}
+
 		internal void OnModuleLoadedEvent (Module module)
 		{
 			if (ModuleLoadedEvent != null)
diff --git a/classes/GUIManager.cs b/classes/GUIManager.cs
dissimilarity index 83%
index ae46c6c..b5c92f0 100644
--- a/classes/GUIManager.cs
+++ b/classes/GUIManager.cs
@@ -1,399 +1,90 @@
-using System;
-using System.Linq;
-using System.IO;
-using System.Collections;
-using System.Collections.Generic;
-using ST = System.Threading;
-
-using Mono.Debugger.Backend;
-using Mono.Debugger.Languages;
-using Mono.Debugger.Languages.Mono;
-
-namespace Mono.Debugger
-{
-	using EE = ExpressionEvaluator;
-
-	public class GUIManager : DebuggerMarshalByRefObject
-	{
-		public Process Process {
-			get; private set;
-		}
-
-		internal GUIManager (Process process)
-		{
-			this.Process = process;
-		}
-
-		ST.Thread manager_thread;
-		ST.AutoResetEvent manager_event;
-		ST.ManualResetEvent result_event;
-		bool want_result;
-		Queue<Event> event_queue;
-
-		bool break_mode;
-		bool suppress_events;
-		long current_evaluation;
-
-		public event TargetEventHandler TargetEvent;
-		public event ProcessEventHandler ProcessExitedEvent;
-
-		public void StartGUIManager ()
-		{
-			Process.Session.Config.StopOnManagedSignals = false;
-
-			event_queue = new Queue<Event> ();
-			manager_event = new ST.AutoResetEvent (false);
-			result_event = new ST.ManualResetEvent (false);
-			manager_thread = new ST.Thread (new ST.ThreadStart (manager_thread_main));
-			manager_thread.Start ();
-		}
-
-		internal void OnProcessExited (Process process)
-		{
-			try {
-				if (ProcessExitedEvent != null)
-					ProcessExitedEvent (process.Debugger, process);
-			} catch (Exception ex) {
-				Report.Error ("Caught exception while sending process {0} exit:\n{1}",
-					       process, ex);
-			}
-		}
-
-		internal void OnTargetEvent (SingleSteppingEngine sse, TargetEventArgs args)
-		{
-			switch (args.Type){
-			case TargetEventType.TargetHitBreakpoint:
-			case TargetEventType.TargetStopped:
-			case TargetEventType.UnhandledException:
-			case TargetEventType.Exception:
-				if (!suppress_events)
-					handle_autostop_event (sse, args);
-				break;
-
-			case TargetEventType.TargetInterrupted:
-				if (!break_mode && !suppress_events) {
-					args = new TargetEventArgs (TargetEventType.TargetStopped, 0);
-					handle_autostop_event (sse, args);
-				}
-				break;
-
-			case TargetEventType.RuntimeInvokeDone:
-				if (!suppress_events)
-					handle_autostop_event (sse, args);
-				break;
-
-			default:
-				SendTargetEvent (sse.Thread, args);
-				break;
-			}
-		}
-
-		void handle_autostop_event (SingleSteppingEngine sse, TargetEventArgs args)
-		{
-			break_mode = true;
-
-			List<Thread> stopped = new List<Thread> ();
-
-			Thread[] threads = Process.GetThreads ();
-			foreach (Thread thread in threads) {
-				if (thread == sse.Client)
-					continue;
-
-				// Never touch immutable threads.
-				if ((thread.ThreadFlags & Thread.Flags.Immutable) != 0)
-					continue;
-				// Background thread -> keep running.
-				if ((thread.ThreadFlags & Thread.Flags.Background) != 0)
-					continue;
-
-				Report.Debug (DebugFlags.Threads, "Autostopping thread: {0}", thread);
-				thread.Stop ();
-				thread.ThreadFlags |= Thread.Flags.AutoRun;
-				stopped.Add (thread);
-			}
-
-			lock (event_queue) {
-				event_queue.Enqueue (new StoppingEvent {
-					Manager = this, Thread = sse.Client, Args = args,
-					Stopped = stopped
-				});
-				manager_event.Set ();
-			}
-		}
-
-		internal void SendTargetEvent (Thread thread, TargetEventArgs args)
-		{
-			try {
-				if (TargetEvent != null)
-					TargetEvent (thread, args);
-			} catch (Exception ex) {
-				Report.Error ("{0} caught exception while sending {1}:\n{2}",
-					      thread, args, ex);
-			}
-		}
-
-		protected void ProcessStoppingEvent (StoppingEvent e)
-		{
-			List<ST.WaitHandle> wait_list = new List<ST.WaitHandle> ();
-			foreach (Thread thread in e.Stopped)
-				wait_list.Add (thread.WaitHandle);
-
-			ST.WaitHandle.WaitAll (wait_list.ToArray ());
-
-			SendTargetEvent (e.Thread, e.Args);
-		}
-
-		protected object QueueEvent (Event e)
-		{
-			lock (event_queue) {
-				event_queue.Enqueue (e);
-				manager_event.Set ();
-				result_event.Reset ();
-				want_result = true;
-			}
-			result_event.WaitOne ();
-			if (e.Result is Exception)
-				throw (Exception) e.Result;
-			return e.Result;
-		}
-
-		public void Stop (Thread thread)
-		{
-			QueueEvent (new StopEvent { Manager = this, Thread = thread });
-		}
-
-		public void Continue (Thread thread)
-		{
-			QueueEvent (new ContinueEvent { Manager = this, Thread = thread });
-		}
-
-		public void StepInto (Thread thread)
-		{
-			QueueEvent (new StepIntoEvent { Manager = this, Thread = thread });
-		}
-
-		public void StepOver (Thread thread)
-		{
-			QueueEvent (new StepOverEvent { Manager = this, Thread = thread });
-		}
-
-		public void StepOut (Thread thread)
-		{
-			QueueEvent (new StepOutEvent { Manager = this, Thread = thread });
-		}
-
-		public EE.EvaluationResult MonoObjectToString (Thread thread, TargetStructObject obj,
-							       EE.EvaluationFlags flags, int timeout,
-							       out string text)
-		{
-			if (!break_mode)
-				throw new InvalidOperationException ();
-
-			EE.EvaluationResult result;
-
-			try {
-				suppress_events = true;
-				result = EE.MonoObjectToString (thread, obj, flags, timeout, out text);
-			} finally {
-				suppress_events = false;
-			}
-
-			return result;
-		}
-
-		public EE.EvaluationResult GetProperty (Thread thread, TargetPropertyInfo property,
-							TargetStructObject instance, EE.EvaluationFlags flags,
-							int timeout, out string error, out TargetObject value)
-		{
-			if (!break_mode)
-				throw new InvalidOperationException ();
-
-			EE.EvaluationResult result;
-
-			try {
-				suppress_events = true;
-				result = EE.GetProperty (thread, property, instance, flags, timeout,
-							 out error, out value);
-			} finally {
-				suppress_events = false;
-			}
-
-			return result;
-		}
-
-		public EE.AsyncResult EvaluateExpressionAsync (StackFrame frame, EE.IExpression expression,
-							       EE.EvaluationFlags flags, EE.EvaluationCallback cb)
-		{
-			if (!break_mode)
-				throw new InvalidOperationException ();
-
-			return (EE.AsyncResult) QueueEvent (new EvaluateAsyncEvent {
-				Manager = this, Frame = frame, Expression = expression,
-				Flags = flags, Callback = cb
-			});
-		}
-
-		void ProcessRunEvent (RunEvent e)
-		{
-			break_mode = false;
-			Thread[] threads = Process.GetThreads ();
-			foreach (Thread t in threads) {
-				if (t == e.Thread)
-					continue;
-
-				TargetState state = t.ThreadServant.State;
-				if (state != TargetState.Stopped)
-					continue;
-
-				if ((t.ThreadFlags & Thread.Flags.AutoRun) != 0)
-					t.Continue ();
-			}
-		}
-
-		void manager_thread_main ()
-		{
-			while (true) {
-				manager_event.WaitOne ();
-
-				Event e;
-				lock (event_queue) {
-					e = event_queue.Dequeue ();
-				}
-				e.ProcessEvent ();
-				lock (event_queue) {
-					if (want_result)
-						result_event.Set ();
-					want_result = false;
-				}
-			}
-		}
-
-		protected abstract class Event
-		{
-			public GUIManager Manager {
-				get; set;
-			}
-
-			public object Result {
-				get; protected set;
-			}
-
-			public abstract void ProcessEvent ();
-		}
-
-		protected class EvaluateAsyncEvent : Event
-		{
-			public StackFrame Frame {
-				get; set;
-			}
-
-			public EE.IExpression Expression {
-				get; set;
-			}
-
-			public EE.EvaluationFlags Flags {
-				get; set;
-			}
-
-			public EE.EvaluationCallback Callback {
-				get; set;
-			}
-
-			public override void ProcessEvent ()
-			{
-				Manager.break_mode = false;
-				Result = Expression.EvaluateAsync (Frame, Flags, EvaluationDone);
-			}
-
-			void EvaluationDone (EE.EvaluationResult result, object data)
-			{
-				Manager.break_mode = true;
-				Callback (result, data);
-			}
-		}
-
-		protected class StoppingEvent : Event
-		{
-			public Thread Thread {
-				get; set;
-			}
-
-			public TargetEventArgs Args {
-				get; set;
-			}
-
-			public List<Thread> Stopped {
-				get; set;
-			}
-
-			public override void ProcessEvent ()
-			{
-				Manager.ProcessStoppingEvent (this);
-			}
-		}
-
-
-		protected abstract class RunEvent : Event
-		{
-			public Thread Thread {
-				get; set;
-			}
-
-			public override void ProcessEvent ()
-			{
-				Manager.ProcessRunEvent (this);
-				DoRun ();
-			}
-
-			protected abstract void DoRun ();
-		}
-
-		protected class ContinueEvent : RunEvent
-		{
-			protected override void DoRun ()
-			{
-				Thread.ThreadServant.Old_Step (StepMode.Run, null);
-			}
-		}
-
-		protected class StepIntoEvent : RunEvent
-		{
-			protected override void DoRun ()
-			{
-				Thread.ThreadServant.Old_Step (StepMode.SourceLine, null);
-			}
-		}
-
-		protected class StepOverEvent : RunEvent
-		{
-			protected override void DoRun ()
-			{
-				Thread.ThreadServant.Old_Step (StepMode.NextLine, null);
-			}
-		}
-
-		protected class StepOutEvent : RunEvent
-		{
-			protected override void DoRun ()
-			{
-				StepFrame step_frame = new StepFrame (
-					null, StepMode.Finish, null,
-					Thread.CurrentMethod.StartAddress, Thread.CurrentMethod.EndAddress);
-
-				Thread.ThreadServant.Old_Step (StepMode.Finish, step_frame);
-			}
-		}
-
-		protected class StopEvent : Event
-		{
-			public Thread Thread {
-				get; set;
-			}
-
-			public override void ProcessEvent ()
-			{
-				Thread.ThreadServant.Stop ();
-			}
-		}
-	}
-}
+using System;
+using System.Linq;
+using System.IO;
+using System.Collections;
+using System.Collections.Generic;
+using ST = System.Threading;
+
+using Mono.Debugger.Backend;
+using Mono.Debugger.Languages;
+using Mono.Debugger.Languages.Mono;
+
+namespace Mono.Debugger
+{
+	using EE = ExpressionEvaluator;
+
+	[Obsolete]
+	public class GUIManager : DebuggerMarshalByRefObject
+	{
+		public Process Process {
+			get; private set;
+		}
+
+		internal GUIManager (Process process)
+		{
+			this.Process = process;
+		}
+
+		bool suppress_events;
+
+		public event TargetEventHandler TargetEvent;
+		public event ProcessEventHandler ProcessExitedEvent;
+
+		public void StartGUIManager ()
+		{
+			Process.Session.Config.StopOnManagedSignals = false;
+
+			Process.ProcessExitedEvent += delegate {
+				try {
+					if (ProcessExitedEvent != null)
+						ProcessExitedEvent (Process.Debugger, Process);
+				} catch (Exception ex) {
+					Report.Error ("Caught exception while sending process {0} exit:\n{1}",
+						      Process, ex);
+				}
+			};
+
+			Process.TargetEvent += delegate (Thread thread, TargetEventArgs args) {
+				try {
+					if (suppress_events)
+						return;
+					if (TargetEvent != null)
+						TargetEvent (thread, args);
+				} catch (Exception ex) {
+					Report.Error ("{0} caught exception while sending {1}:\n{2}",
+						      thread, args, ex);
+				}
+			};
+		}
+
+		public EE.EvaluationResult MonoObjectToString (Thread thread, TargetStructObject obj,
+							       EE.EvaluationFlags flags, int timeout,
+							       out string text)
+		{
+			try {
+				suppress_events = true;
+				return EE.MonoObjectToString (thread, obj, flags, timeout, out text);
+			} finally {
+				suppress_events = false;
+			}
+		}
+
+		public EE.EvaluationResult GetProperty (Thread thread, TargetPropertyInfo property,
+							TargetStructObject instance, EE.EvaluationFlags flags,
+							int timeout, out string error, out TargetObject value)
+		{
+			try {
+				suppress_events = true;
+				return EE.GetProperty (thread, property, instance, flags, timeout, out error, out value);
+			} finally {
+				suppress_events = false;
+			}
+		}
+
+		public EE.AsyncResult EvaluateExpressionAsync (StackFrame frame, EE.IExpression expression,
+							       EE.EvaluationFlags flags, EE.EvaluationCallback cb)
+		{
+			return expression.EvaluateAsync (frame, flags, cb);
+		}
+	}
+}
diff --git a/classes/Process.cs b/classes/Process.cs
index 2357a84..f145b80 100644
--- a/classes/Process.cs
+++ b/classes/Process.cs
@@ -171,6 +171,9 @@ namespace Mono.Debugger
 		// Stopping / resuming all threads for the GUI
 		//
 
+		public event TargetEventHandler TargetEvent;
+		public event ProcessEventHandler ProcessExitedEvent;
+
 		GUIManager manager;
 
 		public GUIManager StartGUIManager ()
@@ -185,12 +188,14 @@ namespace Mono.Debugger
 
 		internal void OnTargetEvent (SingleSteppingEngine sse, TargetEventArgs args)
 		{
-			if (manager != null)
-				manager.OnTargetEvent (sse, args);
-
 			Debugger.OnTargetEvent (sse.Client, args);
 		}
 
+		internal void OnProcessEvent (SingleSteppingEngine sse, TargetEventArgs args)
+		{
+			Debugger.OnProcessEvent (sse.Client, args);
+		}
+
 		internal void OnEnterNestedBreakState (SingleSteppingEngine sse)
 		{
 			Debugger.OnEnterNestedBreakState (sse.Client);
@@ -203,8 +208,13 @@ namespace Mono.Debugger
 
 		internal void OnProcessExited ()
 		{
-			if (manager != null)
-				manager.OnProcessExited (this);
+			try {
+				if (ProcessExitedEvent != null)
+					ProcessExitedEvent (debugger, this);
+			} catch (Exception ex) {
+				Report.Error ("Caught exception while sending process {0} exit:\n{1}",
+					      this, ex);
+			}
 		}
 
 		ExceptionCatchPointHandler generic_exc_handler;

--------------1.5.6--



From 099422dcc6500e34393d04a2072227ab3ca165ac Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Fri, 10 Jul 2009 21:01:24 +0200
Subject: [PATCH] Process.Stop()
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |   26 +++++++++++++++++++-------
 backend/SingleSteppingEngine.cs |   31 ++-----------------------------
 classes/Process.cs              |    2 +-
 3 files changed, 22 insertions(+), 37 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="099422dcc6500e34393d04a2072227ab3ca165ac.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="099422dcc6500e34393d04a2072227ab3ca165ac.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 1ed5790..b1de62a 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -681,12 +681,17 @@ namespace Mono.Debugger.Backend
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
 
-			Console.WriteLine ("PROCESS COMPLETED: {0} {1} - {2}", current_model, current_state, caller);
+			Console.WriteLine ("PROCESS COMPLETED: {0} {1} - {2} {3}", current_model, current_state, caller, result);
+
+			if ((result != null) &&
+			    (result.Type == TargetEventType.TargetExited))
+				return;
 
 			if (current_state == ProcessState.Running) {
 				current_state = ProcessState.Stopping;
 				Console.WriteLine ("SUSPEND THREADS: {0}", caller);
 				SuspendUserThreads (ThreadingModel.Process, caller);
+				caller.Thread.ThreadFlags |= Thread.Flags.AutoRun;
 				Console.WriteLine ("SUSPEND THREADS DONE: {0} {1}", caller, current_operation);
 				current_state = ProcessState.Stopped;
 				current_operation.Completed ();
@@ -713,8 +718,6 @@ namespace Mono.Debugger.Backend
 				}
 			}
 
-			caller.Thread.ThreadFlags |= Thread.Flags.AutoRun;
-
 			Report.Debug (DebugFlags.Threads,
 				      "Done suspending user threads: {0} {1}", model, caller);
 		}
@@ -759,6 +762,17 @@ namespace Mono.Debugger.Backend
 			return current_operation;
 		}
 
+		internal void Stop ()
+		{
+			Console.WriteLine ("STOP PROCESS !");
+
+			main_thread.Invoke (delegate {
+				Console.WriteLine ("STOP PROCESS #!");
+				SuspendUserThreads (ThreadingModel.Process, null);
+				return null;
+			}, null);
+		}
+
 		internal class ProcessOperationResult : CommandResult
 		{
 			public readonly ProcessServant Process;
@@ -773,13 +787,11 @@ namespace Mono.Debugger.Backend
 			}
 
 			internal override void Completed ()
-			{
-				Console.WriteLine ("PROCESS RESULT SET COMPLETED");
-			}
+			{ }
 
 			public override void Abort ()
 			{
-				throw new NotImplementedException ("FUCK");
+				Process.Stop ();
 			}
 		}
 
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index b0ed5dc..5050e01 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1808,10 +1808,9 @@ namespace Mono.Debugger.Backend
 				Console.WriteLine ("STEP: {0} {1} {2} {3}", this, model, mode, frame);
 
 				CommandResult result;
-				if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Process) {
+				if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Process)
 					result = process.StartOperation (model, this);
-					result = new OperationCommandResult (this);
-				} else
+				else
 					result = new ThreadCommandResult (thread);
 
 				return ProcessOperation (new OperationStep (this, mode, frame, result));
@@ -2533,32 +2532,6 @@ namespace Mono.Debugger.Backend
 #endregion
 
 #region SSE Operations
-	protected class OperationCommandResult : CommandResult
-	{
-		public SingleSteppingEngine SSE;
-
-		protected ManualResetEvent completed_event = new ManualResetEvent (false);
-
-		internal OperationCommandResult (SingleSteppingEngine sse)
-		{
-			this.SSE = sse;
-		}
-
-		public override WaitHandle CompletedEvent {
-			get { return completed_event; }
-		}
-
-		internal override void Completed ()
-		{
-			completed_event.Set ();
-		}
-
-		public override void Abort ()
-		{
-			throw new NotImplementedException ("FUCK");
-		}
-	}
-
 	protected abstract class Operation {
 		public enum EventResult
 		{
diff --git a/classes/Process.cs b/classes/Process.cs
index f145b80..0d2d756 100644
--- a/classes/Process.cs
+++ b/classes/Process.cs
@@ -138,7 +138,7 @@ namespace Mono.Debugger
 			result.Wait ();
 		}
 
-		public class ProcessCommandResult : CommandResult
+		protected class ProcessCommandResult : CommandResult
 		{
 			Process process;
 			ST.ManualResetEvent completed_event = new ST.ManualResetEvent (false);

--------------1.5.6--



From fa04b9ad8cd6abee4cf243d8620ba16ae2762ab8 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Fri, 10 Jul 2009 21:08:14 +0200
Subject: [PATCH] Properly handle process exit.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs |   18 ++++++++++++++----
 1 files changed, 14 insertions(+), 4 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="fa04b9ad8cd6abee4cf243d8620ba16ae2762ab8.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="fa04b9ad8cd6abee4cf243d8620ba16ae2762ab8.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index b1de62a..c8fa248 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -323,6 +323,15 @@ namespace Mono.Debugger.Backend
 		{
 			DropGlobalThreadLock ();
 
+			Console.WriteLine ("ON PROCESS EXITED!");
+
+			if (current_state == ProcessState.Running) {
+				current_state = ProcessState.Exited;
+				current_operation.Completed ();
+				current_operation = null;
+				stopped_event.Set ();
+			}
+
 			if (!is_forked)
 				session.OnProcessExited (client);
 			client.OnProcessExited ();
@@ -667,7 +676,8 @@ namespace Mono.Debugger.Backend
 			SingleThreaded,
 			Running,
 			Stopping,
-			Stopped
+			Stopped,
+			Exited
 		}
 
 		protected ST.ManualResetEvent stopped_event;
@@ -681,10 +691,10 @@ namespace Mono.Debugger.Backend
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
 
-			Console.WriteLine ("PROCESS COMPLETED: {0} {1} - {2} {3}", current_model, current_state, caller, result);
+			Console.WriteLine ("PROCESS COMPLETED: {0} {1} - {2} {3} {4}", current_model, current_state, caller, caller.State, result);
 
 			if ((result != null) &&
-			    (result.Type == TargetEventType.TargetExited))
+			    ((result.Type == TargetEventType.TargetExited) || (result.Type == TargetEventType.TargetSignaled)))
 				return;
 
 			if (current_state == ProcessState.Running) {
@@ -695,9 +705,9 @@ namespace Mono.Debugger.Backend
 				Console.WriteLine ("SUSPEND THREADS DONE: {0} {1}", caller, current_operation);
 				current_state = ProcessState.Stopped;
 				current_operation.Completed ();
+				current_operation = null;
 				stopped_event.Set ();
 				OnProcessEvent (caller, result);
-				current_operation = null;
 			}
 		}
 

--------------1.5.6--



From 1a086fe43c41407b03390546f1ffac75a97de732 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Fri, 10 Jul 2009 22:24:17 +0200
Subject: [PATCH] Some more work.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |   29 ++++++++++++++++++++++-------
 backend/SingleSteppingEngine.cs |    7 +------
 2 files changed, 23 insertions(+), 13 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="1a086fe43c41407b03390546f1ffac75a97de732.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="1a086fe43c41407b03390546f1ffac75a97de732.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index c8fa248..f354722 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -313,7 +313,6 @@ namespace Mono.Debugger.Backend
 			manager.Debugger.OnMainProcessCreatedEvent (this);
 
 			current_state = ProcessState.Running;
-			current_model = ThreadingModel.Process;
 
 			current_operation = new ProcessOperationResult (this);
 			engine.StartApplication (current_operation);
@@ -683,7 +682,6 @@ namespace Mono.Debugger.Backend
 		protected ST.ManualResetEvent stopped_event;
 
 		ProcessState current_state = ProcessState.Unknown;
-		ThreadingModel current_model = ThreadingModel.Default;
 		CommandResult current_operation = null;
 
 		internal void OperationCompleted (SingleSteppingEngine caller, TargetEventArgs result)
@@ -691,7 +689,7 @@ namespace Mono.Debugger.Backend
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
 
-			Console.WriteLine ("PROCESS COMPLETED: {0} {1} - {2} {3} {4}", current_model, current_state, caller, caller.State, result);
+			Console.WriteLine ("PROCESS COMPLETED: {0} - {1} {2} {3}", current_state, caller, caller.State, result);
 
 			if ((result != null) &&
 			    ((result.Type == TargetEventType.TargetExited) || (result.Type == TargetEventType.TargetSignaled)))
@@ -708,6 +706,9 @@ namespace Mono.Debugger.Backend
 				current_operation = null;
 				stopped_event.Set ();
 				OnProcessEvent (caller, result);
+			} else if (current_state == ProcessState.SingleThreaded) {
+				if (result != null)
+					OnTargetEvent (caller, result);
 			}
 		}
 
@@ -757,12 +758,17 @@ namespace Mono.Debugger.Backend
 		{
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
-			if ((model & ThreadingModel.ThreadingMode) != ThreadingModel.Process)
-				throw new ArgumentException ();
-			if (current_state != ProcessState.Stopped)
+
+			if ((current_state != ProcessState.Stopped) && (current_state != ProcessState.SingleThreaded))
 				throw new TargetException (TargetError.NotStopped);
 
-			current_model = ThreadingModel.Process;
+			if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Single) {
+				current_state = ProcessState.SingleThreaded;
+				return new ThreadCommandResult (caller.Thread);
+			} else if ((model & ThreadingModel.ThreadingMode) != ThreadingModel.Process) {
+				throw new ArgumentException ();
+			}
+
 			current_state = ProcessState.Running;
 
 			stopped_event.Reset ();
@@ -777,8 +783,17 @@ namespace Mono.Debugger.Backend
 			Console.WriteLine ("STOP PROCESS !");
 
 			main_thread.Invoke (delegate {
+				current_state = ProcessState.Stopping;
+
 				Console.WriteLine ("STOP PROCESS #!");
 				SuspendUserThreads (ThreadingModel.Process, null);
+				current_state = ProcessState.Stopped;
+				if (current_operation != null) {
+					current_operation.Completed ();
+					current_operation = null;
+				}
+				stopped_event.Set ();
+				Console.WriteLine ("STOP PROCESS #2");
 				return null;
 			}, null);
 		}
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 5050e01..93317be 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1807,12 +1807,7 @@ namespace Mono.Debugger.Backend
 			return (CommandResult) SendCommand (delegate {
 				Console.WriteLine ("STEP: {0} {1} {2} {3}", this, model, mode, frame);
 
-				CommandResult result;
-				if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Process)
-					result = process.StartOperation (model, this);
-				else
-					result = new ThreadCommandResult (thread);
-
+				CommandResult result = process.StartOperation (model, this);
 				return ProcessOperation (new OperationStep (this, mode, frame, result));
 			});
 		}

--------------1.5.6--



From c3bb49d58f7b0062cee0f134df9b60b866743bdf Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Sat, 11 Jul 2009 03:54:17 +0200
Subject: [PATCH] Configuration ....
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs         |    1 -
 classes/DebuggerConfiguration.cs  |  111 +++++++++++++++++++++++++++++-------
 classes/DebuggerConfiguration.xsd |    9 +++
 classes/Thread.cs                 |    3 +
 frontend/Command.cs               |   55 ++++++++++++++----
 frontend/Main.cs                  |   34 ++++++-----
 6 files changed, 161 insertions(+), 52 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="c3bb49d58f7b0062cee0f134df9b60b866743bdf.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="c3bb49d58f7b0062cee0f134df9b60b866743bdf.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index f354722..cd3e37f 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -313,7 +313,6 @@ namespace Mono.Debugger.Backend
 			manager.Debugger.OnMainProcessCreatedEvent (this);
 
 			current_state = ProcessState.Running;
-
 			current_operation = new ProcessOperationResult (this);
 			engine.StartApplication (current_operation);
 		}
diff --git a/classes/DebuggerConfiguration.cs b/classes/DebuggerConfiguration.cs
index c1a9516..107dbe3 100644
--- a/classes/DebuggerConfiguration.cs
+++ b/classes/DebuggerConfiguration.cs
@@ -44,13 +44,16 @@ namespace Mono.Debugger
 
 		public bool LoadConfiguration()
 		{
-			try {
-				if (!Directory.Exists (ConfigDirectory))
-					Directory.CreateDirectory (ConfigDirectory);
+			string config_file = Path.Combine (ConfigDirectory, ConfigFileName);
+			if (!File.Exists (config_file))
+				return false;
 
-				LoadConfigurationFromStream (Path.Combine (ConfigDirectory, ConfigFileName));
+			try {
+				LoadConfigurationFromStream (config_file);
 				return true;
-			} catch {
+			} catch (Exception ex) {
+				Console.WriteLine ("FUCK: {0}", ex);
+				Report.Error ("Failed to load configuration file {0}: {1}", config_file, ex.Message);
 				return false;
 			}
 		}
@@ -71,7 +74,6 @@ namespace Mono.Debugger
 		public void SetupXSP ()
 		{
 			stay_in_thread = false;
-			broken_threading = true;
 			load_native_symtabs = false;
 			follow_fork = false;
 			notify_thread_creation = false;
@@ -103,8 +105,6 @@ namespace Mono.Debugger
 			while (iter.MoveNext ()) {
 				if (iter.Current.Name == "LoadNativeSymtabs")
 					LoadNativeSymtabs = Boolean.Parse (iter.Current.Value);
-				else if (iter.Current.Name == "BrokenThreading")
-					BrokenThreading = Boolean.Parse (iter.Current.Value);
 				else if (iter.Current.Name == "StayInThread")
 					StayInThread = Boolean.Parse (iter.Current.Value);
 				else if (iter.Current.Name == "FollowFork")
@@ -117,10 +117,38 @@ namespace Mono.Debugger
 					NestedBreakStates = Boolean.Parse (iter.Current.Value);
 				else if (iter.Current.Name == "RedirectOutput")
 					RedirectOutput = Boolean.Parse (iter.Current.Value);
-				else if (iter.Current.Name == "Martin_Boston_07102008")
-					; // ignore, this is no longer uses.
+				else if (iter.Current.Name == "Martin_Boston_07102008") {
+					; // ignore, this is no longer in use.
+				} else if (iter.Current.Name == "BrokenThreading") {
+					; // ignore, this is no longer in use.
+				} else if (iter.Current.Name == "StopDaemonThreads") {
+					if (Boolean.Parse (iter.Current.Value))
+						threading_model |= ThreadingModel.StopDaemonThreads;
+					else
+						threading_model &= ~ThreadingModel.StopDaemonThreads;
+				} else if (iter.Current.Name == "StopImmutableThreads") {
+					if (Boolean.Parse (iter.Current.Value))
+						threading_model |= ThreadingModel.StopImmutableThreads;
 				else
-					throw new InvalidOperationException ();
+						threading_model &= ~ThreadingModel.StopImmutableThreads;
+				} else if (iter.Current.Name == "ThreadingModel") {
+					switch (iter.Current.Value.ToLower ()) {
+					case "single":
+						threading_model |= ThreadingModel.Single;
+						break;
+					case "process":
+						threading_model |= ThreadingModel.Process;
+						break;
+					case "default":
+						break;
+					default:
+						throw new ArgumentException (String.Format (
+							"Invalid value `{0}' in 'ThreadingModel'", iter.Current.Value));
+					}
+				} else {
+					throw new ArgumentException (String.Format (
+						"Invalid configuration item `{0}'", iter.Current.Name));
+				}
 			}
 
 			iter = nav.Select ("/DebuggerConfiguration/ModuleGroups/ModuleGroup");
@@ -151,10 +179,6 @@ namespace Mono.Debugger
 				load_native_symtabs_e.InnerText = LoadNativeSymtabs ? "true" : "false";
 				element.AppendChild (load_native_symtabs_e);
 
-				XmlElement broken_threading_e = doc.CreateElement ("BrokenThreading");
-				broken_threading_e.InnerText = BrokenThreading ? "true" : "false";
-				element.AppendChild (broken_threading_e);
-
 				XmlElement stay_in_thread_e = doc.CreateElement ("StayInThread");
 				stay_in_thread_e.InnerText = StayInThread ? "true" : "false";
 				element.AppendChild (stay_in_thread_e);
@@ -179,6 +203,28 @@ namespace Mono.Debugger
 				redirect_output_e.InnerText = RedirectOutput ? "true" : "false";
 				element.AppendChild (redirect_output_e);
 
+				XmlElement stop_daemon_threads_e = doc.CreateElement ("StopDaemonThreads");
+				stop_daemon_threads_e.InnerText = (ThreadingModel & ThreadingModel.StopDaemonThreads) != 0 ? "true" : "false";
+				element.AppendChild (stop_daemon_threads_e);
+
+				XmlElement stop_immutable_threads_e = doc.CreateElement ("StopImmutableThreads");
+				stop_immutable_threads_e.InnerText = (ThreadingModel & ThreadingModel.StopImmutableThreads) != 0 ? "true" : "false";
+				element.AppendChild (stop_immutable_threads_e);
+
+				XmlElement threading_model_e = doc.CreateElement ("ThreadingModel");
+				switch (threading_model & ThreadingModel.ThreadingMode) {
+				case ThreadingModel.Single:
+					threading_model_e.InnerText = "single";
+					break;
+				case ThreadingModel.Process:
+					threading_model_e.InnerText = "process";
+					break;
+				default:
+					threading_model_e.InnerText = "default";
+					break;
+				}
+				element.AppendChild (threading_model_e);
+
 				XmlElement module_groups = doc.CreateElement ("ModuleGroups");
 				doc.DocumentElement.AppendChild (module_groups);
 
@@ -189,8 +235,7 @@ namespace Mono.Debugger
 			}
 		}
 
-		bool stay_in_thread = false;
-		bool broken_threading = true;
+		bool stay_in_thread = true;
 		bool load_native_symtabs = false;
 		bool follow_fork = false;
 		bool notify_thread_creation = true;
@@ -200,6 +245,7 @@ namespace Mono.Debugger
 		bool nested_break_states = false;
 		bool redirect_output = false;
 		bool is_xsp = false;
+		ThreadingModel threading_model = ThreadingModel.Default;
 		Hashtable module_groups;
 		Dictionary<string,string> directory_maps;
 
@@ -294,9 +340,15 @@ namespace Mono.Debugger
 			set { stay_in_thread = value; }
 		}
 
+		[Obsolete]
 		public bool BrokenThreading {
-			get { return broken_threading; }
-			set { broken_threading = value; }
+			get { return false; }
+			set { ; }
+		}
+
+		public ThreadingModel ThreadingModel {
+			get { return threading_model; }
+			set { threading_model = value; }
 		}
 
 		public bool FollowFork {
@@ -367,10 +419,25 @@ namespace Mono.Debugger
 
 			if (expert_mode) {
 				sb.Append ("\nExpert Settings:\n");
-				sb.Append (String.Format ("  Broken threading (broken-threading):   {0}\n",
-							  BrokenThreading ? "enabled" : "disabled"));
 				sb.Append (String.Format ("  Stay in thread (stay-in-thread):       {0}\n",
-							  BrokenThreading ? "yes" : "no"));
+							  StayInThread ? "yes" : "no"));
+				string threading_mode;
+				switch (ThreadingModel & ThreadingModel.ThreadingMode) {
+				case ThreadingModel.Single:
+					threading_mode = "single";
+					break;
+				case ThreadingModel.Process:
+					threading_mode = "process";
+					break;
+				default:
+					threading_mode = "default";
+					break;
+				}
+				sb.Append (String.Format ("  Threading Model (threading-model):     {0}\n", threading_mode));
+				sb.Append (String.Format ("  Stop Daemon Threads (stop-daemon):     {0}\n",
+							  (ThreadingModel & ThreadingModel.StopDaemonThreads) != 0 ? "yes" : "no"));
+				sb.Append (String.Format ("  Stop Daemon Threads (stop-immutable):  {0}\n",
+							  (ThreadingModel & ThreadingModel.StopImmutableThreads) != 0 ? "yes" : "no"));
 			}
 			return sb.ToString ();
 		}
diff --git a/classes/DebuggerConfiguration.xsd b/classes/DebuggerConfiguration.xsd
index cce0d83..5889f4d 100644
--- a/classes/DebuggerConfiguration.xsd
+++ b/classes/DebuggerConfiguration.xsd
@@ -11,8 +11,17 @@
       <xs:element name="NestedBreakStates" type="xs:boolean" minOccurs="0" maxOccurs="1" />
       <xs:element name="RedirectOutput" type="xs:boolean" minOccurs="0" maxOccurs="1" />
       <xs:element name="Martin_Boston_07102008" type="xs:boolean" minOccurs="0" maxOccurs="1" />
+      <xs:element name="StopDaemonThreads" type="xs:boolean" minOccurs="0" maxOccurs="1" />
+      <xs:element name="StopImmutableThreads" type="xs:boolean" minOccurs="0" maxOccurs="1" />
+      <xs:element name="ThreadingModel" type="ThreadingModel" minOccurs="0" maxOccurs="1" />
     </xs:choice>
   </xs:complexType>
+  <xs:simpleType name="ThreadingModel">
+    <xs:restriction base="xs:string">
+      <xs:enumeration value="single"/>
+      <xs:enumeration value="process"/>
+    </xs:restriction>
+  </xs:simpleType>
   <xs:complexType name="Options">
     <xs:choice maxOccurs="unbounded">
       <xs:element name="File" type="xs:string" minOccurs="1" />
diff --git a/classes/Thread.cs b/classes/Thread.cs
index ec5107f..97aaf2a 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -29,6 +29,9 @@ namespace Mono.Debugger
 		SuspendAll		= 0x0100,
 		ResumeThreads		= 0x0200,
 
+		StopDaemonThreads	= 0x0400,
+		StopImmutableThreads	= 0x0800,
+
 		ThreadingMode		= 0x00FF,
 		ThreadingFlags		= 0xFF00
 	}
diff --git a/frontend/Command.cs b/frontend/Command.cs
index a6ec805..fee346b 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -3702,6 +3702,12 @@ namespace Mono.Debugger.Frontend
 			set { expert_mode = value; }
 		}
 
+		void require_expert_mode ()
+		{
+			if (!expert_mode)
+				throw new ScriptingException ("This option is only available in expert mode.");
+		}
+
 		protected override bool DoResolve (ScriptingContext context)
 		{
 			DebuggerConfiguration config = context.Interpreter.DebuggerConfiguration;
@@ -3712,6 +3718,25 @@ namespace Mono.Debugger.Frontend
 			}
 
 			foreach (string arg in Args) {
+				if (arg.StartsWith ("threading-model=")) {
+					require_expert_mode ();
+					string arg1 = arg.Substring (16);
+					config.ThreadingModel &= ~ThreadingModel.ThreadingMode;
+					switch (arg1) {
+					case "single":
+						config.ThreadingModel |= ThreadingModel.Single;
+						break;
+					case "process":
+						config.ThreadingModel |= ThreadingModel.Process;
+						break;
+					case "default":
+						break;
+					default:
+						throw new ScriptingException ("Invalid 'threading-model' option '{0}'.", arg1);
+					}
+					continue;
+				}
+
 				if ((arg [0] != '+') && (arg [0] != '-'))
 					throw new ScriptingException ("Expected `+option' or `-option'.");
 
@@ -3735,25 +3760,29 @@ namespace Mono.Debugger.Frontend
 					config.NestedBreakStates = enable;
 					break;
 
-				case "broken-threading":
-					if (!expert_mode)
-						throw new ScriptingException (
-							"This option is only available in expert mode.");
-
-					config.BrokenThreading = enable;
+				case "stay-in-thread":
+					require_expert_mode ();
+					config.StayInThread = enable;
 					break;
 
-				case "stay-in-thread":
-					if (!expert_mode)
-						throw new ScriptingException (
-							"This option is only available in expert mode.");
+				case "stop-daemon-threads":
+					require_expert_mode ();
+					if (enable)
+						config.ThreadingModel |= ThreadingModel.StopDaemonThreads;
+					else
+						config.ThreadingModel &= ~ThreadingModel.StopDaemonThreads;
+					break;
 
-					config.StayInThread = enable;
+				case "stop-immutable-threads":
+					require_expert_mode ();
+					if (enable)
+						config.ThreadingModel |= ThreadingModel.StopImmutableThreads;
+					else
+						config.ThreadingModel &= ~ThreadingModel.StopImmutableThreads;
 					break;
 
 				default:
-					throw new ScriptingException (
-						"No such configuration option `{0}'.", option);
+					throw new ScriptingException ("No such configuration option `{0}'.", option);
 				}
 			}
 
diff --git a/frontend/Main.cs b/frontend/Main.cs
index 7f17119..4b2b033 100644
--- a/frontend/Main.cs
+++ b/frontend/Main.cs
@@ -21,6 +21,10 @@ namespace Mono.Debugger.Frontend
 			}
 		}
 
+		public DebuggerConfiguration Configuration {
+			get; private set;
+		}
+
 		public Interpreter Interpreter {
 			get { return interpreter; }
 		}
@@ -58,15 +62,24 @@ namespace Mono.Debugger.Frontend
 			mono_debugger_server_static_init ();
 		}
 
-		internal CommandLineInterpreter (bool is_interactive, DebuggerConfiguration config,
-						 DebuggerOptions options)
+		internal CommandLineInterpreter (DebuggerOptions options, bool is_interactive)
 		{
 			if (options.HasDebugFlags)
 				Report.Initialize (options.DebugOutput, options.DebugFlags);
 			else
 				Report.Initialize ();
 
-			interpreter = new Interpreter (is_interactive, config, options);
+			Configuration = new DebuggerConfiguration ();
+#if HAVE_XSP
+			if (options.StartXSP)
+				Configuration.SetupXSP ();
+			else
+				Configuration.LoadConfiguration ();
+#else
+			Configuration.LoadConfiguration ();
+#endif
+
+			interpreter = new Interpreter (is_interactive, Configuration, options);
 			interpreter.CLI = this;
 
 			engine = interpreter.DebuggerEngine;
@@ -336,24 +349,13 @@ namespace Mono.Debugger.Frontend
 
 			DebuggerOptions options = DebuggerOptions.ParseCommandLine (args);
 
-			DebuggerConfiguration config = new DebuggerConfiguration ();
-#if HAVE_XSP
-			if (options.StartXSP)
-				config.SetupXSP ();
-			else
-				config.LoadConfiguration ();
-#else
-			config.LoadConfiguration ();
-#endif
-
 			Console.WriteLine ("Mono Debugger");
 
-			CommandLineInterpreter interpreter = new CommandLineInterpreter (
-				is_terminal, config, options);
+			CommandLineInterpreter interpreter = new CommandLineInterpreter (options, is_terminal);
 
 			interpreter.RunMainLoop ();
 
-			config.SaveConfiguration ();
+			interpreter.Configuration.SaveConfiguration ();
 		}
 
 		public class MainLoop

--------------1.5.6--



From 788255f8359f2d57e7f6e0d474f3ffa98f4f335c Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Sat, 11 Jul 2009 04:12:17 +0200
Subject: [PATCH] Return a 'CommandResult' when starting the target; killed WaitAll() and WaitOne(), just Wait() the 'CommandResult'.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/DebuggerServant.cs      |    8 ++--
 backend/ProcessServant.cs       |   12 ++++-
 backend/SingleSteppingEngine.cs |    8 +---
 backend/ThreadManager.cs        |   13 +++--
 classes/Debugger.cs             |   16 ++++++-
 frontend/Interpreter.cs         |   93 +++++----------------------------------
 6 files changed, 50 insertions(+), 100 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="788255f8359f2d57e7f6e0d474f3ffa98f4f335c.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="788255f8359f2d57e7f6e0d474f3ffa98f4f335c.diff"

diff --git a/backend/DebuggerServant.cs b/backend/DebuggerServant.cs
index 4012fb9..38f99df 100644
--- a/backend/DebuggerServant.cs
+++ b/backend/DebuggerServant.cs
@@ -140,7 +140,7 @@ namespace Mono.Debugger.Backend
 			}
 		}
 
-		public Process Run (DebuggerSession session)
+		public Process Run (DebuggerSession session, out CommandResult result)
 		{
 			check_disposed ();
 
@@ -148,12 +148,12 @@ namespace Mono.Debugger.Backend
 				throw new TargetException (TargetError.AlreadyHaveTarget);
 
 			ProcessStart start = new ProcessStart (session);
-			main_process = thread_manager.StartApplication (start);
+			main_process = thread_manager.StartApplication (start, out result);
 			process_hash.Add (main_process, main_process);
 			return main_process.Client;
 		}
 
-		public Process Attach (DebuggerSession session, int pid)
+		public Process Attach (DebuggerSession session, int pid, out CommandResult result)
 		{
 			check_disposed ();
 
@@ -161,7 +161,7 @@ namespace Mono.Debugger.Backend
 				throw new TargetException (TargetError.AlreadyHaveTarget);
 
 			ProcessStart start = new ProcessStart (session, pid);
-			main_process = thread_manager.StartApplication (start);
+			main_process = thread_manager.StartApplication (start, out result);
 			process_hash.Add (main_process, main_process);
 			return main_process.Client;
 		}
diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index cd3e37f..20ee498 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -295,7 +295,7 @@ namespace Mono.Debugger.Backend
 			new_thread.StartExecedChild ();
 		}
 
-		internal void StartApplication ()
+		internal CommandResult StartApplication ()
 		{
 			SingleSteppingEngine engine = new SingleSteppingEngine (manager, this, start);
 
@@ -312,9 +312,17 @@ namespace Mono.Debugger.Backend
 			session.OnMainProcessCreated (client);
 			manager.Debugger.OnMainProcessCreatedEvent (this);
 
+			switch (start.Session.Config.ThreadingModel & ThreadingModel.ThreadingMode) {
+			case ThreadingModel.Single:
+				current_state = ProcessState.SingleThreaded;
+				return engine.StartApplication (new ThreadCommandResult (engine.Thread));
+			case ThreadingModel.Process:
 			current_state = ProcessState.Running;
 			current_operation = new ProcessOperationResult (this);
-			engine.StartApplication (current_operation);
+				return engine.StartApplication (current_operation);
+			default:
+				goto case ThreadingModel.Single;
+			}
 		}
 
 		internal void OnProcessExitedEvent ()
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 93317be..ad721fd 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -575,22 +575,20 @@ namespace Mono.Debugger.Backend
 				stop_requested = false;
 				last_target_event = result;
 
+				process.OperationCompleted (this, result);
+
 				operation_completed_event.Set ();
 
 				Report.Debug (DebugFlags.EventLoop, "{0} {1} operation {2}: {3}",
 					      this, suspended ? "suspending" : "terminating", current_operation, result);
 
 				if (suspended) {
-					if (result != null)
-						process.OnTargetEvent (this, result);
 					process.OnEnterNestedBreakState (this);
 					((InterruptibleOperation) current_operation).IsSuspended = true;
 					nested_break_stack.Push ((InterruptibleOperation) current_operation);
 					current_operation.CompletedOperation (true);
 					current_operation = null;
 				} else {
-					if (result != null)
-						process.OnTargetEvent (this, result);
 					if (current_operation != null) {
 						Report.Debug (DebugFlags.EventLoop, "{0} setting completed: {1} {2}",
 							      this, current_operation, current_operation.Result);
@@ -598,8 +596,6 @@ namespace Mono.Debugger.Backend
 						current_operation = null;
 					}
 				}
-
-				process.OperationCompleted (this, result);
 			}
 		}
 
diff --git a/backend/ThreadManager.cs b/backend/ThreadManager.cs
index 7c096c5..123ab32 100644
--- a/backend/ThreadManager.cs
+++ b/backend/ThreadManager.cs
@@ -245,7 +245,7 @@ namespace Mono.Debugger.Backend
 				return command.Result;
 		}
 
-		public ProcessServant StartApplication (ProcessStart start)
+		public ProcessServant StartApplication (ProcessStart start, out CommandResult result)
 		{
 			Command command = new Command (CommandType.CreateProcess, start);
 
@@ -264,8 +264,11 @@ namespace Mono.Debugger.Backend
 
 			if (command.Result is Exception)
 				throw (Exception) command.Result;
-			else
-				return (ProcessServant) command.Result;
+			else {
+				var pair = (KeyValuePair<CommandResult,ProcessServant>) command.Result;
+				result = pair.Key;
+				return pair.Value;
+			}
 		}
 
 		internal void AddPendingEvent (SingleSteppingEngine engine, Inferior.ChildEvent cevent)
@@ -361,11 +364,11 @@ namespace Mono.Debugger.Backend
 					ProcessServant process = new ProcessServant (this, start);
 					processes.Add (process);
 
-					process.StartApplication ();
+					CommandResult result = process.StartApplication ();
 
 					RequestWait ();
 
-					command.Result = process;
+					command.Result = new KeyValuePair<CommandResult,ProcessServant> (result, process);
 				} catch (ST.ThreadAbortException) {
 					return;
 				} catch (Exception ex) {
diff --git a/classes/Debugger.cs b/classes/Debugger.cs
index 393b0f8..89a5f9a 100644
--- a/classes/Debugger.cs
+++ b/classes/Debugger.cs
@@ -194,14 +194,26 @@ namespace Mono.Debugger
 
 		public Process Run (DebuggerSession session)
 		{
+			CommandResult dummy;
+			return Run (session, out dummy);
+		}
+
+		public Process Run (DebuggerSession session, out CommandResult result)
+		{
 			check_servant ();
-			return servant.Run (session);
+			return servant.Run (session, out result);
 		}
 
 		public Process Attach (DebuggerSession session, int pid)
 		{
+			CommandResult dummy;
+			return Attach (session, pid, out dummy);
+		}
+
+		public Process Attach (DebuggerSession session, int pid, out CommandResult result)
+		{
 			check_servant ();
-			return servant.Attach (session, pid);
+			return servant.Attach (session, pid, out result);
 		}
 
 		public Process OpenCoreFile (DebuggerSession session, string core_file,
diff --git a/frontend/Interpreter.cs b/frontend/Interpreter.cs
index 59112d0..874afe6 100644
--- a/frontend/Interpreter.cs
+++ b/frontend/Interpreter.cs
@@ -292,10 +292,11 @@ namespace Mono.Debugger.Frontend
 
 				new InterpreterEventSink (this, debugger);
 
-				current_process = main_process = debugger.Run (session);
-
+				CommandResult result;
+				current_process = main_process = debugger.Run (session, out result);
 				current_thread = current_process.MainThread;
-				WaitAll (current_process);
+
+				Wait (result);
 
 				return current_process;
 			} catch (TargetException) {
@@ -318,9 +319,11 @@ namespace Mono.Debugger.Frontend
 
 				new InterpreterEventSink (this, debugger);
 
-				current_process = main_process = debugger.Attach (session, pid);
+				CommandResult result;
+				current_process = main_process = debugger.Attach (session, pid, out result);
 				current_thread = current_process.MainThread;
-				WaitOne (current_thread);
+
+				Wait (result);
 
 				return current_process;
 			} catch (TargetException) {
@@ -372,10 +375,11 @@ namespace Mono.Debugger.Frontend
 
 				new InterpreterEventSink (this, debugger);
 
-				current_process = main_process = debugger.Run (session);
-
+				CommandResult result;
+				current_process = main_process = debugger.Run (session, out result);
 				current_thread = current_process.MainThread;
-				WaitAll (current_process);
+
+				Wait (result);
 
 				return current_process;
 			} catch (TargetException ex) {
@@ -415,79 +419,6 @@ namespace Mono.Debugger.Frontend
 			return true;
 		}
 
-		public bool WaitOne (Thread thread)
-		{
-			ClearInterrupt ();
-
-			WaitHandle[] handles = new WaitHandle [2];
-			handles [0] = interrupt_event;
-			handles [1] = thread.WaitHandle;
-
-			int ret = WaitHandle.WaitAny (handles);
-
-			if (ret == 0) {
-				thread.Stop ();
-				thread.WaitHandle.WaitOne ();
-				return false;
-			}
-
-			CheckLastEvent (thread);
-			return true;
-		}
-
-		public Process WaitAll (Process process)
-		{
-			ClearInterrupt ();
-			process_event.Reset ();
-
-			Thread stopped;
-			Hashtable seen_threads = new Hashtable ();
-
-			do {
-			again:
-				List<WaitHandle> wait_list = new List<WaitHandle> ();
-				wait_list.Add (interrupt_event);
-				wait_list.Add (process_event);
-				wait_list.Add (process.WaitHandle);
-
-#if FIXME
-				Process[] processes = HasTarget ? debugger.Processes : new Process [0];
-				foreach (Process process in processes) {
-					wait_list.Add (process.WaitHandle);
-				}
-#endif
-
-				Console.WriteLine ("WAIT ALL: {0}", process);
-
-				int ret = WaitHandle.WaitAny (wait_list.ToArray ());
-
-				Console.WriteLine ("WAIT ALL DONE: {0}", ret);
-
-				if (ret == 0) {
-					Console.WriteLine ("NEED ABORT !!!");
-					return null;
-				} else if (ret == 1) {
-					seen_threads = new Hashtable ();
-					process_event.Reset ();
-					goto again;
-				} else {
-					return process;
-				}
-			} while (true);
-		}
-
-		protected void Wait (Thread thread)
-		{
-			if (thread == null)
-				return;
-
-			WaitHandle[] handles = new WaitHandle [2];
-			handles [0] = interrupt_event;
-			handles [1] = thread.WaitHandle;
-
-			WaitHandle.WaitAny (handles);
-		}
-
 		public int Interrupt ()
 		{
 			interrupt_event.Set ();

--------------1.5.6--



From 5b2c831540ea48ba0e051aee4924ddf808dab8c7 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Sat, 11 Jul 2009 04:24:42 +0200
Subject: [PATCH] Ooops.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="5b2c831540ea48ba0e051aee4924ddf808dab8c7.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="5b2c831540ea48ba0e051aee4924ddf808dab8c7.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 20ee498..6bb08e5 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -712,6 +712,8 @@ namespace Mono.Debugger.Backend
 				current_operation.Completed ();
 				current_operation = null;
 				stopped_event.Set ();
+				if (result != null)
+					OnTargetEvent (caller, result);
 				OnProcessEvent (caller, result);
 			} else if (current_state == ProcessState.SingleThreaded) {
 				if (result != null)

--------------1.5.6--



From 7186adb31b88cccec161f980cdd5913ae2c9a757 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Sat, 11 Jul 2009 04:27:52 +0200
Subject: [PATCH] Removed the '-wait' option, added '-single' and '-process'.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 frontend/Command.cs          |   43 ++++++++++++++++++++++++++++-------------
 frontend/ScriptingContext.cs |    9 --------
 2 files changed, 29 insertions(+), 23 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="7186adb31b88cccec161f980cdd5913ae2c9a757.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="7186adb31b88cccec161f980cdd5913ae2c9a757.diff"

diff --git a/frontend/Command.cs b/frontend/Command.cs
index fee346b..c3078c1 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -1279,7 +1279,8 @@ namespace Mono.Debugger.Frontend
 	public abstract class SteppingCommand : ThreadCommand
 	{
 		bool in_background;
-		bool wait, has_wait;
+		bool single_thread, entire_process;
+		ThreadingModel threading_model;
 
 		[Property ("in-background", "bg")]
 		public bool InBackground {
@@ -1287,19 +1288,33 @@ namespace Mono.Debugger.Frontend
 			set { in_background = value; }
 		}
 
-		public bool Wait {
-			get { return wait; }
-			set {
-				has_wait = true;
-				wait = value;
+		[Property ("single-thread", "single")]
+		public bool SingleThread {
+			get { return single_thread; }
+			set { single_thread = value; }
 			}
+
+		[Property ("entire-process", "process")]
+		public bool EntireProcess {
+			get { return entire_process; }
+			set { entire_process = value; }
+		}
+
+		protected ThreadingModel ThreadingModel {
+			get { return threading_model; }
 		}
 
 		protected override bool DoResolveBase (ScriptingContext context)
 		{
-			if (!has_wait) {
-				wait = context.Interpreter.DebuggerConfiguration.StayInThread;
-				has_wait = true;
+			threading_model = context.Interpreter.DebuggerConfiguration.ThreadingModel;
+			if (single_thread && entire_process)
+				throw new ScriptingException ("Cannot use both `-single-thread' and `-entire-process'.");
+			if (single_thread) {
+				threading_model &= ~ThreadingModel.ThreadingMode;
+				threading_model |= ThreadingModel.Single;
+			} else if (entire_process) {
+				threading_model &= ~ThreadingModel.ThreadingMode;
+				threading_model |= ThreadingModel.Process;
 			}
 			return base.DoResolveBase (context);
 		}
@@ -1322,7 +1337,7 @@ namespace Mono.Debugger.Frontend
 	{
 		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
 		{
-			return thread.Step (context.ThreadingModel, StepMode.Run, null);
+			return thread.Step (ThreadingModel, StepMode.Run, null);
 		}
 
 		// IDocumentableCommand
@@ -1336,7 +1351,7 @@ namespace Mono.Debugger.Frontend
 		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
 		{
 			context.Interpreter.Style.IsNative = false;
-			return thread.Step (context.ThreadingModel, StepMode.SourceLine, null);
+			return thread.Step (ThreadingModel, StepMode.SourceLine, null);
 		}
 
 		// IDocumentableCommand
@@ -1350,7 +1365,7 @@ namespace Mono.Debugger.Frontend
 		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
 		{
 			context.Interpreter.Style.IsNative = false;
-			return thread.Step (context.ThreadingModel, StepMode.NextLine, null);
+			return thread.Step (ThreadingModel, StepMode.NextLine, null);
 		}
 
 		// IDocumentableCommand
@@ -1371,7 +1386,7 @@ namespace Mono.Debugger.Frontend
 		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
 		{
 			context.Interpreter.Style.IsNative = true;
-			return thread.Step (context.ThreadingModel, Native ? StepMode.NativeInstruction : StepMode.SingleInstruction, null);
+			return thread.Step (ThreadingModel, Native ? StepMode.NativeInstruction : StepMode.SingleInstruction, null);
 		}
 
 		// IDocumentableCommand
@@ -1385,7 +1400,7 @@ namespace Mono.Debugger.Frontend
 		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
 		{
 			context.Interpreter.Style.IsNative = true;
-			return thread.Step (context.ThreadingModel, StepMode.NextInstruction, null);
+			return thread.Step (ThreadingModel, StepMode.NextInstruction, null);
 		}
 
 		// IDocumentableCommand
diff --git a/frontend/ScriptingContext.cs b/frontend/ScriptingContext.cs
index 6290b32..f9f9d9e 100644
--- a/frontend/ScriptingContext.cs
+++ b/frontend/ScriptingContext.cs
@@ -185,15 +185,6 @@ namespace Mono.Debugger.Frontend
 			}
 		}
 
-		public ThreadingModel ThreadingModel {
-			get {
-				if (Interpreter.DebuggerConfiguration.BrokenThreading)
-					return ThreadingModel.Process;
-				else
-					return ThreadingModel.Single;
-			}
-		}
-
 		public string[] GetNamespaces ()
 		{
 			if (HasFrame) {

--------------1.5.6--



From 7756191088cb4be486bbc5125ad797dde704ee0b Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Sat, 11 Jul 2009 04:37:13 +0200
Subject: [PATCH] We don't need a separate process event.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs |    6 ------
 classes/Debugger.cs       |   17 +----------------
 classes/Process.cs        |    7 ++-----
 3 files changed, 3 insertions(+), 27 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="7756191088cb4be486bbc5125ad797dde704ee0b.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="7756191088cb4be486bbc5125ad797dde704ee0b.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 6bb08e5..58c50de 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -714,7 +714,6 @@ namespace Mono.Debugger.Backend
 				stopped_event.Set ();
 				if (result != null)
 					OnTargetEvent (caller, result);
-				OnProcessEvent (caller, result);
 			} else if (current_state == ProcessState.SingleThreaded) {
 				if (result != null)
 					OnTargetEvent (caller, result);
@@ -869,11 +868,6 @@ namespace Mono.Debugger.Backend
 			client.OnTargetEvent (sse, args);
 		}
 
-		internal void OnProcessEvent (SingleSteppingEngine sse, TargetEventArgs args)
-		{
-			client.OnProcessEvent (sse, args);
-		}
-
 		internal void OnEnterNestedBreakState (SingleSteppingEngine sse)
 		{
 			client.OnEnterNestedBreakState (sse);
diff --git a/classes/Debugger.cs b/classes/Debugger.cs
index 89a5f9a..9259f03 100644
--- a/classes/Debugger.cs
+++ b/classes/Debugger.cs
@@ -59,17 +59,8 @@ namespace Mono.Debugger
 		public event ModuleEventHandler ModuleLoadedEvent;
 		public event ModuleEventHandler ModuleUnLoadedEvent;
 		public event DebuggerEventHandler TargetExitedEvent;
-		public event SymbolTableChangedHandler SymbolTableChanged;
-
-		//
-		// TargetEvent is sent when one thread stopped.
-		//
 		public event TargetEventHandler TargetEvent;
-
-		//
-		// ProcessEvent is sent after stopping all threads in a process.
-		//
-		public event TargetEventHandler ProcessEvent;
+		public event SymbolTableChangedHandler SymbolTableChanged;
 
 		public event ThreadEventHandler EnterNestedBreakStateEvent;
 		public event ThreadEventHandler LeaveNestedBreakStateEvent;
@@ -148,12 +139,6 @@ namespace Mono.Debugger
 				TargetEvent (thread, args);
 		}
 
-		internal void OnProcessEvent (Thread thread, TargetEventArgs args)
-		{
-			if (ProcessEvent != null)
-				ProcessEvent (thread, args);
-		}
-
 		internal void OnModuleLoadedEvent (Module module)
 		{
 			if (ModuleLoadedEvent != null)
diff --git a/classes/Process.cs b/classes/Process.cs
index 0d2d756..d289838 100644
--- a/classes/Process.cs
+++ b/classes/Process.cs
@@ -188,14 +188,11 @@ namespace Mono.Debugger
 
 		internal void OnTargetEvent (SingleSteppingEngine sse, TargetEventArgs args)
 		{
+			if (TargetEvent != null)
+				TargetEvent (sse.Client, args);
 			Debugger.OnTargetEvent (sse.Client, args);
 		}
 
-		internal void OnProcessEvent (SingleSteppingEngine sse, TargetEventArgs args)
-		{
-			Debugger.OnProcessEvent (sse.Client, args);
-		}
-
 		internal void OnEnterNestedBreakState (SingleSteppingEngine sse)
 		{
 			Debugger.OnEnterNestedBreakState (sse.Client);

--------------1.5.6--



From f99669718e755f31c2aac35609d23c804df1cb8b Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Mon, 13 Jul 2009 19:30:35 +0200
Subject: [PATCH] Small fix.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs |    5 ++++-
 1 files changed, 4 insertions(+), 1 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="f99669718e755f31c2aac35609d23c804df1cb8b.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="f99669718e755f31c2aac35609d23c804df1cb8b.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 58c50de..22b5c1e 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -698,11 +698,11 @@ namespace Mono.Debugger.Backend
 
 			Console.WriteLine ("PROCESS COMPLETED: {0} - {1} {2} {3}", current_state, caller, caller.State, result);
 
+			if (current_state == ProcessState.Running) {
 			if ((result != null) &&
 			    ((result.Type == TargetEventType.TargetExited) || (result.Type == TargetEventType.TargetSignaled)))
 				return;
 
-			if (current_state == ProcessState.Running) {
 				current_state = ProcessState.Stopping;
 				Console.WriteLine ("SUSPEND THREADS: {0}", caller);
 				SuspendUserThreads (ThreadingModel.Process, caller);
@@ -773,6 +773,9 @@ namespace Mono.Debugger.Backend
 			if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Single) {
 				current_state = ProcessState.SingleThreaded;
 				return new ThreadCommandResult (caller.Thread);
+			} else if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Default) {
+				current_state = ProcessState.SingleThreaded;
+				return new ThreadCommandResult (caller.Thread);
 			} else if ((model & ThreadingModel.ThreadingMode) != ThreadingModel.Process) {
 				throw new ArgumentException ();
 			}

--------------1.5.6--



From a840b57ef40364e155a8c27eea5ce69449ff73a2 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Mon, 13 Jul 2009 19:34:46 +0200
Subject: [PATCH] Add back -wait as compatibility option.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 frontend/Command.cs |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="a840b57ef40364e155a8c27eea5ce69449ff73a2.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="a840b57ef40364e155a8c27eea5ce69449ff73a2.diff"

diff --git a/frontend/Command.cs b/frontend/Command.cs
index c3078c1..b9d4f97 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -1288,6 +1288,13 @@ namespace Mono.Debugger.Frontend
 			set { in_background = value; }
 		}
 
+		[Obsolete]
+		[Property ("wait")]
+		public bool Wait {
+			get { return single_thread; }
+			set { single_thread = value; }
+		}
+
 		[Property ("single-thread", "single")]
 		public bool SingleThread {
 			get { return single_thread; }

--------------1.5.6--



From 6fbdf005d74b223e7f78aea3c95d3ae33d6f7a6b Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Mon, 13 Jul 2009 19:50:38 +0200
Subject: [PATCH] Kill CheckLastTargetEvent().
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 frontend/Command.cs          |    4 ----
 frontend/Interpreter.cs      |   15 ---------------
 frontend/ScriptingContext.cs |    1 -
 3 files changed, 0 insertions(+), 20 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="6fbdf005d74b223e7f78aea3c95d3ae33d6f7a6b.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="6fbdf005d74b223e7f78aea3c95d3ae33d6f7a6b.diff"

diff --git a/frontend/Command.cs b/frontend/Command.cs
index b9d4f97..ad82337 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -3650,10 +3650,6 @@ namespace Mono.Debugger.Frontend
 			Thread thread = CurrentThread;
 			thread.Return (mode);
 
-			TargetEventArgs args = thread.GetLastTargetEvent ();
-			if (args != null)
-				context.Interpreter.Style.TargetEvent (thread, args);
-
 			return null;
 		}
 
diff --git a/frontend/Interpreter.cs b/frontend/Interpreter.cs
index 874afe6..207c7fb 100644
--- a/frontend/Interpreter.cs
+++ b/frontend/Interpreter.cs
@@ -265,19 +265,6 @@ namespace Mono.Debugger.Frontend
 			}
 		}
 
-		internal void CheckLastEvent (Thread thread)
-		{
-			if (thread == null)
-				return;
-
-			TargetEventArgs args = thread.GetLastTargetEvent ();
-			if (args == null)
-				return;
-
-			if ((args.Type == TargetEventType.TargetStopped) && ((int) args.Data == 0))
-				Style.TargetEvent (thread, args);
-		}
-
 		public Process Start ()
 		{
 			if ((debugger != null) || (main_process != null))
@@ -852,8 +839,6 @@ namespace Mono.Debugger.Frontend
 		{
 			if (CLI != null)
 				CLI.EnterNestedBreakState ();
-
-			CheckLastEvent (thread);
 		}
 
 		protected void OnLeaveNestedBreakState (Thread thread)
diff --git a/frontend/ScriptingContext.cs b/frontend/ScriptingContext.cs
index f9f9d9e..330a06a 100644
--- a/frontend/ScriptingContext.cs
+++ b/frontend/ScriptingContext.cs
@@ -286,7 +286,6 @@ namespace Mono.Debugger.Frontend
 				throw new EvaluationTimeoutException ();
 			}
 
-			Interpreter.CheckLastEvent (thread);
 			return result;
 		}
 

--------------1.5.6--



From 34a2b80c424f69866197bdbad748f954526fafe1 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Mon, 13 Jul 2009 23:21:49 +0200
Subject: [PATCH] Fix the completed event mess for OperationRuntimeInvoke and OperationReturn.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |   49 +++++++++++++++++++++++---------------
 test/testsuite/TestAbort.cs     |    9 ++++---
 2 files changed, 35 insertions(+), 23 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="34a2b80c424f69866197bdbad748f954526fafe1.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="34a2b80c424f69866197bdbad748f954526fafe1.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index ad721fd..cf49e5d 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -479,6 +479,8 @@ namespace Mono.Debugger.Backend
 			if (current_operation == null)
 				throw new InternalError ("SSE {0} has no current operation, but received event {1}", this, cevent);
 
+			Report.Debug (DebugFlags.EventLoop, "{0} process operation event: {1} {2}", this, current_operation, cevent);
+
 			Operation.EventResult status = current_operation.ProcessEvent (cevent, out result);
 
 			Report.Debug (DebugFlags.EventLoop, "{0} processed operation event: {1} {2} {3} {4}", this,
@@ -504,7 +506,7 @@ namespace Mono.Debugger.Backend
 			}
 
 			case Operation.EventResult.CompletedCallback:
-				OperationCompleted (null);
+				OperationCompleted (result);
 				return;
 
 			case Operation.EventResult.ResumeOperation:
@@ -546,7 +548,7 @@ namespace Mono.Debugger.Backend
 			}
 		}
 
-		void AbortRuntimeInvoke (long rti_id)
+		void AbortRuntimeInvoke (long rti_id, out TargetEventArgs args)
 		{
 			OperationRuntimeInvoke rti = rti_stack.Pop ();
 			if (rti.ID != rti_id)
@@ -554,6 +556,12 @@ namespace Mono.Debugger.Backend
 
 			inferior.AbortInvoke (rti_id);
 
+			frame_changed (inferior.CurrentFrame, null);
+			if ((rti.Flags & RuntimeInvokeFlags.SendEventOnCompletion) != 0)
+				args = new TargetEventArgs (TargetEventType.RuntimeInvokeDone, rti.Result, current_frame);
+			else
+				args = null;
+
 			if (rti.IsSuspended) {
 				InterruptibleOperation io = nested_break_stack.Pop ();
 				if (io != rti)
@@ -2951,7 +2959,7 @@ namespace Mono.Debugger.Backend
 				func.Token, Index, func.DeclaringType.BaseName, ID);
 		}
 
-		protected override EventResult CallbackCompleted (long data1, long data2)
+		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
 		{
 			TargetAddress info = new TargetAddress (inferior.AddressDomain, data1);
 
@@ -2960,6 +2968,7 @@ namespace Mono.Debugger.Backend
 			sse.Process.MonoLanguage.RegisterMethodLoadHandler (inferior, info, Index, Handle.MethodLoaded);
 
 			Handle.Breakpoint.OnBreakpointBound ();
+			args = null;
 			return EventResult.AskParent;
 		}
 	}
@@ -3034,7 +3043,7 @@ namespace Mono.Debugger.Backend
 			inferior.CallMethod (info.InitCodeBuffer, 0, 0, ID);
 		}
 
-		protected override EventResult CallbackCompleted (long data1, long data2)
+		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
 		{
 			Report.Debug (DebugFlags.SSE,
 				      "{0} init code buffer: {1:x} {2:x} {3}",
@@ -3044,6 +3053,7 @@ namespace Mono.Debugger.Backend
 			sse.process.MonoManager.InitCodeBuffer (inferior, buffer);
 
 			RestoreStack ();
+			args = null;
 			return EventResult.AskParent;
 		}
 	}
@@ -3623,8 +3633,7 @@ namespace Mono.Debugger.Backend
 			}
 
 			try {
-				args = null;
-				return CallbackCompleted (cevent);
+				return CallbackCompleted (cevent.Data1, cevent.Data2, out args);
 			} catch (Exception ex) {
 				Report.Debug (DebugFlags.SSE, "{0} got exception while handling event {1}: {2}",
 					      sse, cevent, ex);
@@ -3633,12 +3642,7 @@ namespace Mono.Debugger.Backend
 			}
 		}
 
-		protected virtual EventResult CallbackCompleted (Inferior.ChildEvent cevent)
-		{
-			return CallbackCompleted (cevent.Data1, cevent.Data2);
-		}
-
-		protected abstract EventResult CallbackCompleted (long data1, long data2);
+		protected abstract EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args);
 
 		public override bool IsSourceOperation {
 			get { return false; }
@@ -4056,7 +4060,7 @@ namespace Mono.Debugger.Backend
 				return false;
 			}
 
-			protected override EventResult CallbackCompleted (long data1, long data2)
+			protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
 			{
 				switch (stage) {
 				case Stage.Uninitialized: {
@@ -4070,6 +4074,7 @@ namespace Mono.Debugger.Backend
 					((IMonoStructType) RTI.Function.DeclaringType).ResolveClass (inferior, false);
 					stage = Stage.ResolvedClass;
 					do_execute ();
+					args = null;
 					return EventResult.Running;
 				}
 
@@ -4084,6 +4089,7 @@ namespace Mono.Debugger.Backend
 					instance = (TargetStructObject) parent_type.GetObject (inferior, new_loc);
 					stage = Stage.HasMethodAddress;
 					do_execute ();
+					args = null;
 					return EventResult.Running;
 				}
 
@@ -4101,6 +4107,7 @@ namespace Mono.Debugger.Backend
 							"Unable to get virtual method `{0}'.", RTI.Function.FullName);
 						RTI.Result.InvocationCompleted = true;
 						RestoreStack ();
+						args = null;
 						return EventResult.CompletedCallback;
 					}
 
@@ -4117,6 +4124,7 @@ namespace Mono.Debugger.Backend
 
 					stage = Stage.HasVirtualMethod;
 					do_execute ();
+					args = null;
 					return EventResult.Running;
 				}
 
@@ -4128,12 +4136,14 @@ namespace Mono.Debugger.Backend
 
 					stage = Stage.CompiledMethod;
 					do_execute ();
+					args = null;
 					return EventResult.Running;
 				}
 
 				case Stage.InvokedMethod: {
 					RTI.Completed (data1, data2);
 					RestoreStack ();
+					args = null;
 					return EventResult.CompletedCallback;
 				}
 
@@ -4294,7 +4304,7 @@ namespace Mono.Debugger.Backend
 			return EventResult.Running;
 		}
 
-		protected override EventResult CallbackCompleted (long data1, long data2)
+		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
 		{
 			if (inferior.TargetAddressSize == 4)
 				data1 &= 0xffffffffL;
@@ -4305,6 +4315,7 @@ namespace Mono.Debugger.Backend
 
 			RestoreStack ();
 			Result.Result = new TargetAddress (inferior.AddressDomain, data1);
+			args = null;
 			return EventResult.CompletedCallback;
 		}
 	}
@@ -4747,10 +4758,8 @@ namespace Mono.Debugger.Backend
 			inferior.CallMethod (sse.MonoDebuggerInfo.RunFinally, null, ID);
 		}
 
-		protected override EventResult CallbackCompleted (long data1, long data2)
+		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
 		{
-			DiscardStack ();
-
 			StackFrame parent_frame = Backtrace.Frames [++level];
 			inferior.SetRegisters (parent_frame.Registers);
 
@@ -4758,16 +4767,18 @@ namespace Mono.Debugger.Backend
 			Report.Debug (DebugFlags.SSE, "{0} return: {1} {2}\n{3}", sse, level, cframe, parent_frame);
 			if (cframe != null) {
 				Report.Debug (DebugFlags.SSE, "{0} return aborting rti: {1}", sse, cframe);
-				sse.AbortRuntimeInvoke (cframe.ID);
-				return EventResult.Completed;
+				sse.AbortRuntimeInvoke (cframe.ID, out args);
+				return EventResult.CompletedCallback;
 			}
 
 			if (level == Backtrace.Count) {
 				Report.Debug (DebugFlags.SSE, "{0} completed return", sse);
+				args = null;
 				return EventResult.Completed;
 			}
 
 			DoExecute ();
+			args = null;
 			return EventResult.Running;
 		}
 	}
diff --git a/test/testsuite/TestAbort.cs b/test/testsuite/TestAbort.cs
index 3ef1e19..771f402 100644
--- a/test/testsuite/TestAbort.cs
+++ b/test/testsuite/TestAbort.cs
@@ -51,12 +51,13 @@ namespace Mono.Debugger.Tests
 			AssertStopped (thread, "X.Hello()", line_hello);
 
 			AssertExecute ("return -yes");
-			AssertStopped (thread, "X.Main()", line_main);
+
+			AssertRuntimeInvokeDone (thread, "X.Main()", line_main);
 
 			AssertExecute ("call Hello (8)");
 			AssertStopped (thread, "X.Hello(int)", line_hello_2);
 			AssertExecute ("return -yes");
-			AssertStopped (thread, "X.Main()", line_main);
+			AssertRuntimeInvokeDone (thread, "X.Main()", line_main);
 
 			AssertExecute ("call Hello (9)");
 			AssertStopped (thread, "X.Hello(int)", line_hello_2);
@@ -65,7 +66,7 @@ namespace Mono.Debugger.Tests
 			AssertExecute ("return -yes");
 			AssertTargetOutput ("Done: 9 18 1");
 			AssertNoTargetOutput ();
-			AssertStopped (thread, "X.Main()", line_main);
+			AssertRuntimeInvokeDone (thread, "X.Main()", line_main);
 
 			bt = thread.GetBacktrace (-1);
 			if (bt.Count != 1)
@@ -95,7 +96,7 @@ namespace Mono.Debugger.Tests
 			AssertTargetOutput ("Done: 7 14 2");
 			AssertNoTargetOutput ();
 
-			AssertStopped (thread, "X.Main()", line_main);
+			AssertRuntimeInvokeDone (thread, "X.Main()", line_main);
 
 			bt = thread.GetBacktrace (-1);
 			if (bt.Count != 1)

--------------1.5.6--



From 75dc4c9342dbe8b732558545582f2e375e638d00 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 14 Jul 2009 00:08:50 +0200
Subject: [PATCH] Fix this test.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 classes/Thread.cs                 |    2 +-
 frontend/Interpreter.cs           |    4 +
 test/testsuite/TestMultiThread.cs |  113 ++++++++-----------------------------
 3 files changed, 29 insertions(+), 90 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="75dc4c9342dbe8b732558545582f2e375e638d00.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="75dc4c9342dbe8b732558545582f2e375e638d00.diff"

diff --git a/classes/Thread.cs b/classes/Thread.cs
index 97aaf2a..cda710f 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -412,7 +412,7 @@ namespace Mono.Debugger
 		[Obsolete("Background() and Continue() are the same")]
 		public ThreadCommandResult Background ()
 		{
-			return Continue ();
+			return (ThreadCommandResult) Step (ThreadingModel.Single, StepMode.Run, null);
 		}
 
 		[Obsolete("Background() and Continue() are the same")]
diff --git a/frontend/Interpreter.cs b/frontend/Interpreter.cs
index 207c7fb..3382c17 100644
--- a/frontend/Interpreter.cs
+++ b/frontend/Interpreter.cs
@@ -518,6 +518,10 @@ namespace Mono.Debugger.Frontend
 
 		protected virtual void OnTargetEvent (Thread thread, TargetEventArgs args)
 		{
+			if ((args.Type != TargetEventType.TargetSignaled) &&
+			    (args.Type != TargetEventType.TargetExited) &&
+			    (args.Type != TargetEventType.TargetInterrupted))
+				CurrentThread = thread;
 			Style.TargetEvent (thread, args);
 		}
 
diff --git a/test/testsuite/TestMultiThread.cs b/test/testsuite/TestMultiThread.cs
index d622834..d076184 100644
--- a/test/testsuite/TestMultiThread.cs
+++ b/test/testsuite/TestMultiThread.cs
@@ -14,7 +14,7 @@ namespace Mono.Debugger.Tests
 		public TestMultiThread ()
 			: base ("TestMultiThread")
 		{
-			Config.BrokenThreading = true;
+			Config.ThreadingModel = ThreadingModel.Process;
 		}
 
 		const int LineMain = 51;
@@ -84,35 +84,13 @@ namespace Mono.Debugger.Tests
 			AssertPrint (thread, "Parent.Counter", "(int) 0");
 
 			AssertNoEvent ();
-			AssertExecute ("continue -wait -thread " + thread.ID);
-			AssertTargetOutput ("Loop: child 2");
-
-			bool child_event = false, thread_event = false;
-			while (!child_event || !thread_event) {
-				DebuggerEvent e = AssertEvent ();
-
-				if (e.Type == DebuggerEventType.TargetEvent) {
-					Thread e_thread = (Thread) e.Data;
-					TargetEventArgs args = (TargetEventArgs) e.Data2;
-
-					if ((args.Type == TargetEventType.TargetHitBreakpoint) &&
-					    ((int) args.Data == bpt_loop)) {
-						if ((e_thread == thread) && !thread_event) {
-							thread_event = true;
-							continue;
-						} else if ((e_thread == child) && !child_event) {
-							child_event = true;
-							continue;
-						}
-					}
-				}
-
-				Assert.Fail ("Received unexpected event {0}", e);
-			}
+			AssertExecute ("continue -single-thread -thread " + thread.ID);
 
 			AssertTargetOutput ("Loop: main 1");
 			AssertNoTargetOutput ();
 
+			AssertHitBreakpoint (thread, bpt_loop, "X.LoopDone()", LineLoop);
+
 			Assert.IsTrue (thread.IsStopped);
 			Assert.IsTrue (child.IsStopped);
 			Assert.IsTrue (Interpreter.CurrentThread == thread);
@@ -121,77 +99,55 @@ namespace Mono.Debugger.Tests
 			AssertPrint (thread, "Parent.Counter", "(int) 1");
 
 			AssertFrame (thread, "X.LoopDone()", LineLoop);
-			AssertFrame (child, "X.LoopDone()", LineLoop);
 
-			AssertExecute ("continue -wait -thread " + thread.ID);
-			AssertTargetOutput ("Loop: child 3");
-
-			child_event = false; thread_event = false;
-			while (!child_event || !thread_event) {
-				DebuggerEvent e = AssertEvent ();
-
-				if (e.Type == DebuggerEventType.TargetEvent) {
-					Thread e_thread = (Thread) e.Data;
-					TargetEventArgs args = (TargetEventArgs) e.Data2;
-
-					if ((args.Type == TargetEventType.TargetHitBreakpoint) &&
-					    ((int) args.Data == bpt_loop)) {
-						if ((e_thread == thread) && !thread_event) {
-							thread_event = true;
-							continue;
-						} else if ((e_thread == child) && !child_event) {
-							child_event = true;
-							continue;
-						}
-					}
-				}
-
-				Assert.Fail ("Received unexpected event {0}", e);
-			}
+			AssertExecute ("continue -single-thread -thread " + thread.ID);
 
 			AssertTargetOutput ("Loop: main 2");
 			AssertNoTargetOutput ();
 
+			AssertHitBreakpoint (thread, bpt_loop, "X.LoopDone()", LineLoop);
+
 			Assert.IsTrue (thread.IsStopped);
 			Assert.IsTrue (child.IsStopped);
 			Assert.IsTrue (Interpreter.CurrentThread == thread);
 
-			AssertPrint (thread, "Child.Counter", "(int) 3");
+			AssertPrint (thread, "Child.Counter", "(int) 2");
 			AssertPrint (thread, "Parent.Counter", "(int) 2");
 
 			AssertFrame (thread, "X.LoopDone()", LineLoop);
-			AssertFrame (child, "X.LoopDone()", LineLoop);
 
-			AssertExecute ("continue -wait -thread " + child.ID);
-			AssertTargetOutput ("Loop: child 4");
+			AssertExecute ("continue -single-thread -thread " + child.ID);
+			AssertTargetOutput ("Loop: child 2");
 
 			AssertHitBreakpoint (child, bpt_loop, "X.LoopDone()", LineLoop);
+
 			Assert.IsTrue (thread.IsStopped);
 			Assert.IsTrue (child.IsStopped);
 			Assert.IsTrue (Interpreter.CurrentThread == child);
 
-			AssertPrint (child, "Child.Counter", "(int) 4");
-			AssertPrint (child, "Parent.Counter", "(int) 3");
+			AssertPrint (child, "Child.Counter", "(int) 2");
+			AssertPrint (child, "Parent.Counter", "(int) 2");
 
+			AssertFrame (thread, "X.LoopDone()", LineLoop);
 			AssertFrame (child, "X.LoopDone()", LineLoop);
 
-			Backtrace bt = thread.GetBacktrace (Backtrace.Mode.Managed, -1);
-			Assert.IsTrue (bt.Count == 6);
-			AssertFrame (bt [3], 3, "X.Loop()", LineSleep + 1);
-
 			AssertExecute ("continue -thread " + thread.ID);
-			AssertTargetOutput ("Loop: child 5");
+			AssertTargetOutput ("Loop: child 3");
 
 			AssertHitBreakpoint (child, bpt_loop, "X.LoopDone()", LineLoop);
 			Assert.IsTrue (thread.IsStopped);
 			Assert.IsTrue (child.IsStopped);
 			Assert.IsTrue (Interpreter.CurrentThread == child);
 
-			AssertPrint (child, "Child.Counter", "(int) 5");
+			AssertPrint (child, "Child.Counter", "(int) 3");
 			AssertPrint (child, "Parent.Counter", "(int) 3");
 
 			AssertFrame (child, "X.LoopDone()", LineLoop);
 
+			Backtrace bt = thread.GetBacktrace (Backtrace.Mode.Managed, -1);
+			Assert.IsTrue (bt.Count == 6);
+			AssertFrame (bt [3], 3, "X.Loop()", LineSleep + 1);
+
 			AssertExecute ("continue -wait -thread " + thread.ID);
 			AssertTargetOutput ("Loop: main 3");
 
@@ -200,43 +156,22 @@ namespace Mono.Debugger.Tests
 			Assert.IsTrue (child.IsStopped);
 			Assert.IsTrue (Interpreter.CurrentThread == thread);
 
-			AssertPrint (thread, "Child.Counter", "(int) 6");
+			AssertPrint (thread, "Child.Counter", "(int) 3");
 			AssertPrint (thread, "Parent.Counter", "(int) 3");
 
 			Assert.IsTrue (thread.IsStopped);
 			Assert.IsTrue (child.IsStopped);
 			Assert.IsTrue (Interpreter.CurrentThread == thread);
 
+			AssertExecute ("bg -thread " + child.ID);
 			AssertExecute ("continue -wait -thread " + thread.ID);
-			AssertTargetOutput ("Loop: child 6");
-
-			child_event = false; thread_event = false;
-			while (!child_event || !thread_event) {
-				DebuggerEvent e = AssertEvent ();
-
-				if (e.Type == DebuggerEventType.TargetEvent) {
-					Thread e_thread = (Thread) e.Data;
-					TargetEventArgs args = (TargetEventArgs) e.Data2;
-
-					if ((args.Type == TargetEventType.TargetHitBreakpoint) &&
-					    ((int) args.Data == bpt_loop)) {
-						if ((e_thread == thread) && !thread_event) {
-							thread_event = true;
-							continue;
-						} else if ((e_thread == child) && !child_event) {
-							child_event = true;
-							continue;
-						}
-					}
-				}
+			AssertTargetOutput ("Loop: child 4");
 
-				Assert.Fail ("Received unexpected event {0}", e);
-			}
 
 			AssertTargetOutput ("Loop: main 4");
 			AssertNoTargetOutput ();
 
-			AssertPrint (thread, "Child.Counter", "(int) 6");
+			AssertPrint (thread, "Child.Counter", "(int) 4");
 			AssertPrint (thread, "Parent.Counter", "(int) 4");
 
 			AssertFrame (thread, "X.LoopDone()", LineLoop);

--------------1.5.6--



From 3268d30c3fba11c5c969f96c9bef605d995c8318 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 14 Jul 2009 00:59:14 +0200
Subject: [PATCH] Fix managed callbacks.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |   16 ++++++++++++++++
 1 files changed, 16 insertions(+), 0 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="3268d30c3fba11c5c969f96c9bef605d995c8318.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="3268d30c3fba11c5c969f96c9bef605d995c8318.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index cf49e5d..021d9d7 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1569,6 +1569,9 @@ namespace Mono.Debugger.Backend
 				      "{0} acquiring thread lock: {1} {2}",
 				      this, engine_stopped, current_operation);
 
+			if (engine_stopped)
+				return;
+
 			Inferior.ChildEvent stop_event;
 			bool stopped = inferior.Stop (out stop_event);
 			thread_lock = new ThreadLockData (stopped, stop_event, true);
@@ -1611,6 +1614,8 @@ namespace Mono.Debugger.Backend
 			thread_lock.PopRegisters (inferior);
 			if (thread_lock.StopEvent != null)
 				manager.AddPendingEvent (this, thread_lock.StopEvent);
+			if (thread_lock.Stopped)
+				engine_stopped = false;
 
 			thread_lock = null;
 		}
@@ -2236,10 +2241,15 @@ namespace Mono.Debugger.Backend
 					bool ok = false;
 					process.AcquireGlobalThreadLock (this);
 					foreach (SingleSteppingEngine engine in process.ThreadServants) {
+					try {
 						if (engine.do_managed_callback (data)) {
 							ok = true;
 							break;
 						}
+					} catch (Exception ex) {
+						Console.WriteLine ("FUCK: {0} {1}", engine, ex);
+						}
+
 					}
 
 					if (!ok) {
@@ -3670,6 +3680,7 @@ namespace Mono.Debugger.Backend
 	{
 		ThreadLockData thread_lock;
 		Inferior.ChildEvent stop_event;
+		bool resume_when_done;
 
 		public Queue<ManagedCallbackData> CallbackFunctions {
 			get; private set;
@@ -3678,6 +3689,7 @@ namespace Mono.Debugger.Backend
 		public OperationManagedCallback (SingleSteppingEngine sse, ManagedCallbackData data)
 			: base (sse, null)
 		{
+			resume_when_done = sse.HasThreadLock;
 			CallbackFunctions = new Queue<ManagedCallbackData> ();
 			CallbackFunctions.Enqueue (data);
 		}
@@ -3685,6 +3697,7 @@ namespace Mono.Debugger.Backend
 		public OperationManagedCallback (SingleSteppingEngine sse, Queue<ManagedCallbackData> list)
 			: base (sse, null)
 		{
+			this.resume_when_done = true;
 			this.CallbackFunctions = list;
 		}
 
@@ -3755,7 +3768,10 @@ namespace Mono.Debugger.Backend
 			}
 
 			args = null;
+			if (resume_when_done)
 			return EventResult.ResumeOperation;
+			else
+				return EventResult.CompletedCallback;
 		}
 	}
 

--------------1.5.6--



From 9faba76e10b6ae94fad4234b13f3d225889be4d3 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 14 Jul 2009 17:20:34 +0200
Subject: [PATCH] This isn't needed anymore.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |   12 ------------
 1 files changed, 0 insertions(+), 12 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="9faba76e10b6ae94fad4234b13f3d225889be4d3.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="9faba76e10b6ae94fad4234b13f3d225889be4d3.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 021d9d7..94d881f 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -2561,10 +2561,6 @@ namespace Mono.Debugger.Backend
 			get { return false; }
 		}
 
-		public virtual bool SuspendThreadsOnCompletion {
-			get { return false; }
-		}
-
 		protected bool HasChild {
 			get { return child != null; }
 		}
@@ -2816,10 +2812,6 @@ namespace Mono.Debugger.Backend
 			get { return true; }
 		}
 
-		public override bool SuspendThreadsOnCompletion {
-			get { return true; }
-		}
-
 		protected override void DoExecute ()
 		{
 			Report.Debug (DebugFlags.SSE,
@@ -3228,10 +3220,6 @@ namespace Mono.Debugger.Backend
 			get { return true; }
 		}
 
-		public override bool SuspendThreadsOnCompletion {
-			get { return true; }
-		}
-
 		protected OperationStepBase (SingleSteppingEngine sse, CommandResult result)
 			: base (sse, result)
 		{ }

--------------1.5.6--



From 49a4abec8553ee969b0ad0eefe622e446da02bbf Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 14 Jul 2009 19:16:33 +0200
Subject: [PATCH] Fix the completion mess.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |   80 ++++++++++++++++++++++++++++-----------
 classes/Thread.cs               |    1 +
 2 files changed, 59 insertions(+), 22 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="49a4abec8553ee969b0ad0eefe622e446da02bbf.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="49a4abec8553ee969b0ad0eefe622e446da02bbf.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 94d881f..378d3fe 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -281,9 +281,7 @@ namespace Mono.Debugger.Backend
 					current_operation.Result.Completed ();
 				current_operation = rti;
 
-				TargetEventArgs args = null;
-				if ((rti.Flags & RuntimeInvokeFlags.SendEventOnCompletion) != 0)
-					args = new TargetEventArgs (TargetEventType.RuntimeInvokeDone, rti.Result, current_frame);
+				TargetEventArgs args = rti.OperationCompleted (current_frame, false);
 				OperationCompleted (args);
 				return true;
 			}
@@ -548,19 +546,13 @@ namespace Mono.Debugger.Backend
 			}
 		}
 
-		void AbortRuntimeInvoke (long rti_id, out TargetEventArgs args)
+		OperationRuntimeInvoke AbortRuntimeInvoke (long rti_id)
 		{
 			OperationRuntimeInvoke rti = rti_stack.Pop ();
 			if (rti.ID != rti_id)
 				throw new InternalError ("{0} aborting rti failed: {1} {2}", this, rti.ID, rti_id);
 
-			inferior.AbortInvoke (rti_id);
-
-			frame_changed (inferior.CurrentFrame, null);
-			if ((rti.Flags & RuntimeInvokeFlags.SendEventOnCompletion) != 0)
-				args = new TargetEventArgs (TargetEventType.RuntimeInvokeDone, rti.Result, current_frame);
-			else
-				args = null;
+			rti.Abort ();
 
 			if (rti.IsSuspended) {
 				InterruptibleOperation io = nested_break_stack.Pop ();
@@ -568,6 +560,8 @@ namespace Mono.Debugger.Backend
 					throw new InternalError ("{0} aborting rti failed: {1}", this, io);
 				process.OnLeaveNestedBreakState (this);
 			}
+
+			return rti;
 		}
 
 		void OperationCompleted (TargetEventArgs result)
@@ -2751,10 +2745,15 @@ namespace Mono.Debugger.Backend
 				}
 			}
 
-			args = new TargetEventArgs (TargetEventType.TargetStopped, 0, sse.current_frame);
+			args = OperationCompleted (sse.current_frame, result == EventResult.SuspendOperation);
 			return result;
 		}
 
+		public virtual TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
+		{
+			return null;
+		}
+
 		protected abstract EventResult DoProcessEvent (Inferior.ChildEvent cevent,
 							       out TargetEventArgs args);
 
@@ -2861,6 +2860,11 @@ namespace Mono.Debugger.Backend
 			return EventResult.Running;
 		}
 
+		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
+		{
+			return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
+		}
+
 		public override bool HandleException (TargetAddress stack, TargetAddress exc)
 		{
 			return sse.reached_main ? false : true;
@@ -3243,6 +3247,11 @@ namespace Mono.Debugger.Backend
 			return completed ? EventResult.Completed : EventResult.Running;
 		}
 
+		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
+		{
+			return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
+		}
+
 		protected abstract bool DoProcessEvent ();
 
 		protected abstract bool TrampolineHandler (Method method);
@@ -3668,7 +3677,6 @@ namespace Mono.Debugger.Backend
 	{
 		ThreadLockData thread_lock;
 		Inferior.ChildEvent stop_event;
-		bool resume_when_done;
 
 		public Queue<ManagedCallbackData> CallbackFunctions {
 			get; private set;
@@ -3677,7 +3685,6 @@ namespace Mono.Debugger.Backend
 		public OperationManagedCallback (SingleSteppingEngine sse, ManagedCallbackData data)
 			: base (sse, null)
 		{
-			resume_when_done = sse.HasThreadLock;
 			CallbackFunctions = new Queue<ManagedCallbackData> ();
 			CallbackFunctions.Enqueue (data);
 		}
@@ -3685,7 +3692,6 @@ namespace Mono.Debugger.Backend
 		public OperationManagedCallback (SingleSteppingEngine sse, Queue<ManagedCallbackData> list)
 			: base (sse, null)
 		{
-			this.resume_when_done = true;
 			this.CallbackFunctions = list;
 		}
 
@@ -3756,10 +3762,12 @@ namespace Mono.Debugger.Backend
 			}
 
 			args = null;
-			if (resume_when_done)
 				return EventResult.ResumeOperation;
-			else
-				return EventResult.CompletedCallback;
+		}
+
+		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
+		{
+			return null;
 		}
 	}
 
@@ -3771,6 +3779,7 @@ namespace Mono.Debugger.Backend
 		public readonly TargetObject[] ParamObjects;
 		public readonly RuntimeInvokeFlags Flags;
 
+		bool stopped_somewhere;
 		OperationRuntimeInvokeHelper helper;
 
 		public override bool IsSourceOperation {
@@ -3909,6 +3918,25 @@ namespace Mono.Debugger.Backend
 			Result.InvocationCompleted = true;
 		}
 
+		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
+		{
+			if (Result.InvocationCompleted || Result.InvocationAborted) {
+				if (stopped_somewhere || ((Flags & RuntimeInvokeFlags.SendEventOnCompletion) != 0))
+					return new TargetEventArgs (TargetEventType.RuntimeInvokeDone, Result, frame);
+				else
+					return null;
+			}
+
+			stopped_somewhere = true;
+			return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
+		}
+
+		public void Abort ()
+		{
+			inferior.AbortInvoke (ID);
+			Result.InvocationAborted = true;
+		}
+
 		protected class OperationRuntimeInvokeHelper : OperationCallback
 		{
 			public readonly OperationRuntimeInvoke RTI;
@@ -4747,6 +4775,7 @@ namespace Mono.Debugger.Backend
 	{
 		public readonly Backtrace Backtrace;
 		public readonly ReturnMode Mode;
+		OperationRuntimeInvoke aborted_rti;
 		int level = 0;
 
 		public OperationReturn (SingleSteppingEngine sse, Backtrace bt, ReturnMode mode)
@@ -4764,6 +4793,7 @@ namespace Mono.Debugger.Backend
 
 		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
 		{
+			args = null;
 			StackFrame parent_frame = Backtrace.Frames [++level];
 			inferior.SetRegisters (parent_frame.Registers);
 
@@ -4771,20 +4801,26 @@ namespace Mono.Debugger.Backend
 			Report.Debug (DebugFlags.SSE, "{0} return: {1} {2}\n{3}", sse, level, cframe, parent_frame);
 			if (cframe != null) {
 				Report.Debug (DebugFlags.SSE, "{0} return aborting rti: {1}", sse, cframe);
-				sse.AbortRuntimeInvoke (cframe.ID, out args);
-				return EventResult.CompletedCallback;
+				aborted_rti = sse.AbortRuntimeInvoke (cframe.ID);
+				return EventResult.Completed;
 			}
 
 			if (level == Backtrace.Count) {
 				Report.Debug (DebugFlags.SSE, "{0} completed return", sse);
-				args = null;
 				return EventResult.Completed;
 			}
 
 			DoExecute ();
-			args = null;
 			return EventResult.Running;
 		}
+
+		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
+		{
+			if (aborted_rti != null)
+				return aborted_rti.OperationCompleted (frame, suspended);
+			else
+				return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
+		}
 	}
 
 	protected abstract class InterruptibleOperation : Operation
diff --git a/classes/Thread.cs b/classes/Thread.cs
index cda710f..ce0999e 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -896,6 +896,7 @@ namespace Mono.Debugger
 		}
 
 		public long ID;
+		public bool InvocationAborted;
 		public bool InvocationCompleted;
 		public TargetObject ReturnObject;
 		public string ExceptionMessage;

--------------1.5.6--



From d8288bd82ba00ce74d06374c3c0196a6f5abb4ed Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 14 Jul 2009 19:21:54 +0200
Subject: [PATCH] Remove some debugging output.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |    6 +-----
 backend/SingleSteppingEngine.cs |    3 +--
 2 files changed, 2 insertions(+), 7 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="d8288bd82ba00ce74d06374c3c0196a6f5abb4ed.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="d8288bd82ba00ce74d06374c3c0196a6f5abb4ed.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 22b5c1e..42c6322 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -329,8 +329,6 @@ namespace Mono.Debugger.Backend
 		{
 			DropGlobalThreadLock ();
 
-			Console.WriteLine ("ON PROCESS EXITED!");
-
 			if (current_state == ProcessState.Running) {
 				current_state = ProcessState.Exited;
 				current_operation.Completed ();
@@ -696,7 +694,7 @@ namespace Mono.Debugger.Backend
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
 
-			Console.WriteLine ("PROCESS COMPLETED: {0} - {1} {2} {3}", current_state, caller, caller.State, result);
+			Report.Debug (DebugFlags.EventLoop, "{0} completed operation: {1} {2} {3}", caller, current_state, caller.State, result);
 
 			if (current_state == ProcessState.Running) {
 				if ((result != null) &&
@@ -704,10 +702,8 @@ namespace Mono.Debugger.Backend
 					return;
 
 				current_state = ProcessState.Stopping;
-				Console.WriteLine ("SUSPEND THREADS: {0}", caller);
 				SuspendUserThreads (ThreadingModel.Process, caller);
 				caller.Thread.ThreadFlags |= Thread.Flags.AutoRun;
-				Console.WriteLine ("SUSPEND THREADS DONE: {0} {1}", caller, current_operation);
 				current_state = ProcessState.Stopped;
 				current_operation.Completed ();
 				current_operation = null;
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 378d3fe..7edd71a 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1808,8 +1808,7 @@ namespace Mono.Debugger.Backend
 			StartOperation ();
 
 			return (CommandResult) SendCommand (delegate {
-				Console.WriteLine ("STEP: {0} {1} {2} {3}", this, model, mode, frame);
-
+				Report.Debug (DebugFlags.SSE, "{0} step: {1} {2} {3}", this, model, mode, frame);
 				CommandResult result = process.StartOperation (model, this);
 				return ProcessOperation (new OperationStep (this, mode, frame, result));
 			});

--------------1.5.6--



From 997d02d60692636c34b21f8725376b1c54071673 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 14 Jul 2009 19:28:41 +0200
Subject: [PATCH] Daemon and Immutable.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/MonoThreadManager.cs |    8 +++++---
 backend/ProcessServant.cs    |    5 ++++-
 backend/ThreadServant.cs     |   16 +---------------
 3 files changed, 10 insertions(+), 19 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="997d02d60692636c34b21f8725376b1c54071673.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="997d02d60692636c34b21f8725376b1c54071673.diff"

diff --git a/backend/MonoThreadManager.cs b/backend/MonoThreadManager.cs
index bab73c8..78ce298 100644
--- a/backend/MonoThreadManager.cs
+++ b/backend/MonoThreadManager.cs
@@ -239,18 +239,20 @@ namespace Mono.Debugger.Backend
 			sse.Inferior.SetRuntimeInfo (mono_runtime_info);
 			if (!MonoDebuggerInfo.CheckRuntimeVersion (81, 3) && !process.IsAttached) {
 				if (++index < 3)
-					sse.SetDaemon ();
+					sse.Thread.ThreadFlags |= Thread.Flags.Daemon | Thread.Flags.Immutable;
 			} else {
-				sse.SetDaemon ();
+				sse.Thread.ThreadFlags |= Thread.Flags.Daemon | Thread.Flags.Immutable;
 			}
 		}
 
 		void check_thread_flags (SingleSteppingEngine engine, ThreadFlags flags)
 		{
 			if ((flags & (ThreadFlags.Internal | ThreadFlags.ThreadPool)) != ThreadFlags.Internal) {
-				engine.SetManaged ();
+				engine.Thread.ThreadFlags &= ~(Thread.Flags.Daemon | Thread.Flags.Immutable);
 				if (engine != process.MainThread)
 					process.Debugger.Client.OnManagedThreadCreatedEvent (engine.Thread);
+			} else if ((flags & ThreadFlags.ThreadPool) != 0) {
+				engine.Thread.ThreadFlags &= ~Thread.Flags.Immutable;
 			}
 		}
 
diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 42c6322..9621ee7 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -726,7 +726,10 @@ namespace Mono.Debugger.Backend
 					if (engine == caller)
 						continue;
 					if (((engine.Thread.ThreadFlags & Thread.Flags.Immutable) != 0) &&
-					    ((model & ThreadingModel.SuspendAll) == 0))
+					    ((model & ThreadingModel.StopImmutableThreads) == 0))
+						continue;
+					if (((engine.Thread.ThreadFlags & Thread.Flags.Daemon) != 0) &&
+					    ((model & ThreadingModel.StopDaemonThreads) == 0))
 						continue;
 					engine.SuspendUserThread ();
 					engine.Thread.ThreadFlags |= Thread.Flags.AutoRun;
diff --git a/backend/ThreadServant.cs b/backend/ThreadServant.cs
index aff9e80..96ae9d4 100644
--- a/backend/ThreadServant.cs
+++ b/backend/ThreadServant.cs
@@ -36,8 +36,6 @@ namespace Mono.Debugger.Backend
 		protected readonly ThreadManager manager;
 		protected readonly ThreadGroup tgroup;
 
-		bool is_daemon;
-
 		protected internal Language NativeLanguage {
 			get { return process.NativeLanguage; }
 		}
@@ -89,25 +87,13 @@ namespace Mono.Debugger.Backend
 		}
 
 		public bool IsDaemon {
-			get { return is_daemon; }
+			get { return (thread.ThreadFlags & (Thread.Flags.Daemon | Thread.Flags.Immutable)) != 0; }
 		}
 
 		public ThreadGroup ThreadGroup {
 			get { return tgroup; }
 		}
 
-		internal void SetDaemon ()
-		{
-			is_daemon = true;
-			thread.ThreadFlags |= Thread.Flags.Daemon | Thread.Flags.Immutable;
-		}
-
-		internal void SetManaged ()
-		{
-			is_daemon = false;
-			thread.ThreadFlags &= ~(Thread.Flags.Daemon | Thread.Flags.Immutable);
-		}
-
 		public abstract TargetEventArgs LastTargetEvent {
 			get;
 		}

--------------1.5.6--



From c239f23813167683ff8935102ddc2e95f696d7d6 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 14 Jul 2009 19:37:09 +0200
Subject: [PATCH] The traditional '-wait' now resumes threads.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs |   12 +++++++++---
 classes/Thread.cs         |    7 +++----
 frontend/Command.cs       |   27 +++++++++++++--------------
 3 files changed, 25 insertions(+), 21 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="c239f23813167683ff8935102ddc2e95f696d7d6.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="c239f23813167683ff8935102ddc2e95f696d7d6.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 9621ee7..6a94669 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -766,14 +766,20 @@ namespace Mono.Debugger.Backend
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
 
+			if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Default) {
+				if (Inferior.HasThreadEvents)
+					model |= ThreadingModel.Single;
+				else
+					model |= ThreadingModel.Process;
+			}
+
 			if ((current_state != ProcessState.Stopped) && (current_state != ProcessState.SingleThreaded))
 				throw new TargetException (TargetError.NotStopped);
 
 			if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Single) {
 				current_state = ProcessState.SingleThreaded;
-				return new ThreadCommandResult (caller.Thread);
-			} else if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Default) {
-				current_state = ProcessState.SingleThreaded;
+				if ((model & ThreadingModel.ResumeThreads) != 0)
+					ResumeUserThreads (caller);
 				return new ThreadCommandResult (caller.Thread);
 			} else if ((model & ThreadingModel.ThreadingMode) != ThreadingModel.Process) {
 				throw new ArgumentException ();
diff --git a/classes/Thread.cs b/classes/Thread.cs
index ce0999e..5e8de3c 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -26,11 +26,10 @@ namespace Mono.Debugger
 		Process			= 2,
 		Global			= 3,
 
-		SuspendAll		= 0x0100,
-		ResumeThreads		= 0x0200,
+		ResumeThreads		= 0x0100,
 
-		StopDaemonThreads	= 0x0400,
-		StopImmutableThreads	= 0x0800,
+		StopDaemonThreads	= 0x0200,
+		StopImmutableThreads	= 0x0400,
 
 		ThreadingMode		= 0x00FF,
 		ThreadingFlags		= 0xFF00
diff --git a/frontend/Command.cs b/frontend/Command.cs
index ad82337..8a8cc66 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -1278,33 +1278,27 @@ namespace Mono.Debugger.Frontend
 
 	public abstract class SteppingCommand : ThreadCommand
 	{
-		bool in_background;
-		bool single_thread, entire_process;
 		ThreadingModel threading_model;
 
 		[Property ("in-background", "bg")]
 		public bool InBackground {
-			get { return in_background; }
-			set { in_background = value; }
+			get; set;
 		}
 
 		[Obsolete]
 		[Property ("wait")]
 		public bool Wait {
-			get { return single_thread; }
-			set { single_thread = value; }
+			get; set;
 		}
 
 		[Property ("single-thread", "single")]
 		public bool SingleThread {
-			get { return single_thread; }
-			set { single_thread = value; }
+			get; set;
 		}
 
 		[Property ("entire-process", "process")]
 		public bool EntireProcess {
-			get { return entire_process; }
-			set { entire_process = value; }
+			get; set;
 		}
 
 		protected ThreadingModel ThreadingModel {
@@ -1314,12 +1308,17 @@ namespace Mono.Debugger.Frontend
 		protected override bool DoResolveBase (ScriptingContext context)
 		{
 			threading_model = context.Interpreter.DebuggerConfiguration.ThreadingModel;
-			if (single_thread && entire_process)
+			if (SingleThread && EntireProcess)
 				throw new ScriptingException ("Cannot use both `-single-thread' and `-entire-process'.");
-			if (single_thread) {
+			if (Wait) {
+				if (SingleThread || EntireProcess)
+					throw new ScriptingException ("Cannot use `-single-thread' or `-entire-process' together with `-wait'.");
+				threading_model &= ~ThreadingModel.ThreadingMode;
+				threading_model |= ThreadingModel.Single | ThreadingModel.ResumeThreads;
+			} else if (SingleThread) {
 				threading_model &= ~ThreadingModel.ThreadingMode;
 				threading_model |= ThreadingModel.Single;
-			} else if (entire_process) {
+			} else if (EntireProcess) {
 				threading_model &= ~ThreadingModel.ThreadingMode;
 				threading_model |= ThreadingModel.Process;
 			}
@@ -1330,7 +1329,7 @@ namespace Mono.Debugger.Frontend
 		{
 			Thread thread = CurrentThread;
 			CommandResult result = DoStep (thread, context);
-			if (in_background)
+			if (InBackground)
 				return result;
 
 			context.Interpreter.Wait (result);

--------------1.5.6--



From b04dc65c8a9d364044176e3210a3cfa70247dbcb Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 14 Jul 2009 20:11:06 +0200
Subject: [PATCH] Don't mess with 'Thread.Flags.AutoRun' in the backend; add userland option to modify thread flags.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |   17 ++++----
 backend/SingleSteppingEngine.cs |    6 ++-
 classes/Thread.cs               |    4 +-
 frontend/Command.cs             |   81 ++++++++++++++++++++++++--------------
 4 files changed, 67 insertions(+), 41 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="b04dc65c8a9d364044176e3210a3cfa70247dbcb.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="b04dc65c8a9d364044176e3210a3cfa70247dbcb.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 6a94669..5d343d0 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -703,7 +703,6 @@ namespace Mono.Debugger.Backend
 
 				current_state = ProcessState.Stopping;
 				SuspendUserThreads (ThreadingModel.Process, caller);
-				caller.Thread.ThreadFlags |= Thread.Flags.AutoRun;
 				current_state = ProcessState.Stopped;
 				current_operation.Completed ();
 				current_operation = null;
@@ -732,7 +731,6 @@ namespace Mono.Debugger.Backend
 					    ((model & ThreadingModel.StopDaemonThreads) == 0))
 						continue;
 					engine.SuspendUserThread ();
-					engine.Thread.ThreadFlags |= Thread.Flags.AutoRun;
 				}
 			}
 
@@ -740,7 +738,7 @@ namespace Mono.Debugger.Backend
 				      "Done suspending user threads: {0} {1}", model, caller);
 		}
 
-		protected void ResumeUserThreads (SingleSteppingEngine caller)
+		protected void ResumeUserThreads (ThreadingModel model, SingleSteppingEngine caller)
 		{
 			Report.Debug (DebugFlags.Threads,
 				      "Resuming user threads: {0}", caller);
@@ -750,13 +748,16 @@ namespace Mono.Debugger.Backend
 					continue;
 				if ((engine.Thread.ThreadFlags & Thread.Flags.AutoRun) == 0)
 					continue;
+				if (((engine.Thread.ThreadFlags & Thread.Flags.Immutable) != 0) &&
+				    ((model & ThreadingModel.StopImmutableThreads) == 0))
+					continue;
+				if (((engine.Thread.ThreadFlags & Thread.Flags.Daemon) != 0) &&
+				    ((model & ThreadingModel.StopDaemonThreads) == 0))
+					continue;
 
 				engine.ResumeUserThread ();
-				engine.Thread.ThreadFlags &= ~Thread.Flags.AutoRun;
 			}
 
-			caller.Thread.ThreadFlags &= ~Thread.Flags.AutoRun;
-
 			Report.Debug (DebugFlags.Threads,
 				      "Resumed user threads: {0}", caller);
 		}
@@ -779,7 +780,7 @@ namespace Mono.Debugger.Backend
 			if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Single) {
 				current_state = ProcessState.SingleThreaded;
 				if ((model & ThreadingModel.ResumeThreads) != 0)
-					ResumeUserThreads (caller);
+					ResumeUserThreads (model, caller);
 				return new ThreadCommandResult (caller.Thread);
 			} else if ((model & ThreadingModel.ThreadingMode) != ThreadingModel.Process) {
 				throw new ArgumentException ();
@@ -790,7 +791,7 @@ namespace Mono.Debugger.Backend
 			stopped_event.Reset ();
 
 			current_operation = new ProcessOperationResult (this);
-			ResumeUserThreads (caller);
+			ResumeUserThreads (model, caller);
 			return current_operation;
 		}
 
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 7edd71a..1ee66d7 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1676,7 +1676,8 @@ namespace Mono.Debugger.Backend
 				throw new InternalError ();
 
 			Report.Debug (DebugFlags.Threads,
-				      "{0} resume user thread: {1} {2}", this, HasThreadLock, thread.ThreadFlags);
+				      "{0} resume user thread: {1} {2} {3}", this, engine_stopped,
+				      HasThreadLock, thread.ThreadFlags);
 
 			CommandResult result = new ThreadCommandResult (thread);
 
@@ -1693,6 +1694,9 @@ namespace Mono.Debugger.Backend
 				return;
 			}
 
+			if (!engine_stopped)
+				return;
+
 			StartOperation (new OperationStep (this, StepMode.Run, result));
 		}
 
diff --git a/classes/Thread.cs b/classes/Thread.cs
index 5e8de3c..de292ed 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -50,6 +50,7 @@ namespace Mono.Debugger
 		{
 			this.id = id;
 			this.servant = servant;
+			this.flags = Flags.AutoRun;
 		}
 
 		int id;
@@ -119,7 +120,7 @@ namespace Mono.Debugger
 
 		public Flags ThreadFlags {
 			get { return flags; }
-			internal set { flags = value; }
+			set { flags = value; }
 		}
 
 		public string Name {
@@ -444,7 +445,6 @@ namespace Mono.Debugger
 		{
 			check_alive ();
 			servant.Stop ();
-			flags |= Flags.AutoRun;
 		}
 
 		public ThreadCommandResult GetWaitHandle ()
diff --git a/frontend/Command.cs b/frontend/Command.cs
index 8a8cc66..e7955aa 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -1187,18 +1187,15 @@ namespace Mono.Debugger.Frontend
 			if (Argument == "")
 				return true;
 
+			if (Args.Count < 1)
+				throw new ScriptingException ("Thread number expected.");
+
 			try {
-				index = (int) UInt32.Parse (Argument);
+				index = (int) UInt32.Parse ((string) Args [0]);
 			} catch {
-				context.Print ("Thread number expected.");
-				return false;
-			}
-
-			return true;
+				throw new ScriptingException ("Thread number expected.");
 		}
 
-		protected override object DoExecute (ScriptingContext context)
-		{
 			Thread thread;
 			if (index >= 0)
 				thread = context.Interpreter.GetThread (index);
@@ -1206,8 +1203,37 @@ namespace Mono.Debugger.Frontend
 				thread = context.Interpreter.CurrentThread;
 
 			context.Interpreter.CurrentThread = thread;
-			context.Print ("{0} ({1}:{2:x}) {3}", thread,
-				       thread.PID, thread.TID, thread.State);
+
+			for (int i = 1; i < Args.Count; i++) {
+				string arg = (string) Args [i];
+				if (arg == "-auto")
+					thread.ThreadFlags &= ~Thread.Flags.AutoRun;
+				else if ((arg == "+auto") || (arg == "auto"))
+					thread.ThreadFlags |= Thread.Flags.AutoRun;
+				else if (arg == "-immutable")
+					thread.ThreadFlags &= ~Thread.Flags.Immutable;
+				else if ((arg == "+immutable") || (arg == "immutable"))
+					thread.ThreadFlags |= Thread.Flags.Immutable | Thread.Flags.Daemon;
+				else if (arg == "-daemon") {
+					if ((thread.ThreadFlags & Thread.Flags.Immutable) != 0)
+						throw new ScriptingException ("{0} is immutable, cannot remove daemon flag.", thread);
+					thread.ThreadFlags &= ~Thread.Flags.Daemon;
+				} else if ((arg == "+daemon") || (arg == "daemon"))
+					thread.ThreadFlags |= Thread.Flags.Daemon;
+				else
+					throw new ScriptingException ("Invalid thread option `{0}'.", arg);
+			}
+
+			return true;
+		}
+
+		protected override object DoExecute (ScriptingContext context)
+		{
+			Thread thread = context.Interpreter.CurrentThread;
+
+			context.Print ("{0} ({1}:{2:x}) {3} {4}", thread,
+				       thread.PID, thread.TID, thread.State,
+				       thread.ThreadFlags);
 			return thread;
 		}
 
@@ -1301,10 +1327,6 @@ namespace Mono.Debugger.Frontend
 			get; set;
 		}
 
-		protected ThreadingModel ThreadingModel {
-			get { return threading_model; }
-		}
-
 		protected override bool DoResolveBase (ScriptingContext context)
 		{
 			threading_model = context.Interpreter.DebuggerConfiguration.ThreadingModel;
@@ -1327,8 +1349,7 @@ namespace Mono.Debugger.Frontend
 
 		protected override object DoExecute (ScriptingContext context)
 		{
-			Thread thread = CurrentThread;
-			CommandResult result = DoStep (thread, context);
+			CommandResult result = DoStep (CurrentThread, threading_model, context);
 			if (InBackground)
 				return result;
 
@@ -1336,14 +1357,14 @@ namespace Mono.Debugger.Frontend
 			return result;
 		}
 
-		protected abstract CommandResult DoStep (Thread thread, ScriptingContext context);
+		protected abstract CommandResult DoStep (Thread thread, ThreadingModel model, ScriptingContext context);
 	}
 
 	public class ContinueCommand : SteppingCommand, IDocumentableCommand
 	{
-		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
+		protected override CommandResult DoStep (Thread thread, ThreadingModel model, ScriptingContext context)
 		{
-			return thread.Step (ThreadingModel, StepMode.Run, null);
+			return thread.Step (model, StepMode.Run, null);
 		}
 
 		// IDocumentableCommand
@@ -1354,10 +1375,10 @@ namespace Mono.Debugger.Frontend
 
 	public class StepCommand : SteppingCommand, IDocumentableCommand
 	{
-		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
+		protected override CommandResult DoStep (Thread thread, ThreadingModel model, ScriptingContext context)
 		{
 			context.Interpreter.Style.IsNative = false;
-			return thread.Step (ThreadingModel, StepMode.SourceLine, null);
+			return thread.Step (model, StepMode.SourceLine, null);
 		}
 
 		// IDocumentableCommand
@@ -1368,10 +1389,10 @@ namespace Mono.Debugger.Frontend
 
 	public class NextCommand : SteppingCommand, IDocumentableCommand
 	{
-		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
+		protected override CommandResult DoStep (Thread thread, ThreadingModel model, ScriptingContext context)
 		{
 			context.Interpreter.Style.IsNative = false;
-			return thread.Step (ThreadingModel, StepMode.NextLine, null);
+			return thread.Step (model, StepMode.NextLine, null);
 		}
 
 		// IDocumentableCommand
@@ -1389,10 +1410,10 @@ namespace Mono.Debugger.Frontend
 			set { native = value; }
 		}
 
-		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
+		protected override CommandResult DoStep (Thread thread, ThreadingModel model, ScriptingContext context)
 		{
 			context.Interpreter.Style.IsNative = true;
-			return thread.Step (ThreadingModel, Native ? StepMode.NativeInstruction : StepMode.SingleInstruction, null);
+			return thread.Step (model, Native ? StepMode.NativeInstruction : StepMode.SingleInstruction, null);
 		}
 
 		// IDocumentableCommand
@@ -1403,10 +1424,10 @@ namespace Mono.Debugger.Frontend
 
 	public class NextInstructionCommand : SteppingCommand, IDocumentableCommand
 	{
-		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
+		protected override CommandResult DoStep (Thread thread, ThreadingModel model, ScriptingContext context)
 		{
 			context.Interpreter.Style.IsNative = true;
-			return thread.Step (ThreadingModel, StepMode.NextInstruction, null);
+			return thread.Step (model, StepMode.NextInstruction, null);
 		}
 
 		// IDocumentableCommand
@@ -1424,7 +1445,7 @@ namespace Mono.Debugger.Frontend
 			set { native = value; }
 		}
 
-		protected override CommandResult DoStep (Thread thread, ScriptingContext context)
+		protected override CommandResult DoStep (Thread thread, ThreadingModel model, ScriptingContext context)
 		{
 			return thread.Finish (Native);
 		}
@@ -2059,8 +2080,8 @@ namespace Mono.Debugger.Frontend
 						       context.Interpreter.PrintProcess (process));
 					foreach (Thread proc in process.GetThreads ()) {
 						string prefix = proc.ID == current_id ? "(*)" : "   ";
-						context.Print ("{0} {1} ({2}:{3:x}) {4}", prefix, proc,
-							       proc.PID, proc.TID, proc.State);
+						context.Print ("{0} {1} ({2}:{3:x}) {4} {5}", prefix, proc,
+							       proc.PID, proc.TID, proc.State, proc.ThreadFlags);
 						printed_something = true;
 					}
 				}

--------------1.5.6--



From c2ad9c962379deaed5861db9d3753d8f9af9b1c6 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 14 Jul 2009 20:20:58 +0200
Subject: [PATCH] Put back the old test.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 test/src/TestMultiThread.cs       |    2 +-
 test/testsuite/TestMultiThread.cs |  105 ++++++++++++++++++++++++++++++-------
 2 files changed, 87 insertions(+), 20 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="c2ad9c962379deaed5861db9d3753d8f9af9b1c6.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="c2ad9c962379deaed5861db9d3753d8f9af9b1c6.diff"

diff --git a/test/src/TestMultiThread.cs b/test/src/TestMultiThread.cs
index 5b903c4..f89dfba 100644
--- a/test/src/TestMultiThread.cs
+++ b/test/src/TestMultiThread.cs
@@ -17,7 +17,7 @@ public class X
 
 	void Loop ()
 	{
-		Thread.Sleep (Seconds * 100);
+		Thread.Sleep (Seconds * 50);
 	}
 
 	public int Test ()
diff --git a/test/testsuite/TestMultiThread.cs b/test/testsuite/TestMultiThread.cs
index d076184..b11161d 100644
--- a/test/testsuite/TestMultiThread.cs
+++ b/test/testsuite/TestMultiThread.cs
@@ -84,13 +84,35 @@ namespace Mono.Debugger.Tests
 			AssertPrint (thread, "Parent.Counter", "(int) 0");
 
 			AssertNoEvent ();
-			AssertExecute ("continue -single-thread -thread " + thread.ID);
+			AssertExecute ("continue -wait -thread " + thread.ID);
+			AssertTargetOutput ("Loop: child 2");
+
+			bool child_event = false, thread_event = false;
+			while (!child_event || !thread_event) {
+				DebuggerEvent e = AssertEvent ();
+
+				if (e.Type == DebuggerEventType.TargetEvent) {
+					Thread e_thread = (Thread) e.Data;
+					TargetEventArgs args = (TargetEventArgs) e.Data2;
+
+					if ((args.Type == TargetEventType.TargetHitBreakpoint) &&
+					    ((int) args.Data == bpt_loop)) {
+						if ((e_thread == thread) && !thread_event) {
+							thread_event = true;
+							continue;
+						} else if ((e_thread == child) && !child_event) {
+							child_event = true;
+							continue;
+						}
+					}
+				}
+
+				Assert.Fail ("Received unexpected event {0}", e);
+			}
 
 			AssertTargetOutput ("Loop: main 1");
 			AssertNoTargetOutput ();
 
-			AssertHitBreakpoint (thread, bpt_loop, "X.LoopDone()", LineLoop);
-
 			Assert.IsTrue (thread.IsStopped);
 			Assert.IsTrue (child.IsStopped);
 			Assert.IsTrue (Interpreter.CurrentThread == thread);
@@ -99,47 +121,71 @@ namespace Mono.Debugger.Tests
 			AssertPrint (thread, "Parent.Counter", "(int) 1");
 
 			AssertFrame (thread, "X.LoopDone()", LineLoop);
+			AssertFrame (child, "X.LoopDone()", LineLoop);
 
-			AssertExecute ("continue -single-thread -thread " + thread.ID);
+			AssertExecute ("continue -wait -thread " + thread.ID);
+			AssertTargetOutput ("Loop: child 3");
+
+			child_event = false; thread_event = false;
+			while (!child_event || !thread_event) {
+				DebuggerEvent e = AssertEvent ();
+
+				if (e.Type == DebuggerEventType.TargetEvent) {
+					Thread e_thread = (Thread) e.Data;
+					TargetEventArgs args = (TargetEventArgs) e.Data2;
+
+					if ((args.Type == TargetEventType.TargetHitBreakpoint) &&
+					    ((int) args.Data == bpt_loop)) {
+						if ((e_thread == thread) && !thread_event) {
+							thread_event = true;
+							continue;
+						} else if ((e_thread == child) && !child_event) {
+							child_event = true;
+							continue;
+						}
+					}
+				}
+
+				Assert.Fail ("Received unexpected event {0}", e);
+			}
 
 			AssertTargetOutput ("Loop: main 2");
 			AssertNoTargetOutput ();
 
-			AssertHitBreakpoint (thread, bpt_loop, "X.LoopDone()", LineLoop);
-
 			Assert.IsTrue (thread.IsStopped);
 			Assert.IsTrue (child.IsStopped);
 			Assert.IsTrue (Interpreter.CurrentThread == thread);
 
-			AssertPrint (thread, "Child.Counter", "(int) 2");
+			AssertPrint (thread, "Child.Counter", "(int) 3");
 			AssertPrint (thread, "Parent.Counter", "(int) 2");
 
 			AssertFrame (thread, "X.LoopDone()", LineLoop);
+			AssertFrame (child, "X.LoopDone()", LineLoop);
 
-			AssertExecute ("continue -single-thread -thread " + child.ID);
-			AssertTargetOutput ("Loop: child 2");
+			AssertExecute ("continue -single -thread " + child.ID);
+			AssertTargetOutput ("Loop: child 4");
 
 			AssertHitBreakpoint (child, bpt_loop, "X.LoopDone()", LineLoop);
-
 			Assert.IsTrue (thread.IsStopped);
 			Assert.IsTrue (child.IsStopped);
 			Assert.IsTrue (Interpreter.CurrentThread == child);
 
-			AssertPrint (child, "Child.Counter", "(int) 2");
+			AssertPrint (child, "Child.Counter", "(int) 4");
 			AssertPrint (child, "Parent.Counter", "(int) 2");
 
-			AssertFrame (thread, "X.LoopDone()", LineLoop);
 			AssertFrame (child, "X.LoopDone()", LineLoop);
+			AssertFrame (thread, "X.LoopDone()", LineLoop);
 
 			AssertExecute ("continue -thread " + thread.ID);
-			AssertTargetOutput ("Loop: child 3");
+			AssertTargetOutput ("Loop: child 5");
 
 			AssertHitBreakpoint (child, bpt_loop, "X.LoopDone()", LineLoop);
 			Assert.IsTrue (thread.IsStopped);
 			Assert.IsTrue (child.IsStopped);
 			Assert.IsTrue (Interpreter.CurrentThread == child);
 
-			AssertPrint (child, "Child.Counter", "(int) 3");
+
+			AssertPrint (child, "Child.Counter", "(int) 5");
 			AssertPrint (child, "Parent.Counter", "(int) 3");
 
 			AssertFrame (child, "X.LoopDone()", LineLoop);
@@ -148,7 +194,7 @@ namespace Mono.Debugger.Tests
 			Assert.IsTrue (bt.Count == 6);
 			AssertFrame (bt [3], 3, "X.Loop()", LineSleep + 1);
 
-			AssertExecute ("continue -wait -thread " + thread.ID);
+			AssertExecute ("continue -single -thread " + thread.ID);
 			AssertTargetOutput ("Loop: main 3");
 
 			AssertHitBreakpoint (thread, bpt_loop, "X.LoopDone()", LineLoop);
@@ -156,22 +202,43 @@ namespace Mono.Debugger.Tests
 			Assert.IsTrue (child.IsStopped);
 			Assert.IsTrue (Interpreter.CurrentThread == thread);
 
-			AssertPrint (thread, "Child.Counter", "(int) 3");
+			AssertPrint (thread, "Child.Counter", "(int) 5");
 			AssertPrint (thread, "Parent.Counter", "(int) 3");
 
 			Assert.IsTrue (thread.IsStopped);
 			Assert.IsTrue (child.IsStopped);
 			Assert.IsTrue (Interpreter.CurrentThread == thread);
 
-			AssertExecute ("bg -thread " + child.ID);
 			AssertExecute ("continue -wait -thread " + thread.ID);
-			AssertTargetOutput ("Loop: child 4");
+			AssertTargetOutput ("Loop: child 6");
+
+			child_event = false; thread_event = false;
+			while (!child_event || !thread_event) {
+				DebuggerEvent e = AssertEvent ();
+
+				if (e.Type == DebuggerEventType.TargetEvent) {
+					Thread e_thread = (Thread) e.Data;
+					TargetEventArgs args = (TargetEventArgs) e.Data2;
+
+					if ((args.Type == TargetEventType.TargetHitBreakpoint) &&
+					    ((int) args.Data == bpt_loop)) {
+						if ((e_thread == thread) && !thread_event) {
+							thread_event = true;
+							continue;
+						} else if ((e_thread == child) && !child_event) {
+							child_event = true;
+							continue;
+						}
+					}
+				}
 
+				Assert.Fail ("Received unexpected event {0}", e);
+			}
 
 			AssertTargetOutput ("Loop: main 4");
 			AssertNoTargetOutput ();
 
-			AssertPrint (thread, "Child.Counter", "(int) 4");
+			AssertPrint (thread, "Child.Counter", "(int) 6");
 			AssertPrint (thread, "Parent.Counter", "(int) 4");
 
 			AssertFrame (thread, "X.LoopDone()", LineLoop);

--------------1.5.6--



From 7658e1847f0094afc1a95e71a91dd8812dd7c7ce Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 14 Jul 2009 20:26:54 +0200
Subject: [PATCH] DebuggerConfiguration.StayInThread is now gone.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 classes/DebuggerConfiguration.cs           |   17 ++++++-----------
 frontend/Command.cs                        |    5 -----
 test/testsuite/TestActivateBreakpoints2.cs |    3 +--
 test/testsuite/TestAppDomain-Module.cs     |    3 +--
 test/testsuite/TestAppDomain.cs            |    3 +--
 test/testsuite/testnativefork.cs           |    3 +--
 6 files changed, 10 insertions(+), 24 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="7658e1847f0094afc1a95e71a91dd8812dd7c7ce.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="7658e1847f0094afc1a95e71a91dd8812dd7c7ce.diff"

diff --git a/classes/DebuggerConfiguration.cs b/classes/DebuggerConfiguration.cs
index 107dbe3..7105708 100644
--- a/classes/DebuggerConfiguration.cs
+++ b/classes/DebuggerConfiguration.cs
@@ -105,9 +105,9 @@ namespace Mono.Debugger
 			while (iter.MoveNext ()) {
 				if (iter.Current.Name == "LoadNativeSymtabs")
 					LoadNativeSymtabs = Boolean.Parse (iter.Current.Value);
-				else if (iter.Current.Name == "StayInThread")
-					StayInThread = Boolean.Parse (iter.Current.Value);
-				else if (iter.Current.Name == "FollowFork")
+				else if (iter.Current.Name == "StayInThread") {
+					; // ignore, this is no longer in use.
+				} else if (iter.Current.Name == "FollowFork")
 					FollowFork = Boolean.Parse (iter.Current.Value);
 				else if (iter.Current.Name == "OpaqueFileNames")
 					OpaqueFileNames = Boolean.Parse (iter.Current.Value);
@@ -179,10 +179,6 @@ namespace Mono.Debugger
 				load_native_symtabs_e.InnerText = LoadNativeSymtabs ? "true" : "false";
 				element.AppendChild (load_native_symtabs_e);
 
-				XmlElement stay_in_thread_e = doc.CreateElement ("StayInThread");
-				stay_in_thread_e.InnerText = StayInThread ? "true" : "false";
-				element.AppendChild (stay_in_thread_e);
-
 				XmlElement follow_fork_e = doc.CreateElement ("FollowFork");
 				follow_fork_e.InnerText = FollowFork ? "true" : "false";
 				element.AppendChild (follow_fork_e);
@@ -335,9 +331,10 @@ namespace Mono.Debugger
 			set { load_native_symtabs = value; }
 		}
 
+		[Obsolete]
 		public bool StayInThread {
-			get { return stay_in_thread; }
-			set { stay_in_thread = value; }
+			get { return false; }
+			set { ; }
 		}
 
 		[Obsolete]
@@ -419,8 +416,6 @@ namespace Mono.Debugger
 
 			if (expert_mode) {
 				sb.Append ("\nExpert Settings:\n");
-				sb.Append (String.Format ("  Stay in thread (stay-in-thread):       {0}\n",
-							  StayInThread ? "yes" : "no"));
 				string threading_mode;
 				switch (ThreadingModel & ThreadingModel.ThreadingMode) {
 				case ThreadingModel.Single:
diff --git a/frontend/Command.cs b/frontend/Command.cs
index e7955aa..04b41fc 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -3798,11 +3798,6 @@ namespace Mono.Debugger.Frontend
 					config.NestedBreakStates = enable;
 					break;
 
-				case "stay-in-thread":
-					require_expert_mode ();
-					config.StayInThread = enable;
-					break;
-
 				case "stop-daemon-threads":
 					require_expert_mode ();
 					if (enable)
diff --git a/test/testsuite/TestActivateBreakpoints2.cs b/test/testsuite/TestActivateBreakpoints2.cs
index ad83720..38b215f 100644
--- a/test/testsuite/TestActivateBreakpoints2.cs
+++ b/test/testsuite/TestActivateBreakpoints2.cs
@@ -14,8 +14,7 @@ namespace Mono.Debugger.Tests
 		public TestActivateBreakpoints2 ()
 			: base ("TestActivateBreakpoints2")
 		{
-			Config.BrokenThreading = false;
-			Config.StayInThread = true;
+			Config.ThreadingModel = ThreadingModel.Single;
 		}
 
 		[Test]
diff --git a/test/testsuite/TestAppDomain-Module.cs b/test/testsuite/TestAppDomain-Module.cs
index f885720..5bf526d 100644
--- a/test/testsuite/TestAppDomain-Module.cs
+++ b/test/testsuite/TestAppDomain-Module.cs
@@ -14,8 +14,7 @@ namespace Mono.Debugger.Tests
 		public TestAppDomainModule ()
 			: base ("TestAppDomain-Module")
 		{
-			Config.BrokenThreading = false;
-			Config.StayInThread = true;
+			Config.ThreadingModel = ThreadingModel.Single;
 		}
 
 		public override void SetUp ()
diff --git a/test/testsuite/TestAppDomain.cs b/test/testsuite/TestAppDomain.cs
index cf520a7..c17b45a 100644
--- a/test/testsuite/TestAppDomain.cs
+++ b/test/testsuite/TestAppDomain.cs
@@ -14,8 +14,7 @@ namespace Mono.Debugger.Tests
 		public TestAppDomain ()
 			: base ("TestAppDomain")
 		{
-			Config.BrokenThreading = false;
-			Config.StayInThread = true;
+			Config.ThreadingModel = ThreadingModel.Single;
 		}
 
 		public override void SetUp ()
diff --git a/test/testsuite/testnativefork.cs b/test/testsuite/testnativefork.cs
index 2e4d654..a7a65e9 100644
--- a/test/testsuite/testnativefork.cs
+++ b/test/testsuite/testnativefork.cs
@@ -14,8 +14,7 @@ namespace Mono.Debugger.Tests
 		public testnativefork ()
 			: base ("testnativefork", "testnativefork.c")
 		{
-			Config.BrokenThreading = false;
-			Config.StayInThread = true;
+			Config.ThreadingModel = ThreadingModel.Single;
 		}
 
 		const int LineMain = 12;

--------------1.5.6--



From 07bdf69d330b435e387ca6fc75244229c63d9f2b Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 14 Jul 2009 21:07:46 +0200
Subject: [PATCH] Fix starting of new threads and attaching.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/Inferior.cs               |    6 +++-
 backend/ProcessServant.cs         |    5 +++-
 backend/SingleSteppingEngine.cs   |   38 ++++++++----------------------------
 backend/server/x86-linux-ptrace.c |    9 --------
 backend/server/x86-ptrace.c       |    2 +-
 5 files changed, 18 insertions(+), 42 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="07bdf69d330b435e387ca6fc75244229c63d9f2b.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="07bdf69d330b435e387ca6fc75244229c63d9f2b.diff"

diff --git a/backend/Inferior.cs b/backend/Inferior.cs
index f29b785..182dfb0 100644
--- a/backend/Inferior.cs
+++ b/backend/Inferior.cs
@@ -685,7 +685,7 @@ namespace Mono.Debugger.Backend
 
 		public void Attach (int pid)
 		{
-			if (has_target)
+			if (has_target || initialized)
 				throw new TargetException (TargetError.AlreadyHaveTarget);
 
 			has_target = true;
@@ -699,7 +699,9 @@ namespace Mono.Debugger.Backend
 
 			start.SetupApplication (exe_file, cwd, cmdline_args);
 
-			InitializeThread (pid);
+			initialized = true;
+
+			SetupInferior ();
 
 			change_target_state (TargetState.Stopped, 0);
 		}
diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 5d343d0..0a77bff 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -204,7 +204,8 @@ namespace Mono.Debugger.Backend
 				get_thread_info (inferior, new_thread);
 			OnThreadCreatedEvent (new_thread);
 
-			new_thread.StartThread (resume_thread);
+			if (resume_thread)
+				new_thread.StartThread ();
 		}
 
 		internal void ChildForked (Inferior inferior, int pid)
@@ -722,6 +723,8 @@ namespace Mono.Debugger.Backend
 
 			if ((model & ThreadingModel.Process) != 0) {
 				foreach (SingleSteppingEngine engine in thread_hash.Values) {
+					Report.Debug (DebugFlags.Threads, "  check user thread: {0} {1}",
+						      engine, engine.Thread.ThreadFlags);
 					if (engine == caller)
 						continue;
 					if (((engine.Thread.ThreadFlags & Thread.Flags.Immutable) != 0) &&
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 1ee66d7..322feb7 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -109,11 +109,13 @@ namespace Mono.Debugger.Backend
 			this.inferior = inferior;
 			this.pid = pid;
 
+			engine_stopped = true;
 			manager.AddEngine (this);
 		}
 
 		public CommandResult StartApplication (CommandResult result)
 		{
+			engine_stopped = false;
 			current_operation = new OperationStart (this, result);
 			current_operation.Execute ();
 			return result;
@@ -121,23 +123,23 @@ namespace Mono.Debugger.Backend
 
 		public void StartExecedChild ()
 		{
+			engine_stopped = false;
 			CommandResult result = new ThreadCommandResult (thread);
 			current_operation = new OperationStart (this, result);
 			current_operation.Execute ();
 		}
 
-		public CommandResult StartThread (bool resume_thread)
+		public CommandResult StartThread ()
 		{
-			if (resume_thread)
+			engine_stopped = false;
 				current_operation = new OperationStep (this, StepMode.Run, new ThreadCommandResult (thread));
-			else
-				current_operation = new OperationInitialize (this, new ThreadCommandResult (thread));
 			current_operation.Execute ();
 			return current_operation.Result;
 		}
 
 		public CommandResult StartForkedChild ()
 		{
+			engine_stopped = false;
 			CommandResult result = new ThreadCommandResult (thread);
 			current_operation = new OperationStep (this, StepMode.Run, result);
 			PushOperation (new OperationInitAfterFork (this));
@@ -1650,6 +1652,9 @@ namespace Mono.Debugger.Backend
 				      "{0} suspend user thread: {1} {2}",
 				      this, engine_stopped, current_operation);
 
+			if (engine_stopped)
+				return;
+
 			Inferior.ChildEvent stop_event;
 			bool stopped = inferior.Stop (out stop_event);
 
@@ -2982,31 +2987,6 @@ namespace Mono.Debugger.Backend
 		}
 	}
 
-	protected class OperationInitialize : Operation
-	{
-		public OperationInitialize (SingleSteppingEngine sse, CommandResult result)
-			: base (sse, result)
-		{ }
-
-		public override bool IsSourceOperation {
-			get { return true; }
-		}
-
-		protected override void DoExecute ()
-		{ }
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} initialize ({1})", sse,
-				      DebuggerWaitHandle.CurrentThread);
-
-			args = null;
-			return EventResult.Completed;
-		}
-	}
-
 	protected class OperationInitAfterFork : Operation
 	{
 		public OperationInitAfterFork (SingleSteppingEngine sse)
diff --git a/backend/server/x86-linux-ptrace.c b/backend/server/x86-linux-ptrace.c
index 2f77438..d4d7240 100644
--- a/backend/server/x86-linux-ptrace.c
+++ b/backend/server/x86-linux-ptrace.c
@@ -348,15 +348,6 @@ _server_ptrace_wait_for_new_thread (ServerHandle *handle)
 	}
 
 	/*
-	 * If the call succeeds, then we're already stopped.
-	 */
-
-	if (x86_arch_get_registers (handle) == COMMAND_ERROR_NONE) {
-		g_static_mutex_unlock (&wait_mutex);
-		return TRUE;
-	}
-
-	/*
 	 * We own the `wait_mutex', so no other thread is currently waiting for the target
 	 * and we can safely wait for it here.
 	 */
diff --git a/backend/server/x86-ptrace.c b/backend/server/x86-ptrace.c
index 48007c4..ae24934 100644
--- a/backend/server/x86-ptrace.c
+++ b/backend/server/x86-ptrace.c
@@ -486,7 +486,7 @@ server_ptrace_attach (ServerHandle *handle, guint32 pid)
 	if (!_server_ptrace_wait_for_new_thread (handle))
 		return COMMAND_ERROR_INTERNAL_ERROR;
 
-	return COMMAND_ERROR_NONE;
+	return _server_ptrace_setup_inferior (handle);
 }
 
 static void

--------------1.5.6--



From a3a5689d4355eff4ca6e868511e79965363d59e5 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 15 Jul 2009 03:12:36 +0200
Subject: [PATCH] Don't wait for the child after exec.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/Inferior.cs                 |   19 +-
 backend/ProcessServant.cs           |    2 +-
 backend/SingleSteppingEngine.cs.new | 4901 +++++++++++++++++++++++++++++++++++
 backend/server/library.c            |    4 +-
 backend/server/server.h             |    6 +-
 backend/server/x86-ptrace.c         |    4 +-
 6 files changed, 4927 insertions(+), 9 deletions(-)
 create mode 100644 backend/SingleSteppingEngine.cs.new
--------------1.5.6
Content-Type: text/x-patch; name="a3a5689d4355eff4ca6e868511e79965363d59e5.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="a3a5689d4355eff4ca6e868511e79965363d59e5.diff"

diff --git a/backend/Inferior.cs b/backend/Inferior.cs
index 182dfb0..07a86ec 100644
--- a/backend/Inferior.cs
+++ b/backend/Inferior.cs
@@ -65,7 +65,7 @@ namespace Mono.Debugger.Backend
 		static extern TargetError mono_debugger_server_initialize_process (IntPtr handle);
 
 		[DllImport("monodebuggerserver")]
-		static extern TargetError mono_debugger_server_initialize_thread (IntPtr handle, int child_pid);
+		static extern TargetError mono_debugger_server_initialize_thread (IntPtr handle, int child_pid, bool wait);
 
 		[DllImport("monodebuggerserver")]
 		static extern TargetError mono_debugger_server_io_thread_main (IntPtr io_data, ChildOutputHandler output_handler);
@@ -675,7 +675,22 @@ namespace Mono.Debugger.Backend
 
 			initialized = true;
 
-			check_error (mono_debugger_server_initialize_thread (server_handle, pid));
+			check_error (mono_debugger_server_initialize_thread (server_handle, pid, true));
+			this.child_pid = pid;
+
+			SetupInferior ();
+
+			change_target_state (TargetState.Stopped, 0);
+		}
+
+		public void InitializeAfterExec (int pid)
+		{
+			if (initialized)
+				throw new TargetException (TargetError.AlreadyHaveTarget);
+
+			initialized = true;
+
+			check_error (mono_debugger_server_initialize_thread (server_handle, pid, false));
 			this.child_pid = pid;
 
 			SetupInferior ();
diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 0a77bff..f2d1638 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -268,7 +268,7 @@ namespace Mono.Debugger.Backend
 			native_language = new NativeLanguage (this, os, target_info);
 
 			Inferior new_inferior = Inferior.CreateInferior (manager, this, start);
-			new_inferior.InitializeThread (inferior.PID);
+			new_inferior.InitializeAfterExec (inferior.PID);
 
 			SingleSteppingEngine new_thread = new SingleSteppingEngine (
 				manager, this, new_inferior, inferior.PID);
diff --git a/backend/SingleSteppingEngine.cs.new b/backend/SingleSteppingEngine.cs.new
new file mode 100644
index 0000000..3e90643
--- /dev/null
+++ b/backend/SingleSteppingEngine.cs.new
@@ -0,0 +1,4901 @@
+using System;
+using System.IO;
+using System.Text;
+using System.Threading;
+using System.Configuration;
+using System.Globalization;
+using System.Reflection;
+using System.Diagnostics;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.Specialized;
+using System.Runtime.InteropServices;
+using System.Runtime.Serialization;
+using System.Runtime.Remoting.Messaging;
+
+using Mono.Debugger.Languages;
+using Mono.Debugger.Languages.Mono;
+using Mono.Debugger.Architectures;
+
+namespace Mono.Debugger.Backend
+{
+// <summary>
+//   The single stepping engine is responsible for doing all the stepping
+//   operations.
+//
+//     sse                  - short for single stepping engine.
+//
+//     stepping operation   - an operation which has been invoked by the user such
+//                            as StepLine(), NextLine() etc.
+//
+//     atomic operation     - an operation which the sse invokes on the target
+//                            such as stepping one machine instruction or resuming
+//                            the target until a breakpoint is hit.
+//
+//     step frame           - an address range; the sse invokes atomic operations
+//                            until the target hit a breakpoint, received a signal
+//                            or stopped at an address outside this range.
+//
+//     temporary breakpoint - a breakpoint which is automatically removed the next
+//                            time the target stopped; it is used to step over
+//                            method calls.
+//
+//     source stepping op   - stepping operation based on the program's source code,
+//                            such as StepLine() or NextLine().
+//
+//     native stepping op   - stepping operation based on the machine code such as
+//                            StepInstruction() or NextInstruction().
+//
+//   The SingleSteppingEngine supports both synchronous and asynchronous
+//   operations; in synchronous mode, the engine waits until the child has stopped
+//   before returning.  In either case, the step commands return true on success
+//   and false an error.
+//
+//   Since the SingleSteppingEngine can be used from multiple threads at the same
+//   time, you can no longer safely use the `State' property to find out whether
+//   the target is stopped or not.  It is safe to call all the step commands from
+//   multiple threads, but for obvious reasons only one command can run at a
+//   time.  So if you attempt to issue a step command while the engine is still
+//   busy, the step command will return false to signal this error.
+// </summary>
+
+	// <summary>
+	//   The ThreadManager creates one SingleSteppingEngine instance for each thread
+	//   in the target.
+	//
+	//   The `SingleSteppingEngine' class is basically just responsible for whatever happens
+	//   in the background thread: processing commands and events.  Their methods
+	//   are just meant to be called from the SingleSteppingEngine (since it's a
+	//   protected nested class they can't actually be called from anywhere else).
+	//
+	//   See the `Thread' class for the "user interface".
+	// </summary>
+	internal class SingleSteppingEngine : ThreadServant
+	{
+		// <summary>
+		//   This is invoked after compiling a trampoline - it returns whether or
+		//   not we should enter that trampoline.
+		// </summary>
+		internal delegate bool TrampolineHandler (Method method);
+		internal delegate bool CheckBreakpointHandler ();
+
+		protected SingleSteppingEngine (ThreadManager manager, ProcessServant process)
+			: base (manager, process)
+		{
+			Report.Debug (DebugFlags.Threads, "New SSE ({0}): {1}",
+				      DebuggerWaitHandle.CurrentThread, this);
+		}
+
+		public SingleSteppingEngine (ThreadManager manager, ProcessServant process,
+					     ProcessStart start)
+			: this (manager, process)
+		{
+			inferior = Inferior.CreateInferior (manager, process, start);
+
+			if (start.PID != 0) {
+				this.pid = start.PID;
+				inferior.Attach (pid);
+			} else {
+				pid = inferior.Run ();
+			}
+
+			manager.AddEngine (this);
+		}
+
+		public SingleSteppingEngine (ThreadManager manager, ProcessServant process,
+					     Inferior inferior, int pid)
+			: this (manager, process)
+		{
+			this.inferior = inferior;
+			this.pid = pid;
+
+			engine_stopped = true;
+			manager.AddEngine (this);
+		}
+
+		public CommandResult StartApplication (CommandResult result)
+		{
+			engine_stopped = false;
+			current_operation = new OperationStart (this, result);
+			current_operation.Execute ();
+			return result;
+		}
+
+		public void StartExecedChild ()
+		{
+			engine_stopped = false;
+			CommandResult result = new ThreadCommandResult (thread);
+			current_operation = new OperationStart (this, result);
+			current_operation.Execute ();
+		}
+
+		public CommandResult StartThread ()
+		{
+			engine_stopped = false;
+			current_operation = new OperationStep (this, StepMode.Run, new ThreadCommandResult (thread));
+			current_operation.Execute ();
+			return current_operation.Result;
+		}
+
+		public CommandResult StartForkedChild ()
+		{
+			engine_stopped = false;
+			CommandResult result = new ThreadCommandResult (thread);
+			current_operation = new OperationStep (this, StepMode.Run, result);
+			PushOperation (new OperationInitAfterFork (this));
+			return result;
+		}
+
+#region child event processing
+		// <summary>
+		//   This is called from the SingleSteppingEngine's main event loop to give
+		//   us the next event - `status' has no meaning to us, it's just meant to
+		//   be passed to inferior.ProcessEvent() to get the actual event.
+		// </summary>
+		// <remarks>
+		//   Actually, `status' is the waitpid() status code.  In Linux 2.6.x, you
+		//   can call waitpid() from any thread in the debugger, but we need to get
+		//   the target's registers to find out whether it's a breakpoint etc.
+		//   That's done in inferior.ProcessEvent() - which must always be called
+		//   from the engine's thread.
+		// </remarks>
+		public void ProcessEvent (int status)
+		{
+			if (inferior == null)
+				return;
+
+			ProcessEvent (inferior.ProcessEvent (status));
+		}
+
+		public bool ProcessEvent (Inferior.ChildEvent cevent)
+		{
+			Report.Debug (DebugFlags.EventLoop, "{0} received event {1}",
+				      this, cevent);
+
+			if (killed) {
+				if (cevent.Type == Inferior.ChildEventType.CHILD_INTERRUPTED) {
+					inferior.Continue ();
+					return true;
+				} else if (cevent.Type != Inferior.ChildEventType.CHILD_EXITED) {
+					Report.Debug (DebugFlags.EventLoop,
+						      "{0} received event {1} when already killed",
+						      this, cevent);
+					return true;
+				}
+			}
+
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_EXITED) ||
+			    (cevent.Type == Inferior.ChildEventType.CHILD_SIGNALED)) {
+				Report.Debug (DebugFlags.SSE, "{0} received {1}", this, cevent);
+				// we can't remove the breakpoint anymore after
+				// the target exited, but we need to clear this id.
+				temp_breakpoint = null;
+				dead = true;
+			} else {
+				string frame_text = "";
+				Inferior.StackFrame iframe = inferior.GetCurrentFrame (true);
+				if (iframe != null)
+					frame_text = "at " + iframe.Address.ToString ();
+
+				string running_text;
+				if (HasThreadLock)
+					running_text = String.Format ("being thread-locked ({0})", thread_lock);
+				else
+					running_text = String.Format ("running {0}", current_operation);
+
+				string event_text;
+				if (cevent.Type == Inferior.ChildEventType.CHILD_NOTIFICATION)
+					event_text = String.Format ("notification {0} ({1})", cevent, (NotificationType) cevent.Argument);
+				else
+					event_text = "event " + cevent.ToString ();
+
+				Report.Debug (DebugFlags.EventLoop, "{0} received {1} {2} while {3}",
+					      this, event_text, frame_text, running_text);
+
+				if (HasThreadLock) {
+					thread_lock.SetStopEvent (cevent);
+					return false;
+				}
+			}
+
+			if (ProcessServant.IsAttached && !attach_initialized) {
+				attach_initialized = true;
+
+				if (cevent.Type == Inferior.ChildEventType.CHILD_INTERRUPTED)
+					cevent = new Inferior.ChildEvent (Inferior.ChildEventType.CHILD_STOPPED, 0, 0, 0);
+			}
+
+			bool resume_target;
+			if (manager.HandleChildEvent (this, inferior, ref cevent, out resume_target)) {
+				Report.Debug (DebugFlags.EventLoop,
+					      "{0} done handling event: {1}{2}{3}{4}",
+					      this, cevent, resume_target ? " resume-target" : "" ,
+					      stop_requested ? " stop-requested" : "",
+					      HasThreadLock ? " thread-lock" : "");
+				if (stop_requested) {
+					OperationInterrupted ();
+				} else if (resume_target) {
+					if (!current_operation.ResumeOperation ())
+						inferior.Continue ();
+				}
+				return true;
+			}
+
+			Inferior.ChildEventType message = cevent.Type;
+			int arg = (int) cevent.Argument;
+
+			switch (message) {
+			case Inferior.ChildEventType.CHILD_INTERRUPTED:
+				OperationInterrupted ();
+				return true;
+			case Inferior.ChildEventType.CHILD_SIGNALED:
+				if (killed)
+					OperationCompleted (new TargetEventArgs (TargetEventType.TargetExited, 0));
+				else
+					OperationCompleted (new TargetEventArgs (TargetEventType.TargetSignaled, arg));
+				return true;
+
+			case Inferior.ChildEventType.CHILD_EXITED:
+				OperationCompleted (new TargetEventArgs (TargetEventType.TargetExited, arg));
+				return true;
+
+			case Inferior.ChildEventType.CHILD_CALLBACK_COMPLETED:
+				frame_changed (inferior.CurrentFrame, null);
+				OperationCompleted (new TargetEventArgs (TargetEventType.TargetStopped, 0, current_frame));
+				return true;
+
+			case Inferior.ChildEventType.RUNTIME_INVOKE_DONE:
+				OperationRuntimeInvoke rti = rti_stack.Pop ();
+				if (rti.ID != cevent.Argument)
+					throw new InternalError ("{0} got unknown RUNTIME_INVOKE_DONE: {1} {2}", this, rti.ID, cevent);
+
+				frame_changed (inferior.CurrentFrame, null);
+				rti.Completed (cevent.Data1, cevent.Data2);
+
+				if (rti.IsSuspended) {
+					InterruptibleOperation io = nested_break_stack.Pop ();
+					if (io != rti)
+						throw new InternalError ("{0} unexpected item on nested break state stack: {1}", this, io);
+					process.OnLeaveNestedBreakState (this);
+				}
+
+				if (current_operation != rti)
+					current_operation.Result.Completed ();
+				current_operation = rti;
+
+				TargetEventArgs args = rti.OperationCompleted (current_frame, false);
+				OperationCompleted (args);
+				return true;
+			}
+
+			if (stop_requested) {
+				switch (message) {
+				case Inferior.ChildEventType.CHILD_STOPPED:
+				case Inferior.ChildEventType.CHILD_CALLBACK:
+				case Inferior.ChildEventType.CHILD_HIT_BREAKPOINT:
+					OperationInterrupted ();
+					return true;
+
+				case Inferior.ChildEventType.UNHANDLED_EXCEPTION:
+				case Inferior.ChildEventType.THROW_EXCEPTION:
+				case Inferior.ChildEventType.HANDLE_EXCEPTION:
+				case Inferior.ChildEventType.CHILD_NOTIFICATION:
+					inferior.RestartNotification ();
+					OperationInterrupted ();
+					return true;
+
+				default:
+					OperationInterrupted ();
+					return false;
+				}
+			}
+
+			DoProcessEvent (cevent);
+			return true;
+		}
+
+		protected void DoProcessEvent (Inferior.ChildEvent cevent)
+		{
+			Inferior.ChildEventType message = cevent.Type;
+			int arg = (int) cevent.Argument;
+
+			if (message == Inferior.ChildEventType.THROW_EXCEPTION) {
+				TargetAddress info = new TargetAddress (inferior.AddressDomain, cevent.Data1);
+				TargetAddress ip = new TargetAddress (manager.AddressDomain, cevent.Data2);
+
+				Report.Debug (DebugFlags.EventLoop,
+					      "{0} received exception: {1} {2} {3}", this, message, info, ip);
+
+				TargetAddress stack = inferior.ReadAddress (info);
+				TargetAddress exc = inferior.ReadAddress (info + inferior.TargetAddressSize);
+
+				ExceptionAction action = throw_exception (stack, exc, ip);
+
+				Report.Debug (DebugFlags.SSE,
+					      "{0} throw exception ({1}:{2}:{3}) - {4} - {5} - {6}",
+					      this, stack, exc, ip, action, current_operation, temp_breakpoint);
+
+				switch (action) {
+				case ExceptionAction.None:
+					do_continue ();
+					return;
+
+				case ExceptionAction.Stop:
+					inferior.WriteInteger (info + 2 * inferior.TargetAddressSize, 1);
+					PushOperation (new OperationException (this, ip, exc, false));
+					return;
+
+				case ExceptionAction.StopUnhandled:
+					if (!check_runtime_version (81, 1) && !check_runtime_version (80, 1))
+						goto case ExceptionAction.Stop;
+					inferior.WriteInteger (info + 4 + 2 * inferior.TargetAddressSize, 1);
+					do_continue ();
+					return;
+				}
+			}
+
+			if (message == Inferior.ChildEventType.HANDLE_EXCEPTION) {
+				TargetAddress info = new TargetAddress (inferior.AddressDomain, cevent.Data1);
+				TargetAddress ip = new TargetAddress (manager.AddressDomain, cevent.Data2);
+
+				Report.Debug (DebugFlags.EventLoop,
+					      "{0} received exception: {1} {2} {3}", this, message, info, ip);
+
+				TargetAddress stack = inferior.ReadAddress (info);
+				TargetAddress exc = inferior.ReadAddress (info + inferior.TargetAddressSize);
+
+				bool stop = handle_exception (stack, exc, ip);
+
+				Report.Debug (DebugFlags.SSE,
+					      "{0} {1}stopping at exception handler ({2}:{3}:{4}) - {4} - {5}",
+					      this, stop ? "" : "not ", stack, exc, ip, current_operation, temp_breakpoint);
+
+				if (stop) {
+					inferior.WriteInteger (info + 2 * inferior.TargetAddressSize, 1);
+					PushOperation (new OperationException (this, ip, exc, false));
+					return;
+				}
+
+				do_continue ();
+				return;
+			}
+
+
+			if (lmf_breakpoint != null) {
+				if ((message == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) &&
+				    (arg == lmf_breakpoint.Breakpoint.ID)) {
+					remove_lmf_breakpoint ();
+
+					Report.Debug (DebugFlags.SSE, "{0} back in managed land: {1}",
+						      this, inferior.CurrentFrame);
+
+					Method method = Lookup (inferior.CurrentFrame);
+
+					bool is_managed = (method != null) && method.Module.Language.IsManaged;
+					Report.Debug (DebugFlags.SSE, "{0} back in managed land #1: {1}", this, is_managed);
+
+					Queue<ManagedCallbackData> queue = process.MonoManager.ClearManagedCallbacks (inferior);
+					OnManagedCallback (queue);
+					return;
+				}
+			}
+
+			// To step over a method call, the sse inserts a temporary
+			// breakpoint immediately after the call instruction and then
+			// resumes the target.
+			//
+			// If the target stops and we have such a temporary breakpoint, we
+			// need to distinguish a few cases:
+			//
+			// a) we may have received a signal
+			// b) we may have hit another breakpoint
+			// c) we actually hit the temporary breakpoint
+			//
+			// In either case, we need to remove the temporary breakpoint if
+			// the target is to remain stopped.  Note that this piece of code
+			// here only deals with the temporary breakpoint, the handling of
+			// a signal or another breakpoint is done later.
+			if ((temp_breakpoint != null) &&
+			    (message == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) && (arg == temp_breakpoint.ID)) {
+				// we hit the temporary breakpoint; this'll always
+				// happen in the `correct' thread since the
+				// `temp_breakpoint_id' is only set in this
+				// SingleSteppingEngine and not in any other thread's.
+
+				remove_temporary_breakpoint ();
+
+				Breakpoint bpt = lookup_breakpoint (arg);
+				Report.Debug (DebugFlags.SSE,
+					      "{0} hit temporary breakpoint {1} at {2} {3}",
+					      this, arg, inferior.CurrentFrame, bpt);
+				if ((bpt == null) || !bpt.Breaks (thread.ID) || bpt.HideFromUser) {
+					message = Inferior.ChildEventType.CHILD_STOPPED;
+					arg = 0;
+					cevent = new Inferior.ChildEvent (Inferior.ChildEventType.CHILD_STOPPED, 0, 0, 0);
+				} else {
+					ProcessOperationEvent (cevent);
+					return;
+				}
+			}
+
+			if (message == Inferior.ChildEventType.UNHANDLED_EXCEPTION) {
+				TargetAddress exc = new TargetAddress (manager.AddressDomain, cevent.Data1);
+				TargetAddress ip = new TargetAddress (manager.AddressDomain, cevent.Data2);
+				PushOperation (new OperationException (this, ip, exc, true));
+				return;
+			} else if (message == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) {
+				// Ok, the next thing we need to check is whether this is actually "our"
+				// breakpoint or whether it belongs to another thread.  In this case,
+				// `step_over_breakpoint' does everything for us and we can just continue
+				// execution.
+				Breakpoint bpt;
+				bool remain_stopped = child_breakpoint (cevent, arg, out bpt);
+				if (!remain_stopped) {
+					do_continue ();
+					return;
+				}
+			}
+
+			ProcessOperationEvent (cevent);
+		}
+
+		protected void ProcessOperationEvent (Inferior.ChildEvent cevent)
+		{
+			TargetEventArgs result = null;
+
+			Inferior.ChildEventType message = cevent.Type;
+			int arg = (int) cevent.Argument;
+
+			//
+			// Sometimes, we need to do just one atomic operation - in all
+			// other cases, `current_operation' is the current stepping
+			// operation.
+			//
+			// ProcessEvent() will either start another atomic operation
+			// (and return false) or tell us the stepping operation is
+			// completed by returning true.
+			//
+
+			if (current_operation == null)
+				throw new InternalError ("SSE {0} has no current operation, but received event {1}", this, cevent);
+
+			Report.Debug (DebugFlags.EventLoop, "{0} process operation event: {1} {2}", this, current_operation, cevent);
+
+			Operation.EventResult status = current_operation.ProcessEvent (cevent, out result);
+
+			Report.Debug (DebugFlags.EventLoop, "{0} processed operation event: {1} {2} {3} {4}", this,
+				      current_operation, cevent, status, result);
+
+			switch (status) {
+			case Operation.EventResult.Running:
+				return;
+
+			case Operation.EventResult.Completed:
+			case Operation.EventResult.SuspendOperation: {
+				Operation.EventResult new_status = current_operation.CompletedOperation (cevent, status, ref result);
+				if (new_status == Operation.EventResult.Running)
+					return;
+				else if (new_status == Operation.EventResult.Completed)
+					OperationCompleted (result);
+				else if (new_status == Operation.EventResult.SuspendOperation)
+					OperationCompleted (result, true);
+				else
+					throw new InternalError ("Got unexpected event result: {0}", new_status);
+
+				return;
+			}
+
+			case Operation.EventResult.ResumeOperation:
+				if (current_operation.ResumeOperation ())
+					return;
+				status = Operation.EventResult.Completed;
+				goto case Operation.EventResult.Completed;
+
+			default:
+				throw new InternalError ("Got unexpected event result: {0}", status);
+			}
+		}
+
+		bool check_runtime_version (int major, int minor)
+		{
+			if (MonoDebuggerInfo.MajorVersion < major)
+				return false;
+			if (MonoDebuggerInfo.MajorVersion > major)
+				return true;
+			return MonoDebuggerInfo.MinorVersion >= minor;
+		}
+
+#endregion
+
+		void OperationInterrupted ()
+		{
+			frame_changed (inferior.CurrentFrame, null);
+
+			long abort_rti = -1;
+			lock (this) {
+				abort_rti = abort_requested;
+				abort_requested = -1;
+			}
+			Report.Debug (DebugFlags.SSE, "{0} operation interrupted: {1} - {2}", this, abort_rti, current_frame);
+			if (abort_rti >= 0) {
+				DoAbortInvocation (abort_rti);
+			} else {
+				OperationCompleted (new TargetEventArgs (TargetEventType.TargetInterrupted, 0, current_frame));
+			}
+		}
+
+		OperationRuntimeInvoke AbortRuntimeInvoke (long rti_id)
+		{
+			OperationRuntimeInvoke rti = rti_stack.Pop ();
+			if (rti.ID != rti_id)
+				throw new InternalError ("{0} aborting rti failed: {1} {2}", this, rti.ID, rti_id);
+
+			rti.Abort ();
+
+			if (rti.IsSuspended) {
+				InterruptibleOperation io = nested_break_stack.Pop ();
+				if (io != rti)
+					throw new InternalError ("{0} aborting rti failed: {1}", this, io);
+				process.OnLeaveNestedBreakState (this);
+			}
+
+			return rti;
+		}
+
+		void OperationCompleted (TargetEventArgs result)
+		{
+			OperationCompleted (result, false);
+		}
+
+		void OperationCompleted (TargetEventArgs result, bool suspended)
+		{
+			lock (this) {
+				remove_temporary_breakpoint ();
+				engine_stopped = true;
+				stop_requested = false;
+				last_target_event = result;
+
+				process.OperationCompleted (this, result);
+
+				operation_completed_event.Set ();
+
+				Report.Debug (DebugFlags.EventLoop, "{0} {1} operation {2}: {3}",
+					      this, suspended ? "suspending" : "terminating", current_operation, result);
+
+				if (suspended) {
+					process.OnEnterNestedBreakState (this);
+					((InterruptibleOperation) current_operation).IsSuspended = true;
+					nested_break_stack.Push ((InterruptibleOperation) current_operation);
+					current_operation.CompletedOperation (true);
+					current_operation = null;
+				} else {
+					if (current_operation != null) {
+						Report.Debug (DebugFlags.EventLoop, "{0} setting completed: {1} {2}",
+							      this, current_operation, current_operation.Result);
+						current_operation.CompletedOperation (false);
+						current_operation = null;
+					}
+				}
+			}
+		}
+
+		internal void OnManagedThreadCreated (TargetAddress end_stack_address)
+		{
+			this.end_stack_address = end_stack_address;
+		}
+
+		internal void SetTID (long tid)
+		{
+			this.tid = tid;
+		}
+
+		internal void SetManagedThreadData (TargetAddress lmf_address,
+						    TargetAddress extended_notifications_addr)
+		{
+			this.lmf_address = lmf_address;
+			this.extended_notifications_addr = extended_notifications_addr;
+		}
+
+		internal void SetMainReturnAddress (TargetAddress main_ret)
+		{
+			if(main_ret.IsNull)
+				this.main_retaddr = TargetAddress.Null;
+			else
+			{
+				this.main_retaddr = main_ret + inferior.TargetAddressSize;
+				this.reached_main = true;
+			}
+		}
+
+		internal void OnManagedThreadExited ()
+		{
+			this.end_stack_address = TargetAddress.Null;
+			process.OnManagedThreadExitedEvent (this);
+		}
+
+		internal void OnThreadExited (Inferior.ChildEvent cevent)
+		{
+			TargetEventArgs result;
+			int arg = (int) cevent.Argument;
+			if (killed)
+				result = new TargetEventArgs (TargetEventType.TargetExited, 0);
+			else if (cevent.Type == Inferior.ChildEventType.CHILD_SIGNALED)
+				result = new TargetEventArgs (TargetEventType.TargetSignaled, arg);
+			else
+				result = new TargetEventArgs (TargetEventType.TargetExited, arg);
+			temp_breakpoint = null;
+			OperationCompleted (result);
+
+			process.OnThreadExitedEvent (this);
+			Dispose ();
+		}
+
+		Breakpoint lookup_breakpoint (int index)
+		{
+			BreakpointHandle handle = process.BreakpointManager.LookupBreakpoint (index);
+			if (handle == null)
+				return null;
+
+			return handle.Breakpoint;
+		}
+
+		void set_registers (Registers registers)
+		{
+			if (!registers.FromCurrentFrame)
+				throw new InvalidOperationException ();
+
+			this.registers = registers;
+			inferior.SetRegisters (registers);
+		}
+
+		// <summary>
+		//   Start a new stepping operation.
+		//
+		//   All stepping operations are done asynchronously.
+		//
+		//   The inferior basically just knows two kinds of stepping operations:
+		//   there is do_continue() to continue execution (until a breakpoint is
+		//   hit or the target receives a signal or exits) and there is do_step_native()
+		//   to single-step one machine instruction.  There's also a version of
+		//   do_continue() which takes an address - it inserts a temporary breakpoint
+		//   on that address and calls do_continue().
+		//
+		//   Let's call these "atomic operations" while a "stepping operation" is
+		//   something like stepping until the next source line.  We normally need to
+		//   do several atomic operations for each stepping operation.
+		//
+		//   We start a new stepping operation here, but what we actually do is
+		//   starting an atomic operation on the target.  Note that we just start it,
+		//   but don't wait until is completed.  Once the target is running, we go
+		//   back to the main event loop and wait for it (or another thread) to stop
+		//   (or to get another command from the user).
+		// </summary>
+		void StartOperation ()
+		{
+			lock (this) {
+				Report.Debug (DebugFlags.SSE, "{0} start operation: {1} {2}",
+					      this, engine_stopped, HasThreadLock);
+
+				if (!engine_stopped || HasThreadLock) {
+					Report.Debug (DebugFlags.Wait, "{0} not stopped: {1} {2}",
+						      this, engine_stopped, HasThreadLock);
+					throw new TargetException (TargetError.NotStopped);
+				}
+
+				engine_stopped = false;
+				last_target_event = null;
+				operation_completed_event.Reset ();
+			}
+		}
+
+		object SendCommand (TargetAccessDelegate target)
+		{
+			if (inferior == null)
+				throw new TargetException (TargetError.NoTarget);
+
+			if (ThreadManager.InBackgroundThread)
+				return target (thread, null);
+			else
+				return manager.SendCommand (this, target, null);
+		}
+
+		CommandResult StartOperation (Operation operation)
+		{
+			StartOperation ();
+
+			return (CommandResult) SendCommand (delegate {
+				return ProcessOperation (operation);
+			});
+		}
+
+		CommandResult ProcessOperation (Operation operation)
+		{
+			Report.Debug (DebugFlags.SSE,  "{0} starting {1}", this, operation);
+			PushOperation (operation);
+			return operation.Result;
+		}
+
+		void PushOperation (Operation operation)
+		{
+			if (current_operation != null)
+				current_operation.PushOperation (operation);
+			else
+				current_operation = operation;
+			ExecuteOperation (operation);
+		}
+
+		void ExecuteOperation (Operation operation)
+		{
+			try {
+				check_inferior ();
+
+				InterruptibleOperation iop = operation as InterruptibleOperation;
+				if ((iop != null) && iop.IsSuspended) {
+					iop.IsSuspended = false;
+					do_continue ();
+					return;
+				} else {
+					operation.Execute ();
+				}
+			} catch (Exception ex) {
+				Report.Debug (DebugFlags.SSE, "{0} caught exception while " +
+					      "processing operation {1}: {2}", this, operation, ex);
+				operation.Result.Result = ex;
+				OperationCompleted (null);
+			}
+		}
+
+		public override TargetEventArgs LastTargetEvent {
+			get { return last_target_event; }
+		}
+
+		public override Method Lookup (TargetAddress address)
+		{
+			process.UpdateSymbolTable (inferior);
+			Method method = process.SymbolTableManager.Lookup (address);
+			Report.Debug (DebugFlags.JitSymtab, "{0} lookup {1}: {2}",
+				      this, address, method);
+			return method;
+		}
+
+		public override Symbol SimpleLookup (TargetAddress address, bool exact_match)
+		{
+			return process.SymbolTableManager.SimpleLookup (address, exact_match);
+		}
+
+#region public properties
+		internal Inferior Inferior {
+			get { return inferior; }
+		}
+
+		internal override Architecture Architecture {
+			get { return inferior.Architecture; }
+		}
+
+		public Thread Thread {
+			get { return thread; }
+		}
+
+		public override int PID {
+			get { return pid; }
+		}
+
+		public override long TID {
+			get { return tid; }
+		}
+
+		public override bool IsAlive {
+			get { return !dead && !killed && (inferior != null); }
+		}
+
+		public override TargetAddress LMFAddress {
+			get { return lmf_address; }
+		}
+
+		public override bool CanRun {
+			get { return true; }
+		}
+
+		public override bool CanStep {
+			get { return true; }
+		}
+
+		public override bool IsStopped {
+			get { return engine_stopped; }
+		}
+
+		public override WaitHandle WaitHandle {
+			get { return operation_completed_event; }
+		}
+
+		internal override ProcessServant ProcessServant {
+			get { return process; }
+		}
+
+		internal override ThreadManager ThreadManager {
+			get { return manager; }
+		}
+
+		public override Backtrace CurrentBacktrace {
+			get { return current_backtrace; }
+		}
+
+		public override StackFrame CurrentFrame {
+			get { return current_frame; }
+		}
+
+		public override Method CurrentMethod {
+			get { return current_method; }
+		}
+
+		public override TargetAddress CurrentFrameAddress {
+			get { return inferior.CurrentFrame; }
+		}
+
+		protected MonoDebuggerInfo MonoDebuggerInfo {
+			get { return process.MonoManager.MonoDebuggerInfo; }
+		}
+
+		public override TargetState State {
+			get {
+				if (inferior == null)
+					return TargetState.NoTarget;
+				else if (HasThreadLock)
+					return TargetState.Busy;
+				else
+					return inferior.State;
+			}
+		}
+#endregion
+
+		internal bool HasThreadLock {
+			get { return thread_lock != null; }
+		}
+
+		protected TargetAddress EndStackAddress {
+			get { return end_stack_address; }
+		}
+
+		public override TargetMemoryInfo TargetMemoryInfo {
+			get {
+				check_inferior ();
+				return inferior.TargetMemoryInfo;
+			}
+		}
+
+		public override TargetMemoryArea[] GetMemoryMaps ()
+		{
+			check_inferior ();
+			return inferior.GetMemoryMaps ();
+		}
+
+		public override void Kill ()
+		{
+			killed = true;
+			SendCommand (delegate {
+				Inferior.ChildEvent stop_event;
+				Report.Debug (DebugFlags.SSE, "{0} kill: {1}", this, engine_stopped);
+				if (!engine_stopped) {
+					bool stopped = inferior.Stop (out stop_event);
+					Report.Debug (DebugFlags.SSE, "{0} kill #1: {1} {2} {3}",
+						      this, engine_stopped, stopped, stop_event);
+				}
+				inferior.Kill ();
+				Report.Debug (DebugFlags.SSE, "{0} kill #2", this);
+				return null;
+			});
+		}
+
+		public void SetKilledFlag ()
+		{
+			killed = true;
+		}
+
+		internal override object DoTargetAccess (TargetAccessHandler func)
+		{
+			return SendCommand (delegate {
+				return func (inferior);
+			});
+		}
+
+		public override void Detach ()
+		{
+			SendCommand (delegate {
+				if (!engine_stopped) {
+					Report.Debug (DebugFlags.Wait,
+						      "{0} not stopped", this);
+					throw new TargetException (TargetError.NotStopped);
+				}
+
+				process.AcquireGlobalThreadLock (this);
+				process.BreakpointManager.RemoveAllBreakpoints (inferior);
+
+				if (process.MonoManager != null)
+					process.MonoManager.Detach (inferior);
+				DoDetach ();
+
+				process.DropGlobalThreadLock ();
+				return null;
+			});
+		}
+
+		protected void DoDetach ()
+		{
+			foreach (ThreadServant servant in process.ThreadServants)
+				servant.DetachThread ();
+		}
+
+		internal override void DetachThread ()
+		{
+			if (inferior != null) {
+				inferior.Detach ();
+				inferior.Dispose ();
+				inferior = null;
+			}
+
+			OperationCompleted (new TargetEventArgs (TargetEventType.TargetExited, 0));
+			process.OnThreadExitedEvent (this);
+			Dispose ();
+		}
+
+		public override void Stop ()
+		{
+			lock (this) {
+				Report.Debug (DebugFlags.EventLoop, "{0} interrupt: {1} {2}",
+					      this, engine_stopped, current_operation);
+
+				if (engine_stopped)
+					return;
+
+				bool stopped = inferior.Stop ();
+				if (!Inferior.HasThreadEvents && !stopped)
+					OperationInterrupted ();
+				
+				Report.Debug (DebugFlags.EventLoop, "{0} interrupt #1: {1}",
+					      this, stopped);
+			}
+		}
+
+		protected void check_inferior ()
+		{
+			if (inferior == null)
+				throw new TargetException (TargetError.NoTarget);
+		}
+
+		// <summary>
+		//   A breakpoint has been hit; now the sse needs to find out what do do:
+		//   either ignore the breakpoint and continue or keep the target stopped
+		//   and send out the notification.
+		//
+		//   If @index is zero, we hit an "unknown" breakpoint - ie. a
+		//   breakpoint which we did not create.  Normally, this means that there
+		//   is a breakpoint instruction (such as G_BREAKPOINT ()) in the code.
+		//   Such unknown breakpoints are handled by the Debugger; one of
+		//   the language backends may recognize the breakpoint's address, for
+		//   instance if this is the JIT's breakpoint trampoline.
+		//
+		//   Returns true if the target should remain stopped and false to
+		//   continue stepping.
+		//
+		//   If we can't find a handler for the breakpoint, the default is to stop
+		//   the target and let the user decide what to do.
+		// </summary>
+		bool child_breakpoint (Inferior.ChildEvent cevent, int index, out Breakpoint bpt)
+		{
+			// The inferior knows about breakpoints from all threads, so if this is
+			// zero, then no other thread has set this breakpoint.
+			if (index == 0) {
+				bpt = null;
+				return true;
+			}
+
+			bpt = lookup_breakpoint (index);
+			if ((bpt == null) || !bpt.Breaks (thread.ID))
+				return false;
+
+			if (!process.BreakpointManager.IsBreakpointEnabled (index))
+				return false;
+
+			index = bpt.Index;
+
+			bool remain_stopped;
+			if (bpt.BreakpointHandler (inferior, out remain_stopped))
+				return remain_stopped;
+
+			TargetAddress address = inferior.CurrentFrame;
+			return bpt.CheckBreakpointHit (thread, address);
+		}
+
+		bool step_over_breakpoint (bool singlestep, TargetAddress until)
+		{
+			int index;
+			bool is_enabled;
+			process.BreakpointManager.LookupBreakpoint (
+				inferior.CurrentFrame, out index, out is_enabled);
+
+			if ((index == 0) || !is_enabled)
+				return false;
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} stepping over breakpoint {1} at {2} until {3}",
+				      this, index, inferior.CurrentFrame, until);
+
+			Instruction instruction = inferior.Architecture.ReadInstruction (
+				inferior, inferior.CurrentFrame);
+
+			if ((instruction == null) || !instruction.HasInstructionSize ||
+			    !process.CanExecuteCode) {
+				PushOperation (new OperationStepOverBreakpoint (this, index, until));
+				return true;
+			}
+
+			if (instruction.InterpretInstruction (inferior)) {
+				if (!singlestep)
+					return false;
+
+				byte[] nop_insn = Architecture.Opcodes.GenerateNopInstruction ();
+				PushOperation (new OperationExecuteInstruction (this, nop_insn, false));
+				return true;
+			}
+
+			if (instruction.IsIpRelative) {
+				PushOperation (new OperationStepOverBreakpoint (this, index, until));
+				return true;
+			}
+
+			PushOperation (new OperationExecuteInstruction (this, instruction.Code, true));
+			return true;
+		}
+
+		void enable_extended_notification (NotificationType type)
+		{
+			long notifications = inferior.ReadLongInteger (extended_notifications_addr);
+			notifications |= (uint) type;
+			inferior.WriteLongInteger (extended_notifications_addr, notifications);
+		}
+
+		void disable_extended_notification (NotificationType type)
+		{
+			long notifications = inferior.ReadLongInteger (extended_notifications_addr);
+			notifications &= ~(long) type;
+			inferior.WriteLongInteger (extended_notifications_addr, notifications);
+		}
+
+		ExceptionAction throw_exception (TargetAddress stack, TargetAddress exc, TargetAddress ip)
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} throwing exception {1} at {2} / {3} while running {4}", this, exc, ip,
+				      stack, current_operation);
+
+			OperationRuntimeInvoke rti = current_operation as OperationRuntimeInvoke;
+			if ((rti != null) && !rti.NestedBreakStates)
+				return ExceptionAction.None;
+
+			TargetObject exc_obj = process.MonoLanguage.CreateObject (inferior, exc);
+			if (exc_obj == null)
+				return ExceptionAction.None; // OOOPS
+
+			Report.Debug (DebugFlags.SSE, "{0} throwing exception: {1}", this, exc_obj.Type.Name);
+
+			ExceptionAction action;
+			if (process.Client.GenericExceptionCatchPoint (exc_obj.Type.Name, out action)) {
+				Report.Debug (DebugFlags.SSE,
+					      "{0} generic exception catchpoint: {1}", this, action);
+				return action;
+			}
+
+			foreach (ExceptionCatchPoint handle in process.ExceptionCatchPoints) {
+				Report.Debug (DebugFlags.SSE,
+					      "{0} invoking exception handler {1} for {0}",
+					      this, handle.Name, exc);
+
+				if (!handle.CheckException (process.MonoLanguage, inferior, exc))
+					continue;
+
+				return handle.Unhandled ? ExceptionAction.StopUnhandled : ExceptionAction.Stop;
+			}
+
+			return ExceptionAction.None;
+		}
+
+		bool handle_exception (TargetAddress stack, TargetAddress exc, TargetAddress ip)
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} handling exception {1} at {2} while running {3}", this, exc, ip,
+				      current_operation);
+
+			if (current_operation == null)
+				return true;
+
+			return current_operation.HandleException (stack, exc);
+		}
+
+		// <summary>
+		//   Check whether @address is inside @frame.
+		// </summary>
+		bool is_in_step_frame (StepFrame frame, TargetAddress address)
+                {
+			if (address.IsNull || frame.Start.IsNull)
+				return false;
+
+                        if ((address < frame.Start) || (address >= frame.End))
+                                return false;
+
+                        return true;
+                }
+
+		// <summary>
+		//   This is called when a stepping operation is completed or something
+		//   unexpected happened (received signal etc.).
+		//
+		//   Normally, we just compute the new StackFrame here, but we may also
+		//   discover that we need to do one more stepping operation, see
+		//   check_method_operation().
+		// </summary>
+		Operation frame_changed (TargetAddress address, Operation operation)
+		{
+			// Mark the current stack frame and backtrace as invalid.
+			frames_invalid ();
+
+			bool same_method = false;
+
+			// Only do a method lookup if we actually need it.
+			if ((current_method != null) &&
+			    Method.IsInSameMethod (current_method, address))
+				same_method = true;
+			else
+				current_method = Lookup (address);
+
+			// If some clown requested a backtrace while doing the symbol lookup ....
+			frames_invalid ();
+
+			Inferior.StackFrame iframe = inferior.GetCurrentFrame ();
+			registers = inferior.GetRegisters ();
+
+			if ((operation != null) && !main_retaddr.IsNull && (iframe.StackPointer >= main_retaddr))
+				return new OperationStep (this, StepMode.Run, operation.Result);
+
+			// Compute the current stack frame.
+			if ((current_method != null) && current_method.HasLineNumbers) {
+				Block block = current_method.LookupBlock (inferior, address);
+				if (block != null) {
+					if (block.BlockType == Block.Type.IteratorDispatcher)
+						return new OperationStepIterator (
+							this, current_method, operation.Result);
+					else if (block.BlockType == Block.Type.CompilerGenerated)
+						return new OperationStepCompilerGenerated (
+							this, current_method, block, operation.Result);
+				}
+
+				SourceAddress source = current_method.LineNumberTable.Lookup (address);
+
+				if (!same_method) {
+					// If check_method_operation() returns true, it already
+					// started a stepping operation, so the target is
+					// currently running.
+					Operation new_operation = check_method_operation (
+						address, current_method, source, operation);
+					if (new_operation != null)
+						return new_operation;
+				}
+
+				if (source != null)
+					update_current_frame (new StackFrame (
+						thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
+						iframe.FrameAddress, registers, current_method, source));
+				else
+					update_current_frame (new StackFrame (
+						thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
+						iframe.FrameAddress, registers, current_method));
+			} else {
+				if (!same_method && (current_method != null)) {
+					Operation new_operation = check_method_operation (
+						address, current_method, null, operation);
+					if (new_operation != null)
+						return new_operation;
+				}
+
+				if (current_method != null)
+					update_current_frame (new StackFrame (
+						thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
+						iframe.FrameAddress, registers, current_method));
+				else {
+					Symbol name;
+					try {
+						name = SimpleLookup (address, false);
+					} catch {
+						name = null;
+					}
+					update_current_frame (new StackFrame (
+						thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
+						iframe.FrameAddress, registers, thread.NativeLanguage,
+						name));
+				}
+			}
+
+			return null;
+		}
+
+		// <summary>
+		//   Checks whether to do a "method operation".
+		//
+		//   This is only used while doing a source stepping operation and ensures
+		//   that we don't stop somewhere inside a method's prologue code or
+		//   between two source lines.
+		// </summary>
+		Operation check_method_operation (TargetAddress address, Method method,
+						  SourceAddress source, Operation operation)
+		{
+			// Do nothing if this is not a source stepping operation.
+			if ((operation == null) || !operation.IsSourceOperation)
+				return null;
+
+			if (method.WrapperType != WrapperType.None)
+				return new OperationWrapper (this, method, operation.Result);
+			if (method.IsIterator)
+				return new OperationStepIterator (this, method, operation.Result);
+
+			Language language = method.Module.Language;
+			if (source == null)
+				return null;
+
+			if ((source.LineOffset > 0) && (source.LineRange > 0)) {
+				// We stopped between two source lines.  This normally
+				// happens when returning from a method call; in this
+				// case, we need to continue stepping until we reach the
+				// next source line.
+				StepFrame sframe = new StepFrame (
+					language, StepMode.SourceLine, null,
+					address - source.LineOffset, address + source.LineRange);
+				return new OperationStep (this, sframe, operation.Result);
+			}
+
+			LineNumberTable lnt = method.LineNumberTable;
+			if (lnt.HasMethodBounds && (address < lnt.MethodStartAddress)) {
+				StepFrame sframe = new StepFrame (
+					null, StepMode.Finish, null,
+					method.StartAddress, lnt.MethodStartAddress);
+				return new OperationStep (this, sframe, operation.Result);
+			} else if (method.HasMethodBounds && (address < method.MethodStartAddress)) {
+				// Do not stop inside a method's prologue code, but stop
+				// immediately behind it (on the first instruction of the
+				// method's actual code).
+				StepFrame sframe = new StepFrame (
+					null, StepMode.Finish, null,
+					method.StartAddress, method.MethodStartAddress);
+				return new OperationStep (this, sframe, operation.Result);
+			}
+
+			return null;
+		}
+
+		void frames_invalid ()
+		{
+			current_frame = null;
+			current_backtrace = null;
+			registers = null;
+		}
+
+		void update_current_frame (StackFrame new_frame)
+		{
+			current_frame = new_frame;
+		}
+
+		TemporaryBreakpointData temp_breakpoint = null;
+
+		void insert_temporary_breakpoint (TargetAddress address)
+		{
+			check_inferior ();
+
+			if (temp_breakpoint != null)
+				throw new InternalError ("temp_breakpoint_id != 0");
+
+			int dr_index;
+			int id = inferior.InsertHardwareBreakpoint (address, true, out dr_index);
+			temp_breakpoint = new TemporaryBreakpointData (id, address);
+
+			Report.Debug (DebugFlags.SSE, "{0} inserted temp breakpoint {1}:{2} at {3}",
+				      this, id, dr_index, address);
+		}
+
+		void remove_temporary_breakpoint ()
+		{
+			if (temp_breakpoint != null) {
+				Report.Debug (DebugFlags.SSE, "{0} removing temp breakpoint {1}",
+					      this, temp_breakpoint);
+
+				inferior.RemoveBreakpoint (temp_breakpoint.ID);
+				temp_breakpoint = null;
+			}
+		}
+
+		// <summary>
+		//   Step over the next machine instruction.
+		// </summary>
+		void do_next ()
+		{
+			check_inferior ();
+			frames_invalid ();
+			TargetAddress address = inferior.CurrentFrame;
+
+			// Check whether this is a call instruction.
+			Instruction instruction = inferior.Architecture.ReadInstruction (
+				inferior, address);
+			if ((instruction == null) || !instruction.HasInstructionSize) {
+				do_step ();
+				return;
+			}
+
+			Report.Debug (DebugFlags.SSE, "{0} do_next: {1} {2}", this,
+				      address, instruction.InstructionType);
+
+			// Step one instruction unless this is a call
+			if (!instruction.IsCall) {
+				do_step ();
+				return;
+			}
+
+			// Insert a temporary breakpoint immediately behind it and continue.
+			address += instruction.InstructionSize;
+			do_continue (address);
+		}
+
+		// <summary>
+		//   Resume the target.
+		// </summary>
+		void do_continue ()
+		{
+			do_continue (TargetAddress.Null);
+		}
+
+		void do_continue (TargetAddress until)
+		{
+			check_inferior ();
+			frames_invalid ();
+
+			if (step_over_breakpoint (false, until))
+				return;
+
+			if (!until.IsNull)
+				insert_temporary_breakpoint (until);
+			inferior.Continue ();
+		}
+
+		void do_step_native ()
+		{
+			if (step_over_breakpoint (true, TargetAddress.Null))
+				return;
+
+			inferior.Step ();
+		}
+
+		void do_step ()
+		{
+			if (step_over_breakpoint (true, TargetAddress.Null))
+				return;
+
+			/*
+			 * Don't step into any signal handlers.
+			 */
+
+			if (inferior.IsManagedSignal (inferior.GetPendingSignal ())) {
+				do_continue (inferior.CurrentFrame);
+			} else {
+				inferior.Step ();
+			}
+		}
+
+		protected bool CheckTrampoline (Instruction instruction, TrampolineHandler handler)
+		{
+			TargetAddress trampoline;
+			Instruction.TrampolineType type = instruction.CheckTrampoline (
+				inferior, out trampoline);
+			if (type == Instruction.TrampolineType.None)
+				return false;
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} found trampoline {1}:{2} at {3} while running {4}",
+				      this, type, trampoline, instruction.Address, current_operation);
+
+			if (type == Instruction.TrampolineType.NativeTrampolineStart) {
+				PushOperation (new OperationNativeTrampoline (this, trampoline, handler));
+				return true;
+			} else if (type == Instruction.TrampolineType.NativeTrampoline) {
+				Method method = Lookup (trampoline);
+				if (!MethodHasSource (method))
+					do_next ();
+				else
+					do_continue (trampoline);
+				return true;
+			} else if (type == Instruction.TrampolineType.MonoTrampoline) {
+				PushOperation (new OperationMonoTrampoline (
+					this, instruction, trampoline, handler));
+				return true;
+			} else if (type == Instruction.TrampolineType.DelegateInvoke) {
+				PushOperation (new OperationDelegateInvoke (this));
+				return true;
+			}
+
+			return false;
+		}
+
+		protected bool MethodHasSource (Method method)
+		{
+			if ((method == null) || !method.HasLineNumbers || !method.HasMethodBounds)
+				return false;
+
+			if (method.WrapperType == WrapperType.ManagedToNative) {
+				DebuggerConfiguration config = process.Session.Config;
+				ModuleGroup native_group = config.GetModuleGroup ("native");
+				if (!native_group.StepInto)
+					return false;
+			}
+
+			if (current_method != null) {
+				if ((method.Module != current_method.Module) && !method.Module.StepInto)
+					return false;
+			} else {
+				if (!method.Module.StepInto)
+					return false;
+			}
+
+			if (!method.HasSource || method.IsWrapper || method.IsCompilerGenerated)
+				return false;
+
+			LineNumberTable lnt = method.LineNumberTable;
+			if (lnt == null)
+				return false;
+
+			SourceAddress addr = lnt.Lookup (method.MethodStartAddress);
+			if (addr == null) {
+				Report.Error ("OOOOPS - No source for method: {0}", method);
+				lnt.DumpLineNumbers (Console.Out);
+				return false;
+			}
+
+			return true;
+		}
+
+		// <summary>
+		//   Create a step frame to step until the next source line.
+		// </summary>
+		StepFrame CreateStepFrame ()
+		{
+			check_inferior ();
+			StackFrame frame = current_frame;
+			Language language = (frame.Method != null) ? frame.Method.Module.Language : null;
+
+			if (frame.SourceAddress == null)
+				return new StepFrame (language, StepMode.SingleInstruction);
+
+			// The current source line started at the current address minus
+			// SourceOffset; the next source line will start at the current
+			// address plus SourceRange.
+
+			int offset = frame.SourceAddress.LineOffset;
+			int range = frame.SourceAddress.LineRange;
+
+			TargetAddress start = frame.TargetAddress - offset;
+			TargetAddress end = frame.TargetAddress + range;
+
+			return new StepFrame (language, StepMode.StepFrame, frame, start, end);
+		}
+
+		// <summary>
+		//   Create a step frame for a native stepping operation.
+		// </summary>
+		StepFrame CreateStepFrame (StepMode mode)
+		{
+			check_inferior ();
+			Language language = (current_method != null) ?
+				current_method.Module.Language : null;
+
+			return new StepFrame (language, mode);
+		}
+
+		StackData save_stack (long id)
+		{
+			//
+			// Save current state.
+			//
+			StackData stack_data = new StackData (
+				id, current_method, inferior.CurrentFrame, current_frame,
+				current_backtrace, registers);
+
+			current_method = null;
+			current_frame = null;
+			current_backtrace = null;
+			registers = null;
+
+			return stack_data;
+		}
+
+		void restore_stack (StackData stack)
+		{
+			if (inferior.CurrentFrame != stack.Address) {
+				Report.Debug (DebugFlags.SSE,
+					      "{0} discarding saved stack: stopped " +
+					      "at {1}, but recorded {2}", this,
+					      inferior.CurrentFrame, stack.Frame.TargetAddress);
+				frame_changed (inferior.CurrentFrame, null);
+				return;
+			}
+
+			current_method = stack.Method;
+			current_frame = stack.Frame;
+			current_backtrace = stack.Backtrace;
+			registers = stack.Registers;
+		}
+
+		// <summary>
+		//   Interrupt any currently running stepping operation, but don't send
+		//   any notifications to the caller.  The currently running operation is
+		//   automatically resumed when ReleaseThreadLock() is called.
+		// </summary>
+		internal override void AcquireThreadLock ()
+		{
+			if (HasThreadLock)
+				throw new InternalError ("Recursive thread lock");
+
+			Report.Debug (DebugFlags.Threads,
+				      "{0} acquiring thread lock: {1} {2}",
+				      this, engine_stopped, current_operation);
+
+			if (engine_stopped)
+				return;
+
+			Inferior.ChildEvent stop_event;
+			bool stopped = inferior.Stop (out stop_event);
+			thread_lock = new ThreadLockData (stopped, stop_event, true);
+
+			Report.Debug (DebugFlags.Threads,
+				      "{0} acquiring thread lock #1: {1} {2}",
+				      this, stopped, stop_event);
+
+			if ((stop_event != null) &&
+			    ((stop_event.Type == Inferior.ChildEventType.CHILD_EXITED) ||
+			     ((stop_event.Type == Inferior.ChildEventType.CHILD_SIGNALED))))
+				return;
+
+			TargetAddress new_rsp = inferior.PushRegisters ();
+
+			Report.Debug (DebugFlags.Threads,
+				      "{0} acquired thread lock: {1} {2} {3} {4} {5}",
+				      this, stopped, stop_event, EndStackAddress,
+				      new_rsp, inferior.CurrentFrame);
+
+			if (!EndStackAddress.IsNull)
+				inferior.WriteAddress (EndStackAddress, new_rsp);
+
+			frame_changed (inferior.CurrentFrame, null);
+			engine_stopped = true;
+		}
+
+		internal override void ReleaseThreadLock ()
+		{
+			if (thread_lock == null) {
+				Report.Debug (DebugFlags.Threads,
+					      "{0} thread lock already released!", this);
+				return;
+			}
+
+			Report.Debug (DebugFlags.Threads,
+				      "{0} releasing thread lock: {1} {2} {3}", this, thread_lock,
+				      inferior.CurrentFrame, current_operation);
+
+			thread_lock.PopRegisters (inferior);
+			if (thread_lock.StopEvent != null)
+				manager.AddPendingEvent (this, thread_lock.StopEvent);
+			if (thread_lock.Stopped)
+				engine_stopped = false;
+
+			thread_lock = null;
+		}
+
+		internal void ReleaseThreadLock (Inferior.ChildEvent cevent)
+		{
+			Report.Debug (DebugFlags.Threads,
+				      "{0} releasing thread lock #1: {1} {2} {3}",
+				      this, cevent, inferior.CurrentFrame,
+				      current_operation);
+
+			// The target stopped before we were able to send the SIGSTOP,
+			// but we haven't processed this event yet.
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
+			    (cevent.Argument == 0)) {
+				if (current_operation != null)
+					current_operation.ResumeOperation ();
+
+				return;
+			}
+
+			if (cevent.Type == Inferior.ChildEventType.CHILD_INTERRUPTED) {
+				inferior.Resume ();
+				return;
+			}
+
+			ProcessEvent (cevent);
+		}
+
+		internal override void SuspendUserThread ()
+		{
+			if (!ThreadManager.InBackgroundThread)
+				throw new InternalError ();
+			if (HasThreadLock)
+				throw new InternalError ("Recursive thread lock");
+
+			Report.Debug (DebugFlags.Threads,
+				      "{0} suspend user thread: {1} {2}",
+				      this, engine_stopped, current_operation);
+
+			if (engine_stopped)
+				return;
+
+			Inferior.ChildEvent stop_event;
+			bool stopped = inferior.Stop (out stop_event);
+
+			stop_requested = true;
+
+			if (stop_event != null) {
+				if (ProcessEvent (stop_event))
+					stop_event = null;
+			} else {
+				OperationInterrupted ();
+			}
+
+			Report.Debug (DebugFlags.Threads,
+				      "{0} suspend user thread done: {1} {2}",
+				      this, stopped, stop_event);
+
+			if (stop_event != null)
+				thread_lock = new ThreadLockData (stopped, stop_event, false);
+		}
+
+		internal override void ResumeUserThread ()
+		{
+			if (!ThreadManager.InBackgroundThread)
+				throw new InternalError ();
+
+			Report.Debug (DebugFlags.Threads,
+				      "{0} resume user thread: {1} {2} {3}", this, engine_stopped,
+				      HasThreadLock, thread.ThreadFlags);
+
+			CommandResult result = new ThreadCommandResult (thread);
+
+			if (thread_lock != null) {
+				if (thread_lock.PushedRegisters || (thread_lock.StopEvent == null))
+					throw new InternalError ();
+
+				manager.AddPendingEvent (this, thread_lock.StopEvent);
+
+				thread_lock = null;
+				engine_stopped = false;
+
+				current_operation = new OperationStep (this, StepMode.Run, result);
+				return;
+			}
+
+			if (!engine_stopped)
+				return;
+
+			StartOperation (new OperationStep (this, StepMode.Run, result));
+		}
+
+		internal bool OnModuleLoaded (Module module)
+		{
+			return ActivatePendingBreakpoints (module);
+		}
+
+		internal bool ActivatePendingBreakpoints (Module module)
+		{
+			Inferior.StackFrame iframe = inferior.GetCurrentFrame ();
+			Registers registers = inferior.GetRegisters ();
+
+			StackFrame main_frame;
+			if (process.MonoManager != null) {
+				MonoLanguageBackend mono = process.MonoLanguage;
+
+				MonoFunctionType main = mono.MainMethod;
+				if (main == null)
+					return false;
+
+				MethodSource source = main.SymbolFile.GetMethodByToken (main.Token);
+				if (source != null) {
+					SourceLocation location = new SourceLocation (source);
+
+					main_frame = new StackFrame (
+						thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
+						iframe.FrameAddress, registers, main, location);
+				} else {
+					main_frame = new StackFrame (
+						thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
+						iframe.FrameAddress, registers);
+				}
+
+				update_current_frame (main_frame);
+			} else {
+				TargetAddress main_address = Process.OperatingSystem.LookupSymbol ("main");
+				if (main_address.IsNull)
+					return false;
+
+				Method method = Lookup (main_address);
+
+				if (method == null)
+					return false;
+
+				main_frame = new StackFrame (
+					thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
+					iframe.FrameAddress, registers, method);
+				update_current_frame (main_frame);
+			}
+
+			Report.Debug (DebugFlags.SSE, "{0} activate pending breakpoints", this);
+
+			Queue pending = new Queue ();
+			foreach (Event e in process.Session.Events) {
+				Breakpoint breakpoint = e as Breakpoint;
+				if (breakpoint == null)
+					continue;
+
+				if (!e.IsEnabled || e.IsActivated)
+					continue;
+
+				if (e.IsUserModule && (module != null) && (module.ModuleGroup.Name != "user"))
+					continue;
+
+				try {
+					BreakpointHandle handle = breakpoint.Resolve (thread, main_frame);
+					if (handle == null)
+						continue;
+
+					FunctionBreakpointHandle fh = handle as FunctionBreakpointHandle;
+					if (fh == null) {
+						handle.Insert (thread);
+						continue;
+					}
+
+					pending.Enqueue (fh);
+				} catch (TargetException ex) {
+					if (ex.Type == TargetError.LocationInvalid)
+						breakpoint.OnResolveFailed ();
+					else
+						breakpoint.OnBreakpointError (
+							"Cannot insert breakpoint {0}: {1}", e.Index, ex.Message);
+				} catch (Exception ex) {
+					breakpoint.OnBreakpointError (
+						"Cannot insert breakpoint {0}: {1}", e.Index, ex.Message);
+				}
+			}
+
+			if (pending.Count == 0)
+				return false;
+
+			PushOperation (new OperationActivateBreakpoints (this, pending));
+			return true;
+		}
+
+		public override string ToString ()
+		{
+			return String.Format ("SSE ({0}:{1}:{2:x})", ID, PID, TID);
+		}
+
+#region SSE Commands
+
+		internal override ThreadCommandResult Old_Step (StepMode mode, StepFrame frame)
+		{
+			ThreadCommandResult result = new OldOperationCommandResult (thread);
+			StartOperation (new OperationStep (this, mode, frame, result));
+			return result;
+		}
+
+		public override CommandResult Step (ThreadingModel model, StepMode mode, StepFrame frame)
+		{
+			StartOperation ();
+
+			return (CommandResult) SendCommand (delegate {
+				Report.Debug (DebugFlags.SSE, "{0} step: {1} {2} {3}", this, model, mode, frame);
+				CommandResult result = process.StartOperation (model, this);
+				return ProcessOperation (new OperationStep (this, mode, frame, result));
+			});
+		}
+
+		public override void RuntimeInvoke (TargetFunctionType function,
+						    TargetStructObject object_argument,
+						    TargetObject[] param_objects,
+						    RuntimeInvokeFlags flags,
+						    RuntimeInvokeResult result)
+		{
+			StartOperation (new OperationRuntimeInvoke (
+				this, function, object_argument, param_objects,
+				flags, result));
+		}
+
+		public override CommandResult CallMethod (TargetAddress method, long arg1, long arg2,
+							  long arg3, string string_argument)
+		{
+			return StartOperation (new OperationCallMethod (
+				this, method, arg1, arg2, arg3, string_argument));
+		}
+
+		public override CommandResult CallMethod (TargetAddress method, long arg1, long arg2)
+		{
+			return StartOperation (new OperationCallMethod (this, method, arg1, arg2));
+		}
+
+		public override CommandResult CallMethod (TargetAddress method, TargetAddress method_arg,
+							  TargetObject object_arg)
+		{
+			return StartOperation (new OperationCallMethod (this, method, method_arg, object_arg));
+		}
+
+		public override CommandResult Return (ReturnMode mode)
+		{
+			return (CommandResult) SendCommand (delegate {
+				if (!engine_stopped) {
+					Report.Debug (DebugFlags.Wait,
+						      "{0} not stopped", this);
+					throw new TargetException (TargetError.NotStopped);
+				}
+
+				if (current_frame == null)
+					throw new TargetException (TargetError.NoStack);
+
+				process.UpdateSymbolTable (inferior);
+
+				if (!process.IsManagedApplication) {
+					if (mode == ReturnMode.Managed)
+						mode = ReturnMode.Native;
+					else if (mode == ReturnMode.Invocation)
+						throw new TargetException (TargetError.InvalidReturn, "Not a managed application.");
+				}
+
+				Backtrace bt = new Backtrace (current_frame);
+
+				if (mode == ReturnMode.Invocation) {
+					Inferior.CallbackFrame cframe = inferior.GetCallbackFrame (current_frame.StackPointer, false);
+					if (cframe == null)
+						throw new TargetException (TargetError.NoInvocation);
+					bt.GetBacktrace (this, inferior, Backtrace.Mode.Native, cframe.StackPointer, -1);
+					for (int i = 0; i < bt.Count; i++) {
+						if (bt.Frames [i].Type == FrameType.Normal)
+							continue;
+						else if ((bt.Frames [i].Type == FrameType.RuntimeInvoke) && (i + 1 == bt.Count))
+							break;
+						throw new TargetException (TargetError.InvalidReturn,
+									   "Cannot abort an invocation which contains non-managed frames.");
+					}
+				} else {
+					bt.GetBacktrace (this, inferior, Backtrace.Mode.Native,
+							 TargetAddress.Null, 2);
+				}
+
+				if (bt.Count < 2)
+					throw new TargetException (TargetError.NoStack);
+
+				StackFrame parent_frame = bt.Frames [1];
+				if (parent_frame == null)
+					return null;
+
+				Report.Debug (DebugFlags.SSE, "{0} return: {1} {2} {3}", this, mode, current_frame.Type,
+					      parent_frame.Type);
+
+				if (mode == ReturnMode.Native) {
+					if ((current_frame.Type == FrameType.Signal) || (parent_frame.Type == FrameType.Signal) ||
+					    (current_frame.Type == FrameType.Callback) || (parent_frame.Type == FrameType.Callback))
+						throw new TargetException (TargetError.InvalidReturn,
+									   "Cannot return from a signal handler or mdb-internal callback.");
+					if ((current_frame.Type != FrameType.Normal) || (parent_frame.Type != FrameType.Normal))
+						throw new TargetException (TargetError.InvalidReturn);
+				} else if (mode == ReturnMode.Managed) {
+					bool ok = true;
+					if (((current_frame.Type == FrameType.Normal) &&
+					     ((current_frame.Language == null) || !current_frame.Language.IsManaged)) ||
+					    ((current_frame.Type != FrameType.RuntimeInvoke) && (current_frame.Type != FrameType.Normal)))
+						ok = false;
+					if (((parent_frame.Type == FrameType.Normal) &&
+					     ((parent_frame.Language == null) || !parent_frame.Language.IsManaged)) ||
+					    ((parent_frame.Type != FrameType.RuntimeInvoke) && (parent_frame.Type != FrameType.Normal)))
+						ok = false;
+					if (!ok)
+						throw new TargetException (TargetError.InvalidReturn,
+									   "Cannot return from a non-managed frame.");
+				}
+
+				if (mode == ReturnMode.Native) {
+					inferior.SetRegisters (parent_frame.Registers);
+					frame_changed (inferior.CurrentFrame, null);
+					TargetEventArgs args = new TargetEventArgs (
+						TargetEventType.TargetStopped, 0, current_frame);
+					process.OnTargetEvent (this, args);
+					return null;
+				}
+
+				return StartOperation (new OperationReturn (this, bt, mode));
+			});
+		}
+
+		internal override void AbortInvocation (long rti_id)
+		{
+			if (!process.IsManagedApplication)
+				throw new TargetException (TargetError.InvalidReturn, "Not a managed application.");
+
+			SendCommand (delegate {
+				Report.Debug (DebugFlags.SSE, "{0} test abort: {1}", this, engine_stopped);
+
+				lock (this) {
+					if (abort_requested >= 0)
+						throw new TargetException (TargetError.InvalidReturn, "Already queued an abort.");
+
+					bool stopped = inferior.Stop ();
+					Report.Debug (DebugFlags.SSE, "{0} abort invocation: {1} {2}", this, rti_id, stopped);
+					if (stopped) {
+						abort_requested = rti_id;
+						return null;
+					}
+				}
+
+				DoAbortInvocation (rti_id);
+				return null;
+			});
+		}
+
+		void DoAbortInvocation (long rti_id)
+		{
+			Report.Debug (DebugFlags.SSE, "{0} do abort invocation: {1}", this, rti_id);
+
+			if (current_frame == null)
+				throw new TargetException (TargetError.NoStack);
+
+			process.UpdateSymbolTable (inferior);
+
+			Inferior.CallbackFrame cframe = inferior.GetCallbackFrame (current_frame.StackPointer, false);
+
+			bool found = false;
+			foreach (OperationRuntimeInvoke rti in rti_stack) {
+				if (rti.ID == rti_id) {
+					found = true;
+					break;
+				}
+			}
+
+			if (!found) {
+				throw new TargetException (TargetError.NoInvocation);
+			} else {
+				if (cframe == null)
+					throw new TargetException (TargetError.InvalidReturn, "No invocation found.");
+				else if (cframe.ID != rti_id)
+					throw new TargetException (TargetError.InvalidReturn,
+								   "Requested to abort invocation {0}, but current invocation has id {1}.",
+								   rti_id, cframe.ID);
+			}
+
+			Backtrace bt = new Backtrace (current_frame);
+
+			bt.GetBacktrace (this, inferior, Backtrace.Mode.Native, cframe.StackPointer, -1);
+			for (int i = 0; i < bt.Count; i++) {
+				if (bt.Frames [i].Type == FrameType.Normal)
+					continue;
+				else if ((bt.Frames [i].Type == FrameType.RuntimeInvoke) && (i + 1 == bt.Count))
+					break;
+				throw new TargetException (TargetError.InvalidReturn,
+							   "Cannot abort an invocation which contains non-managed frames.");
+			}
+
+			if (bt.Count < 2)
+				throw new TargetException (TargetError.NoStack);
+
+			PushOperation (new OperationReturn (this, bt, ReturnMode.Invocation));
+		}
+
+		public override Backtrace GetBacktrace (Backtrace.Mode mode, int max_frames)
+		{
+			return (Backtrace) SendCommand (delegate {
+				if (!engine_stopped) {
+					Report.Debug (DebugFlags.Wait,
+						      "{0} not stopped", this);
+					throw new TargetException (TargetError.NotStopped);
+				}
+
+				process.UpdateSymbolTable (inferior);
+
+				if (current_frame == null)
+					throw new TargetException (TargetError.NoStack);
+
+				current_backtrace = new Backtrace (current_frame);
+
+				current_backtrace.GetBacktrace (
+					this, inferior, mode, TargetAddress.Null, max_frames);
+
+				return current_backtrace;
+			});
+		}
+
+		public override Registers GetRegisters ()
+		{
+			return (Registers) SendCommand (delegate {
+				registers = inferior.GetRegisters ();
+				return registers;
+			});
+		}
+
+		public override void SetRegisters (Registers registers)
+		{
+			if (!registers.FromCurrentFrame)
+				throw new InvalidOperationException ();
+
+			this.registers = registers;
+			SendCommand (delegate {
+				inferior.SetRegisters (registers);
+				return registers;
+			});
+		}
+
+		internal override void InsertBreakpoint (BreakpointHandle handle,
+							 TargetAddress address, int domain)
+		{
+			SendCommand (delegate {
+				process.BreakpointManager.InsertBreakpoint (
+					inferior, handle, address, domain);
+				return null;
+			});
+		}
+
+		internal override void RemoveBreakpoint (BreakpointHandle handle)
+		{
+			SendCommand (delegate {
+				process.BreakpointManager.RemoveBreakpoint (inferior, handle);
+				return null;
+			});
+		}
+
+		public override int GetInstructionSize (TargetAddress address)
+		{
+			return (int) SendCommand (delegate {
+				return Architecture.Disassembler.GetInstructionSize (inferior, address);
+			});
+		}
+
+		public override AssemblerLine DisassembleInstruction (Method method, TargetAddress address)
+		{
+			return (AssemblerLine) SendCommand (delegate {
+				return Architecture.Disassembler.DisassembleInstruction (
+					inferior, method, address);
+			});
+		}
+
+		public override AssemblerMethod DisassembleMethod (Method method)
+		{
+			return (AssemblerMethod) SendCommand (delegate {
+				return Architecture.Disassembler.DisassembleMethod (inferior, method);
+			});
+		}
+
+		public override byte[] ReadBuffer (TargetAddress address, int size)
+		{
+			return (byte[]) SendCommand (delegate {
+				return inferior.ReadBuffer (address, size);
+			});
+		}
+
+		public override TargetBlob ReadMemory (TargetAddress address, int size)
+		{
+			return new TargetBlob (ReadBuffer (address, size), TargetMemoryInfo);
+		}
+
+		public override byte ReadByte (TargetAddress address)
+		{
+			return (byte) SendCommand (delegate {
+				return inferior.ReadByte (address);
+			});
+		}
+
+		public override int ReadInteger (TargetAddress address)
+		{
+			return (int) SendCommand (delegate {
+				return inferior.ReadInteger (address);
+			});
+		}
+
+		public override long ReadLongInteger (TargetAddress address)
+		{
+			return (long) SendCommand (delegate {
+				return inferior.ReadLongInteger (address);
+			});
+		}
+
+		public override TargetAddress ReadAddress (TargetAddress address)
+		{
+			return (TargetAddress) SendCommand (delegate {
+				return inferior.ReadAddress (address);
+			});
+		}
+
+		public override string ReadString (TargetAddress address)
+		{
+			return (string) SendCommand (delegate {
+				return inferior.ReadString (address);
+			});
+		}
+
+		internal override Inferior.CallbackFrame GetCallbackFrame (TargetAddress stack_pointer,
+									   bool exact_match)
+		{
+			return (Inferior.CallbackFrame) SendCommand (delegate {
+				return inferior.GetCallbackFrame (stack_pointer, exact_match);
+			});
+		}
+
+		internal override TargetFunctionType GetRuntimeInvokedFunction (long ID)
+		{
+			foreach (OperationRuntimeInvoke rti in rti_stack) {
+				if (rti.ID != ID)
+					continue;
+
+				return rti.Function;
+			}
+
+			return null;
+		}
+
+		public override void WriteBuffer (TargetAddress address, byte[] buffer)
+		{
+			SendCommand (delegate {
+				inferior.WriteBuffer (address, buffer);
+				return null;
+			});
+		}
+
+		public override void WriteByte (TargetAddress address, byte value)
+		{
+			SendCommand (delegate {
+				inferior.WriteByte (address, value);
+				return null;
+			});
+		}
+
+		public override void WriteInteger (TargetAddress address, int value)
+		{
+			SendCommand (delegate {
+				inferior.WriteInteger (address, value);
+				return null;
+			});
+		}
+
+		public override void WriteLongInteger (TargetAddress address, long value)
+		{
+			SendCommand (delegate {
+				inferior.WriteLongInteger (address, value);
+				return null;
+			});
+		}
+
+		public override void WriteAddress (TargetAddress address, TargetAddress value)
+		{
+			SendCommand (delegate {
+				inferior.WriteAddress (address, value);
+				return null;
+			});
+		}
+
+		public override bool CanWrite {
+			get { return true; }
+		}
+
+		public override string PrintObject (Style style, TargetObject obj,
+						    DisplayFormat format)
+		{
+			return (string) SendCommand (delegate {
+				return style.FormatObject (thread, obj, format);
+			});
+		}
+
+		public override string PrintType (Style style, TargetType type)
+		{
+			return (string) SendCommand (delegate {
+				return style.FormatType (thread, type);
+			});
+		}
+
+		internal override object Invoke (TargetAccessDelegate func, object data)
+		{
+			return SendCommand (delegate {
+				return func (thread, data);
+			});
+		}
+#endregion
+
+		public void ManagedCallback (ManagedCallbackFunction func, CommandResult result)
+		{
+			ManagedCallbackData data = new ManagedCallbackData (func, result);
+
+			SendCommand (delegate {
+				Report.Debug (DebugFlags.SSE, "{0} starting managed callback: {1}", this, func);
+
+				AcquireThreadLock ();
+
+				if (!do_managed_callback (data)) {
+					Report.Debug (DebugFlags.SSE, "{0} managed callback needs thread lock", this);
+
+					bool ok = false;
+					process.AcquireGlobalThreadLock (this);
+					foreach (SingleSteppingEngine engine in process.ThreadServants) {
+					try {
+						if (engine.do_managed_callback (data)) {
+							ok = true;
+							break;
+						}
+					} catch (Exception ex) {
+						Console.WriteLine ("FUCK: {0} {1}", engine, ex);
+						}
+
+					}
+
+					if (!ok) {
+						TargetAddress lmf_address = inferior.ReadAddress (LMFAddress);
+						StackFrame lmf_frame = Architecture.GetLMF (this, inferior, ref lmf_address);
+
+						Report.Debug (DebugFlags.SSE, "{0} requesting managed callback: {1}", this, lmf_frame);
+						process.MonoManager.AddManagedCallback (inferior, data);
+
+						/*
+						 * Prevent a race condition:
+						 * If we stopped just before returning from native code,
+						 * mono_thread_interruption_checkpoint_request() may not be called again
+						 * before returning back to managed code; it's called next time we're entering
+						 * native code again.
+						 *
+						 * This could lead to problems if the managed code does some CPU-intensive
+						 * before going unmanaged next time - or even loops forever.
+						 *
+						 * I have a test case where an icall contains a sleep() and the managed code
+						 * contains an infinite loop (`for (;;) ;) immediately after returning from
+						 * this icall.
+						 *
+						 * To prevent this from happening, we insert a breakpoint on the last managed
+						 * frame.
+						 */
+
+						if (lmf_frame != null)
+							insert_lmf_breakpoint (lmf_frame.TargetAddress);
+						else {
+							Report.Error ("{0} unable to compute LMF for managed callback: {1}",
+								      this, inferior.CurrentFrame);
+						}
+					}
+
+					Report.Debug (DebugFlags.SSE, "{0} managed callback releasing thread lock", this);
+					process.ReleaseGlobalThreadLock (this);
+				}
+
+				ReleaseThreadLock ();
+
+				Report.Debug (DebugFlags.SSE, "{0} managed callback done: {1} {2}", this, data.Running, data.Completed);
+				return null;
+			});
+		}
+
+		void insert_lmf_breakpoint (TargetAddress lmf_address)
+		{
+			lmf_breakpoint = new LMFBreakpointData (lmf_address);
+
+			/*
+			 * Insert a breakpoint on the last managed frame (LMF).  We use a hardware breakpoint for this
+			 * since the JIT might inspect / modify the callsite and we don't know whether we're at a safe
+			 * spot right now.
+			 *
+			 * If we already have a single-stepping breakpoint, we "steal" it here, so we only use one single
+			 * hardware register internally in the SSE.
+			 *
+			 */
+
+			if (temp_breakpoint != null) {
+				Report.Debug (DebugFlags.SSE, "{0} stealing temporary breakpoint {1} at {2} -> lmf breakpoint at {2}.",
+					      temp_breakpoint.ID, temp_breakpoint.Address, lmf_address);
+
+				lmf_breakpoint.StolenBreakpoint = temp_breakpoint;
+				temp_breakpoint = null;
+
+				/*
+				 * The breakpoint is already at the requested location -> keep and reuse it.
+				 */
+
+				if (lmf_address == temp_breakpoint.Address) {
+					lmf_breakpoint.Breakpoint = lmf_breakpoint.StolenBreakpoint;
+					return;
+				}
+
+				inferior.RemoveBreakpoint (lmf_breakpoint.StolenBreakpoint.ID);
+			}
+
+			/*
+			 * The SSE's internal hardware breakpoint register is now free.
+			 */
+
+			int dr_index;
+			int id = inferior.InsertHardwareBreakpoint (lmf_address, true, out dr_index);
+
+			Report.Debug (DebugFlags.SSE, "{0} inserted lmf breakpoint: {1} {2} {3}", this, lmf_address, id, dr_index);
+
+			lmf_breakpoint.Breakpoint = new TemporaryBreakpointData (id, lmf_address);
+		}
+
+		void remove_lmf_breakpoint ()
+		{
+			if (lmf_breakpoint == null)
+				return;
+
+			/*
+			 * We reused an already existing single-stepping breakpoint at the requested location.
+			 */
+			if (lmf_breakpoint.Breakpoint == lmf_breakpoint.StolenBreakpoint)
+				return;
+
+			inferior.RemoveBreakpoint (lmf_breakpoint.Breakpoint.ID);
+
+			/*
+			 * We stole the single-stepping breakpoint -> restore it here.
+			 */
+
+			if (lmf_breakpoint.StolenBreakpoint != null) {
+				int dr_index;
+				TargetAddress address = lmf_breakpoint.StolenBreakpoint.Address;
+				int id = inferior.InsertHardwareBreakpoint (address, true, out dr_index);
+
+				temp_breakpoint = new TemporaryBreakpointData (id, address);
+
+				Report.Debug (DebugFlags.SSE, "{0} restored stolen breakpoint: {1}", this, temp_breakpoint);
+			}
+
+			lmf_breakpoint = null;
+		}
+
+		bool do_managed_callback (ManagedCallbackData data)
+		{
+			Inferior.StackFrame sframe = inferior.GetCurrentFrame ();
+			Method method = Lookup (inferior.CurrentFrame);
+
+			Report.Debug (DebugFlags.SSE, "{0} managed callback checking frame: {1} ({2:x} - {3:x} - {4:x}) {5} {6}",
+				      this, inferior.CurrentFrame, sframe.Address, sframe.StackPointer, sframe.FrameAddress,
+				      method, method != null);
+			if ((method == null) || !method.Module.Language.IsManaged)
+				return false;
+
+			Report.Debug (DebugFlags.SSE, "{0} found managed frame: {1} {2}", this,
+				      inferior.CurrentFrame, method);
+
+			PushOperation (new OperationManagedCallback (this, data));
+			return true;
+		}
+
+		LMFBreakpointData lmf_breakpoint = null;
+
+		internal void OnManagedCallback (Queue<ManagedCallbackData> callbacks)
+		{
+			Report.Debug (DebugFlags.SSE, "{0} on managed callback", this);
+			PushOperation (new OperationManagedCallback (this, callbacks));
+		}
+
+#region IDisposable implementation
+		protected override void DoDispose ()
+		{
+			if (inferior != null) {
+				inferior.Dispose ();
+				inferior = null;
+			}
+
+			base.DoDispose ();
+		}
+#endregion
+
+		protected Method current_method;
+		protected StackFrame current_frame;
+		protected Backtrace current_backtrace;
+		protected Registers registers;
+
+		Operation current_operation;
+
+		Inferior inferior;
+		Disassembler disassembler;
+		bool engine_stopped;
+		bool reached_main;
+		bool killed, dead;
+		bool stop_requested;
+		bool attach_initialized;
+		long tid;
+		int pid;
+
+		ThreadLockData thread_lock;
+
+		long abort_requested = -1;
+
+		int stepping_over_breakpoint;
+
+		TargetEventArgs last_target_event;
+
+		TargetAddress lmf_address = TargetAddress.Null;
+		TargetAddress end_stack_address = TargetAddress.Null;
+		TargetAddress extended_notifications_addr = TargetAddress.Null;
+		TargetAddress main_retaddr = TargetAddress.Null;
+
+		Stack<InterruptibleOperation> nested_break_stack = new Stack<InterruptibleOperation> ();
+		Stack<OperationRuntimeInvoke> rti_stack = new Stack<OperationRuntimeInvoke> ();
+
+		ManualResetEvent operation_completed_event = new ManualResetEvent (false);
+
+#region Nested SSE classes
+		protected sealed class StackData : DebuggerMarshalByRefObject
+		{
+			public readonly long ID;
+			public readonly Method Method;
+			public readonly TargetAddress Address;
+			public readonly StackFrame Frame;
+			public readonly Backtrace Backtrace;
+			public readonly Registers Registers;
+
+			public StackData (long id, Method method, TargetAddress address,
+					  StackFrame frame, Backtrace backtrace,
+					  Registers registers)
+			{
+				this.ID = id;
+				this.Method = method;
+				this.Address = address;
+				this.Frame = frame;
+				this.Backtrace = backtrace;
+				this.Registers = registers;
+			}
+		}
+
+		protected sealed class TemporaryBreakpointData
+		{
+			public readonly int ID;
+			public readonly TargetAddress Address;
+
+			public TemporaryBreakpointData (int id, TargetAddress address)
+			{
+				this.ID = id;
+				this.Address = address;
+			}
+
+			public override string ToString ()
+			{
+				return String.Format ("TemporaryBreakpoint ({0}:{1})", ID, Address);
+			}
+		}
+
+		protected sealed class LMFBreakpointData
+		{
+			public readonly TargetAddress Address;
+			public TemporaryBreakpointData Breakpoint;
+			public TemporaryBreakpointData StolenBreakpoint;
+
+			public LMFBreakpointData (TargetAddress address)
+			{
+				this.Address = address;
+			}
+		}
+
+		protected sealed class ThreadLockData
+		{
+			public bool Stopped {
+				get; private set;
+			}
+
+			public Inferior.ChildEvent StopEvent {
+				get; private set;
+			}
+
+			public bool PushedRegisters {
+				get; private set;
+			}
+
+			public ThreadLockData (bool stopped, Inferior.ChildEvent stop_event, bool pushed_regs)
+			{
+				this.Stopped = stopped;
+				this.StopEvent = stop_event;
+				this.PushedRegisters = pushed_regs;
+			}
+
+			public void SetStopEvent (Inferior.ChildEvent stop_event)
+			{
+				if (StopEvent != null)
+					throw new InternalError ();
+
+				StopEvent = stop_event;
+				Stopped = true;
+			}
+
+			public void PopRegisters (Inferior inferior)
+			{
+				if (PushedRegisters)
+					inferior.PopRegisters ();
+				PushedRegisters = false;
+			}
+
+			public override string ToString ()
+			{
+				return String.Format ("ThreadLock ({0}:{1}:{2})", Stopped, StopEvent, PushedRegisters);
+			}
+		}
+#endregion
+
+#region SSE Operations
+	protected abstract class Operation {
+		public enum EventResult
+		{
+			Running,
+			Completed,
+			AskParent,
+			ResumeOperation,
+			ParentResumed,
+			SuspendOperation
+		}
+
+		public abstract bool IsSourceOperation {
+			get;
+		}
+
+		public virtual bool CheckBreakpointsOnCompletion {
+			get { return false; }
+		}
+
+		protected bool HasChild {
+			get { return child != null; }
+		}
+
+		protected readonly SingleSteppingEngine sse;
+		protected readonly Inferior inferior;
+
+		public readonly CommandResult Result;
+		public Inferior.StackFrame StartFrame;
+
+		protected int ReportBreakpointHit = -1;
+		protected bool ReportSuspend;
+
+		protected Operation (SingleSteppingEngine sse, CommandResult result)
+		{
+			this.sse = sse;
+			this.inferior = sse.inferior;
+
+			if (result != null)
+				this.Result = result;
+			else
+				this.Result = new SimpleCommandResult (this);
+		}
+
+		public virtual void Execute ()
+		{
+			StartFrame = inferior.GetCurrentFrame (true);
+			Report.Debug (DebugFlags.SSE, "{0} executing {1} at {2}",
+				      sse, this, StartFrame != null ?
+				      StartFrame.Address : TargetAddress.Null);
+			DoExecute ();
+		}
+
+		protected abstract void DoExecute ();
+
+		protected virtual void Abort ()
+		{
+			sse.Stop ();
+		}
+
+		public virtual bool ResumeOperation ()
+		{
+			return false;
+		}
+
+		Operation child;
+
+		public void PushOperation (Operation op)
+		{
+			if (child != null)
+				child.PushOperation (op);
+			else
+				child = op;
+		}
+
+		public virtual void CompletedOperation (bool suspended)
+		{
+			if (!suspended) {
+				Result.Completed ();
+				child = null;
+			}
+		}
+
+		public virtual EventResult ProcessEvent (Inferior.ChildEvent cevent,
+							 out TargetEventArgs args)
+		{
+			if (cevent.Type == Inferior.ChildEventType.CHILD_INTERRUPTED) {
+				args = null;
+				if (ResumeOperation ())
+					return EventResult.Running;
+			}
+
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) && (cevent.Argument != 0)) {
+				sse.frame_changed (inferior.CurrentFrame, null);
+				args = new TargetEventArgs (TargetEventType.TargetStopped, (int) cevent.Argument, sse.current_frame);
+				return EventResult.Completed;
+			}
+
+			EventResult result;
+			if (child != null) {
+				Report.Debug (DebugFlags.EventLoop, "{0} child event: {1} {2}", sse, this, cevent);
+
+				result = child.ProcessEvent (cevent, out args);
+
+				Report.Debug (DebugFlags.EventLoop, "{0} child event done: {1} {2} {3} {4}", sse, this, cevent, result, args);
+
+				if (result == EventResult.ParentResumed) {
+					child = null;
+					return EventResult.Running;
+				}
+
+				if ((result != EventResult.AskParent) &&
+				    (result != EventResult.ResumeOperation))
+					return result;
+
+				Operation old_child = child;
+				child = null;
+
+				if ((result == EventResult.ResumeOperation) && ResumeOperation ()) {
+					args = null;
+					return EventResult.Running;
+				}
+
+				Report.Debug (DebugFlags.EventLoop,
+					      "{0} resending event {1} from {2} to {3}",
+					      sse, cevent, old_child, this);
+			}
+
+			result = DoProcessEvent (cevent, out args);
+
+			return result;
+		}
+
+		public virtual EventResult CompletedOperation (Inferior.ChildEvent cevent, EventResult result, ref TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.EventLoop, "{0} operation completed: {1} {2} {3} - {4} {5}",
+				      sse, this, cevent, result, ReportBreakpointHit, ReportSuspend);
+
+			child = null;
+
+			if (ReportSuspend) {
+				result = EventResult.SuspendOperation;
+				ReportSuspend = false;
+			}
+
+			if (result == EventResult.SuspendOperation) {
+				if (!(this is InterruptibleOperation) || !sse.process.Session.Config.NestedBreakStates)
+					result = EventResult.Completed;
+			}
+
+			if (args != null)
+				return result;
+
+			//
+			// We're done with our stepping operation, but first we need to
+			// compute the new StackFrame.  While doing this, `frame_changed'
+			// may discover that we need to do another stepping operation
+			// before telling the user that we're finished.  This is to avoid
+			// that we stop in things like a method's prologue or epilogue
+			// code.  If that happens, we just continue stepping until we reach
+			// the first actual source line in the method.
+			//
+			Operation new_operation = sse.frame_changed (inferior.CurrentFrame, this);
+
+			if ((ReportBreakpointHit < 0) &&
+			    (CheckBreakpointsOnCompletion || (result == EventResult.SuspendOperation))) {
+				int index;
+				bool is_enabled;
+				sse.process.BreakpointManager.LookupBreakpoint (
+					inferior.CurrentFrame, out index, out is_enabled);
+
+				if ((index != 0) && is_enabled)
+					ReportBreakpointHit = index;
+			}
+
+			if (new_operation != null) {
+				Report.Debug (DebugFlags.SSE,
+					      "{0} frame changed at {1} => new operation {2}",
+					      this, inferior.CurrentFrame, new_operation);
+
+				if (cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT)
+					ReportBreakpointHit = (int) cevent.Argument;
+				if (result == EventResult.SuspendOperation)
+					ReportSuspend = true;
+
+				sse.PushOperation (new_operation);
+
+				args = null;
+				return EventResult.Running;
+			}
+
+			//
+			// Now we're really finished.
+			//
+			int bpt_hit = ReportBreakpointHit;
+			ReportBreakpointHit = -1;
+
+			if (cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT)
+				bpt_hit = (int) cevent.Argument;
+
+			if (bpt_hit >= 0) {
+				Breakpoint bpt = sse.lookup_breakpoint (bpt_hit);
+				if ((bpt != null) && bpt.Breaks (sse.Thread.ID) && !bpt.HideFromUser) {
+					args = new TargetEventArgs (
+						TargetEventType.TargetHitBreakpoint, bpt.Index,
+						sse.current_frame);
+					return result;
+				}
+			}
+
+			args = OperationCompleted (sse.current_frame, result == EventResult.SuspendOperation);
+			return result;
+		}
+
+		public virtual TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
+		{
+			return null;
+		}
+
+		protected abstract EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args);
+
+		public virtual bool HandleException (TargetAddress stack, TargetAddress exc)
+		{
+			return true;
+		}
+
+		protected virtual string MyToString ()
+		{
+			return "";
+		}
+
+		public override string ToString ()
+		{
+			if (child == null)
+				return String.Format ("{0} ({1})", GetType ().Name, MyToString ());
+			else
+				return String.Format ("{0}:{1}", GetType ().Name, child);
+		}
+
+		protected class SimpleCommandResult : CommandResult
+		{
+			Operation operation;
+			ManualResetEvent completed_event = new ManualResetEvent (false);
+
+			internal SimpleCommandResult (Operation operation)
+			{
+				this.operation = operation;
+			}
+
+			public override WaitHandle CompletedEvent {
+				get { return completed_event; }
+			}
+
+			public override void Abort ()
+			{
+				operation.Abort ();
+			}
+
+			internal override void Completed ()
+			{
+				completed_event.Set ();
+			}
+		}
+	}
+
+	protected class OperationStart : Operation
+	{
+		public OperationStart (SingleSteppingEngine sse, CommandResult result)
+			: base (sse, result)
+		{ }
+
+		public override bool IsSourceOperation {
+			get { return true; }
+		}
+
+		protected override void DoExecute ()
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} execute start: {1} {2} {3}", sse, sse.ProcessServant.IsAttached,
+				      inferior.CurrentFrame, inferior.EntryPoint);
+
+			if (!sse.ProcessServant.IsAttached)
+				sse.do_continue (inferior.EntryPoint);
+			else
+				sse.ProcessEvent (new Inferior.ChildEvent (Inferior.ChildEventType.CHILD_STOPPED, 0, 0, 0));
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} start: {1} {2} {3} {4}", sse,
+				      cevent, sse.ProcessServant.IsAttached,
+				      inferior.CurrentFrame, inferior.EntryPoint);
+
+			args = null;
+			if ((cevent.Type != Inferior.ChildEventType.CHILD_STOPPED) &&
+			    (cevent.Type != Inferior.ChildEventType.CHILD_CALLBACK))
+				return EventResult.Completed;
+
+			if (sse.Architecture.IsSyscallInstruction (inferior, inferior.CurrentFrame)) {
+				Report.Debug (DebugFlags.SSE,
+					      "{0} start stopped on syscall instruction {1}",
+					      sse, inferior.CurrentFrame);
+				inferior.Step ();
+				return EventResult.Running;
+			}
+
+			sse.ProcessServant.OperatingSystem.UpdateSharedLibraries (inferior);
+			sse.ProcessServant.InitializeThreads (inferior, !sse.ProcessServant.IsAttached);
+
+			if (sse.ProcessServant.IsAttached)
+				return EventResult.Completed;
+
+			if (!sse.ProcessServant.IsManaged) {
+				if (sse.OnModuleLoaded (null))
+					return EventResult.Running;
+			}
+
+			Report.Debug (DebugFlags.SSE, "{0} start #1: {1}", sse, cevent);
+			sse.PushOperation (new OperationStep (sse, StepMode.Run, Result));
+			return EventResult.Running;
+		}
+
+		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
+		{
+			return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
+		}
+
+		public override bool HandleException (TargetAddress stack, TargetAddress exc)
+		{
+			return sse.reached_main ? false : true;
+		}
+	}
+
+	protected class OperationActivateBreakpoints : Operation
+	{
+		public OperationActivateBreakpoints (SingleSteppingEngine sse, Queue pending)
+			: base (sse, null)
+		{
+			this.pending_events = pending;
+		}
+
+		protected override void DoExecute ()
+		{
+			do_execute ();
+		}
+
+		public override bool IsSourceOperation {
+			get { return false; }
+		}
+
+		Queue pending_events;
+		bool completed;
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			args = null;
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} activate breakpoints: {1}", sse, completed);
+
+			while (!completed) {
+				if (do_execute ())
+					return EventResult.Running;
+
+				Report.Debug (DebugFlags.SSE,
+					      "{0} activate breakpoints done - continue", sse);
+
+				return EventResult.ResumeOperation;
+			}
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} activate breakpoints completed", sse);
+			return EventResult.AskParent;
+		}
+
+		bool do_execute ()
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} activate breakpoints execute: {1} {2}", sse,
+				      inferior.CurrentFrame, pending_events.Count);
+
+			if (pending_events.Count == 0) {
+				completed = true;
+				return false;
+			}
+
+			FunctionBreakpointHandle handle =
+				(FunctionBreakpointHandle) pending_events.Dequeue ();
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} activate breakpoints: {1}", sse, handle);
+
+			sse.PushOperation (new OperationInsertBreakpoint (sse, handle));
+			return true;
+		}
+	}
+
+	protected class OperationInsertBreakpoint : OperationCallback
+	{
+		public readonly FunctionBreakpointHandle Handle;
+		public readonly int Index;
+
+		public OperationInsertBreakpoint (SingleSteppingEngine sse,
+						  FunctionBreakpointHandle handle)
+			: base (sse, null)
+		{
+			this.Handle = handle;
+			this.Index = MonoLanguageBackend.GetUniqueID ();
+		}
+
+		protected override void DoExecute ()
+		{
+			MonoDebuggerInfo info = sse.ProcessServant.MonoManager.MonoDebuggerInfo;
+
+			MonoFunctionType func = (MonoFunctionType) Handle.Function;
+			TargetAddress image = func.SymbolFile.MonoImage;
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} insert breakpoint: {1} {2} {3:x}",
+				      sse, func, Index, func.Token);
+
+			inferior.CallMethod (
+				info.InsertSourceBreakpoint, image.Address,
+				func.Token, Index, func.DeclaringType.BaseName, ID);
+		}
+
+		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
+		{
+			TargetAddress info = new TargetAddress (inferior.AddressDomain, data1);
+
+			Report.Debug (DebugFlags.SSE, "{0} insert breakpoint done: {1}", sse, info);
+
+			sse.Process.MonoLanguage.RegisterMethodLoadHandler (inferior, info, Index, Handle.MethodLoaded);
+
+			Handle.Breakpoint.OnBreakpointBound ();
+			args = null;
+			return EventResult.AskParent;
+		}
+	}
+
+	protected class OperationInitAfterFork : Operation
+	{
+		public OperationInitAfterFork (SingleSteppingEngine sse)
+			: base (sse, null)
+		{ }
+
+		public override bool IsSourceOperation {
+			get { return false; }
+		}
+
+		protected override void DoExecute ()
+		{
+			sse.do_continue ();
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} init after fork ({1})", sse,
+				      DebuggerWaitHandle.CurrentThread);
+
+			sse.ProcessServant.BreakpointManager.InitializeAfterFork (inferior);
+
+			args = null;
+			return EventResult.AskParent;
+		}
+	}
+
+	protected class OperationInitCodeBuffer : OperationCallback
+	{
+		public OperationInitCodeBuffer (SingleSteppingEngine sse)
+			: base (sse, null)
+		{ }
+
+		public override bool IsSourceOperation {
+			get { return false; }
+		}
+
+		protected override void DoExecute ()
+		{
+			MonoDebuggerInfo info = sse.ProcessServant.MonoManager.MonoDebuggerInfo;
+			inferior.CallMethod (info.InitCodeBuffer, 0, 0, ID);
+		}
+
+		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} init code buffer: {1:x} {2:x} {3}",
+				      sse, data1, data2, Result);
+
+			TargetAddress buffer = new TargetAddress (inferior.AddressDomain, data1);
+			sse.process.MonoManager.InitCodeBuffer (inferior, buffer);
+
+			RestoreStack ();
+			args = null;
+			return EventResult.AskParent;
+		}
+	}
+
+	protected class OperationStepOverBreakpoint : Operation
+	{
+		TargetAddress until;
+		public readonly int Index;
+		bool has_thread_lock;
+
+		public OperationStepOverBreakpoint (SingleSteppingEngine sse, int index,
+						    TargetAddress until)
+			: base (sse, null)
+		{
+			this.Index = index;
+			this.until = until;
+		}
+
+		public override bool IsSourceOperation {
+			get { return false; }
+		}
+
+		protected override void DoExecute ()
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} stepping over breakpoint: {1}", sse, until);
+
+			sse.process.AcquireGlobalThreadLock (sse);
+			inferior.DisableBreakpoint (Index);
+
+			has_thread_lock = true;
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} stepping over breakpoint {1} at {2} until {3} ({4})",
+				      sse, Index, inferior.CurrentFrame, until, sse.current_method);
+
+			inferior.Step ();
+		}
+
+		bool ReleaseThreadLock (Inferior.ChildEvent cevent)
+		{
+			if (!has_thread_lock)
+				return true;
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} releasing thread lock at {1}",
+				      sse, inferior.CurrentFrame);
+
+			inferior.EnableBreakpoint (Index);
+			sse.process.ReleaseGlobalThreadLock (sse);
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} done releasing thread lock at {1} - {2}",
+				      sse, inferior.CurrentFrame, sse.HasThreadLock);
+
+			has_thread_lock = false;
+
+			if (sse.thread_lock == null)
+				return true;
+
+			sse.thread_lock.SetStopEvent (cevent);
+			return false;
+		}
+
+		public override EventResult ProcessEvent (Inferior.ChildEvent cevent,
+							  out TargetEventArgs args)
+		{
+			if (((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
+			     (cevent.Argument == 0)) ||
+			    ((cevent.Type != Inferior.ChildEventType.CHILD_CALLBACK) &&
+			     (cevent.Type != Inferior.ChildEventType.RUNTIME_INVOKE_DONE))) {
+				if (!ReleaseThreadLock (cevent)) {
+					args = null;
+					return EventResult.Running;
+				}
+			}
+			return base.ProcessEvent (cevent, out args);
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} stepped over breakpoint {1} at {2}: {3} {4}",
+				      sse, Index, inferior.CurrentFrame, cevent, until);
+
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) &&
+			    (cevent.Argument != Index)) {
+				args = null;
+				return EventResult.Completed;
+			}
+
+			if (!until.IsNull) {
+				sse.do_continue (until);
+
+				args = null;
+				until = TargetAddress.Null;
+				return EventResult.Running;
+			}
+
+			args = null;
+			return EventResult.ResumeOperation;
+		}
+	}
+
+	protected class OperationExecuteInstruction : Operation
+	{
+		public readonly byte[] Instruction;
+		public readonly bool UpdateIP;
+
+		bool pushed_code_buffer;
+
+		public OperationExecuteInstruction (SingleSteppingEngine sse, byte[] insn,
+						    bool update_ip)
+			: base (sse, null)
+		{
+			this.Instruction = insn;
+			this.UpdateIP = update_ip;
+		}
+
+		public override bool IsSourceOperation {
+			get { return false; }
+		}
+
+		protected override void DoExecute ()
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} executing instruction: {1}", sse,
+				      TargetBinaryReader.HexDump (Instruction));
+
+			if (!sse.ProcessServant.MonoManager.HasCodeBuffer) {
+				sse.PushOperation (new OperationInitCodeBuffer (sse));
+				pushed_code_buffer = true;
+				return;
+			}
+
+			inferior.ExecuteInstruction (Instruction, UpdateIP);
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} executed instruction at {1}: {2}\n{3}",
+				      sse, inferior.CurrentFrame, cevent,
+				      TargetBinaryReader.HexDump (Instruction));
+
+			args = null;
+			if (pushed_code_buffer) {
+				pushed_code_buffer = false;
+				inferior.ExecuteInstruction (Instruction, UpdateIP);
+				return EventResult.Running;
+			}
+
+			return EventResult.ResumeOperation;
+		}
+	}
+
+	protected abstract class OperationStepBase : Operation
+	{
+		public override bool CheckBreakpointsOnCompletion {
+			get { return true; }
+		}
+
+		protected OperationStepBase (SingleSteppingEngine sse, CommandResult result)
+			: base (sse, result)
+		{ }
+
+		public override void Execute ()
+		{
+			Report.Debug (DebugFlags.SSE, "{0} start stepping operation: {1}", sse, this);
+			base.Execute ();
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			args = null;
+			bool completed;
+			if (cevent.Type == Inferior.ChildEventType.CHILD_INTERRUPTED)
+				completed = !ResumeOperation ();
+			else
+				completed = DoProcessEvent ();
+
+			return completed ? EventResult.Completed : EventResult.Running;
+		}
+
+		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
+		{
+			return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
+		}
+
+		protected abstract bool DoProcessEvent ();
+
+		protected abstract bool TrampolineHandler (Method method);
+	}
+
+	protected class OperationStep : OperationStepBase
+	{
+		public readonly StepMode StepMode;
+		public StepFrame StepFrame {
+			get; private set;
+		}
+
+		public OperationStep (SingleSteppingEngine sse, StepMode mode, CommandResult result)
+			: base (sse, result)
+		{
+			this.StepMode = mode;
+		}
+
+		public OperationStep (SingleSteppingEngine sse, StepFrame frame, CommandResult result)
+			: base (sse, result)
+		{
+			this.StepFrame = frame;
+			this.StepMode = frame.Mode;
+		}
+
+		public OperationStep (SingleSteppingEngine sse, StepMode mode, StepFrame frame, CommandResult result)
+			: base (sse, result)
+		{
+			this.StepFrame = frame;
+			this.StepMode = mode;
+		}
+
+		public override bool IsSourceOperation {
+			get {
+				return (StepMode == StepMode.SourceLine) ||
+					(StepMode == StepMode.NextLine) ||
+					(StepMode == StepMode.Finish) ||
+					(StepMode == StepMode.Run);
+			}
+		}
+
+		protected override void DoExecute ()
+		{
+			Report.Debug (DebugFlags.SSE, "{0} step execute: {1}", sse, inferior.CurrentFrame);
+
+			switch (StepMode) {
+			case StepMode.Run:
+				if (StepFrame != null)
+					sse.do_continue (StepFrame.Until);
+				else
+					sse.do_continue ();
+				break;
+
+			case StepMode.NativeInstruction:
+				sse.do_step_native ();
+				break;
+
+			case StepMode.NextInstruction:
+				sse.do_next ();
+				break;
+
+			case StepMode.SourceLine:
+				if (StepFrame == null)
+					StepFrame = sse.CreateStepFrame ();
+				if (StepFrame == null)
+					sse.do_step ();
+				else
+					Step (true);
+				break;
+
+			case StepMode.NextLine:
+				// We cannot just set a breakpoint on the next line
+				// since we do not know which way the program's
+				// control flow will go; ie. there may be a jump
+				// instruction before reaching the next line.
+				StepFrame frame = sse.CreateStepFrame ();
+				if (frame == null)
+					sse.do_next ();
+				else {
+					StepFrame = new StepFrame (
+						null, StepMode.Finish, frame.StackFrame,
+						frame.Start, frame.End);
+					Step (true);
+				}
+				break;
+
+			case StepMode.SingleInstruction:
+				StepFrame = sse.CreateStepFrame (StepMode.SingleInstruction);
+				Step (true);
+				break;
+
+			case StepMode.Finish:
+			case StepMode.FinishNative:
+				Step (true);
+				break;
+
+			default:
+				throw new InvalidOperationException ();
+			}
+		}
+
+		public override bool ResumeOperation ()
+		{
+			Report.Debug (DebugFlags.SSE, "{0} resuming operation {1}", sse, this);
+
+			if (sse.temp_breakpoint != null) {
+				sse.do_continue ();
+				return true;
+			}
+
+			return !Step (false);
+		}
+
+		public override bool HandleException (TargetAddress stack, TargetAddress exc)
+		{
+			if (StepMode == StepMode.Run)
+				return false;
+			if ((StepMode != StepMode.SourceLine) && (StepMode != StepMode.NextLine) &&
+			    (StepMode != StepMode.StepFrame))
+				return true;
+
+			/*
+			 * If we don't have a StepFrame or if the StepFrame doesn't have a
+			 * SimpleStackFrame, we're doing something like instruction stepping -
+			 * always stop in this case.
+			 */
+			if ((StepFrame == null) || (StepFrame.StackFrame == null))
+				return true;
+
+			StackFrame oframe = StepFrame.StackFrame;
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} handling exception: {1} {2} - {3} {4} - {5}", sse,
+				      StepFrame, oframe, stack, oframe.StackPointer,
+				      stack < oframe.StackPointer);
+
+			if (stack < oframe.StackPointer)
+				return false;
+
+			return true;
+		}
+
+		protected override bool TrampolineHandler (Method method)
+		{
+			if (StepMode == StepMode.SingleInstruction)
+				return true;
+
+			if (method == null)
+				return false;
+
+			if (method.IsInvokeWrapper)
+				return true;
+			else if (method.WrapperType == WrapperType.Alloc)
+				return false;
+
+			if (StepMode == StepMode.SourceLine)
+				return sse.MethodHasSource (method);
+
+			return true;
+		}
+
+		bool check_method_operation (TargetAddress current_frame)
+		{
+			if ((StepMode != StepMode.SourceLine) && (StepMode != StepMode.NextLine))
+				return false;
+
+			Method method = sse.Lookup (current_frame);
+			if (method == null)
+				return false;
+
+			LineNumberTable lnt = method.LineNumberTable;
+			if (lnt.HasMethodBounds && (current_frame >= lnt.MethodEndAddress)) {
+				Report.Debug (DebugFlags.SSE, "{0} reached method epilogue: {1} {2} {3}",
+					      sse, current_frame, lnt.MethodEndAddress, method.EndAddress);
+				StepFrame = new StepFrame (
+					null, StepMode.Finish, null,
+					lnt.MethodEndAddress, method.EndAddress);
+				return true;
+			}
+
+			return false;
+		}
+
+		protected bool Step (bool first)
+		{
+			TargetAddress current_frame = inferior.CurrentFrame;
+
+			if (StepMode == StepMode.Run) {
+				TargetAddress until = StepFrame != null ? StepFrame.Until : TargetAddress.Null;
+				if (!until.IsNull && (current_frame == until))
+					return true;
+				sse.do_continue ();
+				return false;
+			}
+
+			if (StepMode == StepMode.FinishNative) {
+				Inferior.StackFrame frame = inferior.GetCurrentFrame ();
+				TargetAddress stack = frame.StackPointer;
+
+				Report.Debug (DebugFlags.SSE,
+					      "{0} finish native: stack = {1}, " +
+					      "until = {2}", sse, stack, StepFrame.Until);
+
+				if (stack <= StepFrame.Until) {
+					sse.do_next ();
+					return false;
+				}
+			}
+
+		again:
+			bool in_frame = sse.is_in_step_frame (StepFrame, current_frame);
+			Report.Debug (DebugFlags.SSE, "{0} stepping at {1} in {2} ({3}in frame)",
+				      sse, current_frame, StepFrame, !in_frame ? "not " : "");
+
+			if (!first && !in_frame) {
+				if (!check_method_operation (current_frame))
+					return true;
+
+				in_frame = sse.is_in_step_frame (StepFrame, current_frame);
+				goto again;
+			}
+
+			/*
+			 * When StepMode.SingleInstruction was requested, enter the method
+			 * no matter whether it's a system function or not.
+			 */
+			if (StepMode == StepMode.SingleInstruction) {
+				sse.do_step_native ();
+				return false;
+			}
+
+			/*
+			 * If this is not a call instruction, continue stepping until we leave
+			 * the specified step frame.
+			 */
+			Instruction instruction = inferior.Architecture.ReadInstruction (
+				inferior, current_frame);
+			if ((instruction == null) || !instruction.IsCall) {
+				sse.do_step ();
+				return false;
+			}
+
+			if (!instruction.HasInstructionSize) {
+				/* Ooops, we don't know anything about this instruction */
+				sse.do_step ();
+				return false;
+			}
+
+			TargetAddress call_target = instruction.GetEffectiveAddress (inferior);
+
+			if ((sse.current_method != null) && (sse.current_method.HasMethodBounds) &&
+			    !call_target.IsNull &&
+			    (call_target >= sse.current_method.MethodStartAddress) &&
+			    (call_target < sse.current_method.MethodEndAddress)) {
+				/* Intra-method call (we stay outside the prologue/epilogue code,
+				 * so this also can't be a recursive call). */
+				sse.do_step ();
+				return false;
+			}
+
+			/*
+			 * In StepMode.Finish, always step over all methods.
+			 */
+			if ((StepMode == StepMode.Finish) || (StepMode == StepMode.NextLine)) {
+				sse.do_next ();
+				return false;
+			}
+
+			if (sse.CheckTrampoline (instruction, TrampolineHandler))
+				return false;
+
+			/*
+			 * Try to find out whether this is a system function by doing a symbol lookup.
+			 * If it can't be found in the symbol tables, assume it's a system function
+			 * and step over it.
+			 */
+			Method method = sse.Lookup (call_target);
+
+			/*
+			 * If this is a PInvoke/icall/remoting wrapper, check whether we want
+			 * to step into the wrapped function.
+			 */
+			if ((method != null) && (method.WrapperType != WrapperType.None)) {
+				if (method.IsInvokeWrapper) {
+					sse.do_step ();
+					return false;
+				}
+			}
+
+			if (!sse.MethodHasSource (method)) {
+				sse.do_next ();
+				return false;
+			}
+
+			/*
+			 * Finally, step into the method.
+			 */
+			sse.do_step ();
+			return false;
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.EventLoop, "{0} received {1} at {2} in {3}",
+				      sse, cevent, inferior.CurrentFrame, this);
+
+			if ((StepMode == StepMode.Run) &&
+			    ((cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) ||
+			     (cevent.Type == Inferior.ChildEventType.CHILD_CALLBACK) ||
+			     (cevent.Type == Inferior.ChildEventType.RUNTIME_INVOKE_DONE))) {
+				args = null;
+				return EventResult.Completed;
+			}
+
+			return base.DoProcessEvent (cevent, out args);
+		}
+
+		protected override bool DoProcessEvent ()
+		{
+			Report.Debug (DebugFlags.SSE, "{0} processing {1} event.",
+				      sse, this);
+			return Step (false);
+		}
+
+		protected override string MyToString ()
+		{
+			return String.Format ("{0}:{1}", StepMode, StepFrame);
+		}
+	}
+
+	protected abstract class OperationCallback : Operation
+	{
+		public readonly long ID = ++next_id;
+		StackData stack_data;
+
+		static int next_id = 0;
+
+		protected OperationCallback (SingleSteppingEngine sse)
+			: base (sse, null)
+		{ }
+
+		protected OperationCallback (SingleSteppingEngine sse, CommandResult result)
+			: base (sse, result)
+		{ }
+
+		public override void Execute ()
+		{
+			stack_data = sse.save_stack (ID);
+			try {
+				base.Execute ();
+			} catch {
+				RestoreStack ();
+				throw;
+			}
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.EventLoop,
+				      "{0} received event {1} at {2} while waiting for " +
+				      "callback {4}:{3}", sse, cevent, inferior.CurrentFrame,
+				      ID, this);
+
+			args = null;
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
+			    (cevent.Argument == 0)) {
+				sse.do_continue ();
+				return EventResult.Running;
+			} else if ((cevent.Type != Inferior.ChildEventType.CHILD_CALLBACK) &&
+				   (cevent.Type != Inferior.ChildEventType.RUNTIME_INVOKE_DONE)) {
+				Report.Debug (DebugFlags.SSE,
+					      "{0} aborting callback {1} ({2}) at {3}: {4}",
+					      sse, this, ID, inferior.CurrentFrame, cevent);
+				AbortOperation ();
+				return EventResult.Completed;
+			}
+
+			if (ID != cevent.Argument) {
+				Report.Debug (DebugFlags.SSE,
+					      "{0} aborting callback {1} ({2}) at {3}: {4}",
+					      sse, this, ID, inferior.CurrentFrame, cevent);
+				AbortOperation ();
+				return EventResult.Completed;
+			}
+
+			try {
+				return CallbackCompleted (cevent.Data1, cevent.Data2, out args);
+			} catch (Exception ex) {
+				Report.Debug (DebugFlags.SSE, "{0} got exception while handling event {1}: {2}",
+					      sse, cevent, ex);
+				RestoreStack ();
+				return EventResult.Completed;
+			}
+		}
+
+		protected abstract EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args);
+
+		public override bool IsSourceOperation {
+			get { return false; }
+		}
+
+		protected void AbortOperation ()
+		{
+			stack_data = null;
+		}
+
+		protected void RestoreStack ()
+		{
+			if (stack_data != null)
+				sse.restore_stack (stack_data);
+			stack_data = null;
+		}
+
+		protected void DiscardStack ()
+		{
+			stack_data = null;
+		}
+	}
+
+	protected class OperationManagedCallback : Operation
+	{
+		ThreadLockData thread_lock;
+		Inferior.ChildEvent stop_event;
+
+		public Queue<ManagedCallbackData> CallbackFunctions {
+			get; private set;
+		}
+
+		public OperationManagedCallback (SingleSteppingEngine sse, ManagedCallbackData data)
+			: base (sse, null)
+		{
+			CallbackFunctions = new Queue<ManagedCallbackData> ();
+			CallbackFunctions.Enqueue (data);
+		}
+
+		public OperationManagedCallback (SingleSteppingEngine sse, Queue<ManagedCallbackData> list)
+			: base (sse, null)
+		{
+			this.CallbackFunctions = list;
+		}
+
+		public override bool IsSourceOperation {
+			get { return false; }
+		}
+
+		ManagedCallbackData current_callback;
+
+		protected override void DoExecute ()
+		{
+			Report.Debug (DebugFlags.SSE, "{0} managed callback execute: {1}",
+				      sse, sse.thread_lock);
+
+			if (sse.HasThreadLock) {
+				this.thread_lock = sse.thread_lock;
+				sse.thread_lock = null;
+
+				this.thread_lock.PopRegisters (inferior);
+			}
+
+			if (!do_execute ()) {
+				byte[] nop_insn = sse.Architecture.Opcodes.GenerateNopInstruction ();
+				sse.PushOperation (new OperationExecuteInstruction (sse, nop_insn, false));
+			}
+
+			Report.Debug (DebugFlags.SSE, "{0} managed callback execute done", sse);
+		}
+
+		bool do_execute ()
+		{
+			Report.Debug (DebugFlags.SSE, "{0} managed callback execute start: {1}", sse, CallbackFunctions.Count);
+
+			while (CallbackFunctions.Count > 0) {
+				current_callback = CallbackFunctions.Dequeue ();
+				Report.Debug (DebugFlags.SSE, "{0} managed callback execute: {1}",
+					      sse, current_callback.Func);
+				current_callback.Running = true;
+				bool running = current_callback.Func (sse);
+				Report.Debug (DebugFlags.SSE, "{0} managed callback execute done: {1} {2}",
+					      sse, current_callback.Func, running);
+				if (running)
+					return true;
+
+				current_callback.Completed = true;
+
+				current_callback.Result.Completed ();
+			}
+
+			return false;
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.SSE, "{0} managed callback process event: {1} {2} {3}",
+				      sse, cevent, thread_lock, current_callback);
+
+			current_callback.Result.Completed ();
+
+			args = null;
+			if (do_execute ())
+				return EventResult.Running;
+
+			if ((thread_lock != null) && (thread_lock.StopEvent != null)) {
+				sse.ThreadManager.AddPendingEvent (sse, thread_lock.StopEvent);
+				return EventResult.ParentResumed;
+			}
+
+			args = null;
+			return EventResult.ResumeOperation;
+		}
+
+		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
+		{
+			return null;
+		}
+	}
+
+	protected class OperationRuntimeInvoke : InterruptibleOperation
+	{
+		new public readonly RuntimeInvokeResult Result;
+		public readonly MonoFunctionType Function;
+		public readonly TargetStructObject Instance;
+		public readonly TargetObject[] ParamObjects;
+		public readonly RuntimeInvokeFlags Flags;
+
+		bool stopped_somewhere;
+		OperationRuntimeInvokeHelper helper;
+
+		public override bool IsSourceOperation {
+			get { return true; }
+		}
+
+		public bool Debug {
+			get { return (Flags & RuntimeInvokeFlags.BreakOnEntry) != 0; }
+		}
+
+		public bool NestedBreakStates {
+			get {
+				if (!sse.Process.Session.Config.NestedBreakStates)
+					return false;
+
+				return (Flags & RuntimeInvokeFlags.NestedBreakStates) != 0;
+			}
+		}
+
+		protected bool IsVirtual {
+			get { return (Flags & RuntimeInvokeFlags.VirtualMethod) != 0; }
+		}
+
+		public long ID {
+			get { return helper.ID; }
+		}
+
+		public OperationRuntimeInvoke (SingleSteppingEngine sse,
+					       TargetFunctionType function,
+					       TargetStructObject instance,
+					       TargetObject[] param_objects,
+					       RuntimeInvokeFlags flags,
+					       RuntimeInvokeResult result)
+			: base (sse, result)
+		{
+			this.Result = result;
+			this.Function = (MonoFunctionType) function;
+			this.Instance = instance;
+			this.ParamObjects = param_objects;
+			this.Flags = flags;
+		}
+
+		protected override void DoExecute ()
+		{
+			Report.Debug (DebugFlags.SSE, "{0} rti execute", sse);
+			if (helper != null)
+				throw new InternalError ("{0} rti already has a helper operation", sse);
+			helper = new OperationRuntimeInvokeHelper (sse, this);
+			Result.ID = helper.ID;
+			sse.PushOperation (helper);
+		}
+
+		public override bool ResumeOperation ()
+		{
+			Report.Debug (DebugFlags.SSE, "{0} rti resuming operation {1}", sse, this);
+
+			sse.do_continue ();
+			return true;
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} stopped at {1} during outer runtime-invoke: {2}",
+				      sse, inferior.CurrentFrame, cevent);
+
+			args = null;
+
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
+			    (cevent.Argument == 0)) {
+				if (Debug && (inferior.CurrentFrame == helper.InvokeMethod)) {
+					if (NestedBreakStates)
+						return EventResult.SuspendOperation;
+					else
+						return EventResult.Completed;
+				}
+
+				goto resume_target;
+			} else if (cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) {
+				if (NestedBreakStates)
+					return EventResult.SuspendOperation;
+				if (Debug)
+					return EventResult.Completed;
+
+				goto resume_target;
+			}
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} stopped abnormally at {1} during outer runtime-invoke: {2}",
+				      sse, inferior.CurrentFrame, cevent);
+			return EventResult.Completed;
+
+		resume_target:
+			Report.Debug (DebugFlags.SSE,
+				      "{0} resuming target during runtime-invoke", sse);
+
+			sse.do_continue ();
+			return EventResult.Running;
+		}
+
+		public override bool HandleException (TargetAddress stack, TargetAddress exc)
+		{
+			return false;
+		}
+
+		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
+		{
+			Completed (data1, data2);
+
+			args = null;
+			return EventResult.Completed;
+		}
+
+		public void Completed (long data1, long data2)
+		{
+			Report.Debug (DebugFlags.SSE, "{0} completed runtime-invoke: {1:x} {2:x}", sse, data1, data2);
+
+			MonoLanguageBackend language = sse.process.MonoLanguage;
+
+			if (data2 != 0) {
+				TargetAddress exc_address = new TargetAddress (inferior.AddressDomain, data2);
+				TargetFundamentalObject exc_obj = (TargetFundamentalObject) language.CreateObject (inferior, exc_address);
+
+				Result.ExceptionMessage = (string) exc_obj.GetObject (inferior);
+			}
+
+			if (data1 != 0) {
+				TargetAddress retval_address = new TargetAddress (inferior.AddressDomain, data1);
+				Result.ReturnObject = language.CreateObject (inferior, retval_address);
+
+				Report.Debug (DebugFlags.SSE, "{0} rti done: {1} {2}", sse, retval_address, Result.ReturnObject);
+			}
+
+			helper.CompletedRTI ();
+			Result.InvocationCompleted = true;
+		}
+
+		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
+		{
+			if (Result.InvocationCompleted || Result.InvocationAborted) {
+				if (stopped_somewhere || ((Flags & RuntimeInvokeFlags.SendEventOnCompletion) != 0))
+					return new TargetEventArgs (TargetEventType.RuntimeInvokeDone, Result, frame);
+				else
+					return null;
+			}
+
+			stopped_somewhere = true;
+			return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
+		}
+
+		public void Abort ()
+		{
+			inferior.AbortInvoke (ID);
+			Result.InvocationAborted = true;
+		}
+
+		protected class OperationRuntimeInvokeHelper : OperationCallback
+		{
+			public readonly OperationRuntimeInvoke RTI;
+
+			MonoLanguageBackend language;
+			TargetAddress method = TargetAddress.Null;
+			TargetAddress invoke = TargetAddress.Null;
+			TargetStructObject instance;
+			MonoClassInfo class_info;
+			Stage stage;
+
+			protected enum Stage {
+				Uninitialized,
+				ResolvedClass,
+				BoxingInstance,
+				HasMethodAddress,
+				GettingVirtualMethod,
+				HasVirtualMethod,
+				CompilingMethod,
+				CompiledMethod,
+				InvokedMethod
+			}
+
+			public override bool IsSourceOperation {
+				get { return false; }
+			}
+
+			public TargetAddress InvokeMethod {
+				get { return invoke; }
+			}
+
+			public OperationRuntimeInvokeHelper (SingleSteppingEngine sse,
+							     OperationRuntimeInvoke rti)
+				: base (sse)
+			{
+				this.RTI = rti;
+
+				this.instance = RTI.Instance;
+				this.method = TargetAddress.Null;
+				this.stage = Stage.Uninitialized;
+			}
+
+			protected override void DoExecute ()
+			{
+				language = sse.process.MonoLanguage;
+
+				class_info = RTI.Function.ResolveClass (inferior, false);
+				if (class_info == null) {
+					MonoClassType klass = RTI.Function.DeclaringType as MonoClassType;
+					if (klass == null)
+						throw new TargetException (TargetError.ClassNotInitialized,
+									   "Class `{0}' not initialized yet.",
+									   RTI.Function.DeclaringType.Name);
+
+					TargetAddress image = RTI.Function.SymbolFile.MonoImage;
+					int token = klass.Token;
+
+					Report.Debug (DebugFlags.SSE,
+						      "{0} rti resolving class {1}:{2:x}", sse, image, token);
+
+					inferior.CallMethod (
+						sse.MonoDebuggerInfo.LookupClass, image.Address, 0, 0,
+						RTI.Function.DeclaringType.Name, ID);
+					return;
+				}
+
+				stage = Stage.ResolvedClass;
+				do_execute ();
+			}
+
+			void do_execute ()
+			{
+				switch (stage) {
+				case Stage.ResolvedClass:
+					if (!get_method_address ())
+						throw new TargetException (TargetError.ClassNotInitialized,
+									   "Class `{0}' not initialized yet.",
+									   RTI.Function.DeclaringType.Name);
+					goto case Stage.HasMethodAddress;
+
+				case Stage.HasMethodAddress:
+					if (!get_virtual_method ())
+						return;
+					goto case Stage.HasVirtualMethod;
+
+				case Stage.HasVirtualMethod: {
+					Report.Debug (DebugFlags.SSE,
+						      "{0} rti compiling method: {1}", sse, method);
+
+					stage = Stage.CompilingMethod;
+					inferior.CallMethod (
+						sse.MonoDebuggerInfo.CompileMethod, method.Address, 0, ID);
+					return;
+				}
+
+				case Stage.CompiledMethod: {
+					sse.insert_temporary_breakpoint (invoke);
+					sse.rti_stack.Push (RTI);
+
+					inferior.RuntimeInvoke (
+						sse.MonoDebuggerInfo.RuntimeInvoke,
+						method, instance, RTI.ParamObjects, ID, RTI.Debug);
+
+					stage = Stage.InvokedMethod;
+					return;
+				}
+
+				default:
+					throw new InternalError ();
+				}
+			}
+
+			bool get_method_address ()
+			{
+				method = class_info.GetMethodAddress (inferior, RTI.Function.Token);
+				if (method.IsNull)
+					return false;
+
+				if ((instance == null) || instance.Type.IsByRef)
+					return true;
+
+				TargetType decl = RTI.Function.DeclaringType;
+				if ((decl.Name != "System.ValueType") && (decl.Name != "System.Object"))
+					return true;
+
+				TargetStructType parent_type = RTI.Instance.Type.GetParentType (inferior);
+
+				if (!instance.Type.IsByRef && parent_type.IsByRef) {
+					TargetAddress klass = ((MonoClassObject) instance).KlassAddress;
+					stage = Stage.BoxingInstance;
+					inferior.CallMethod (
+						sse.MonoDebuggerInfo.GetBoxedObjectMethod, klass.Address,
+						instance.Location.GetAddress (inferior).Address, ID);
+					return false;
+				}
+
+				return true;
+			}
+
+			bool get_virtual_method ()
+			{
+				if (!RTI.IsVirtual || (instance == null) || !instance.HasAddress ||
+				    !instance.Type.IsByRef)
+					return true;
+
+				Report.Debug (DebugFlags.SSE, "{0} rti get virtual method: {1}", sse, instance);
+
+				stage = Stage.GettingVirtualMethod;
+				inferior.CallMethod (
+					sse.MonoDebuggerInfo.GetVirtualMethod,
+					instance.Location.GetAddress (inferior).Address,
+					method.Address, ID);
+				return false;
+			}
+
+			protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
+			{
+				switch (stage) {
+				case Stage.Uninitialized: {
+					TargetAddress klass = new TargetAddress (inferior.AddressDomain, data1);
+
+					Report.Debug (DebugFlags.SSE,
+						      "{0} rti resolved class: {1}", sse, klass);
+
+					class_info = language.ReadClassInfo (inferior, klass);
+					((IMonoStructType) RTI.Function.DeclaringType).ClassInfo = class_info;
+					((IMonoStructType) RTI.Function.DeclaringType).ResolveClass (inferior, false);
+					stage = Stage.ResolvedClass;
+					do_execute ();
+					args = null;
+					return EventResult.Running;
+				}
+
+				case Stage.BoxingInstance: {
+					TargetAddress boxed = new TargetAddress (inferior.AddressDomain, data1);
+
+					Report.Debug (DebugFlags.SSE,
+						      "{0} rti boxed object: {1}", sse, boxed);
+
+					TargetLocation new_loc = new AbsoluteTargetLocation (boxed);
+					TargetStructType parent_type = instance.Type.GetParentType (inferior);
+					instance = (TargetStructObject) parent_type.GetObject (inferior, new_loc);
+					stage = Stage.HasMethodAddress;
+					do_execute ();
+					args = null;
+					return EventResult.Running;
+				}
+
+				case Stage.GettingVirtualMethod: {
+					method = new TargetAddress (inferior.AddressDomain, data1);
+
+					Report.Debug (DebugFlags.SSE,
+						      "{0} rti got virtual method: {1}", sse, method);
+
+					TargetAddress klass = inferior.ReadAddress (method + 8);
+					TargetType class_type = language.ReadMonoClass (inferior, klass);
+
+					if (class_type == null) {
+						RTI.Result.ExceptionMessage = String.Format (
+							"Unable to get virtual method `{0}'.", RTI.Function.FullName);
+						RTI.Result.InvocationCompleted = true;
+						RestoreStack ();
+						args = null;
+						return EventResult.Completed;
+					}
+
+					if (!class_type.IsByRef) {
+						TargetLocation new_loc = instance.Location.GetLocationAtOffset (
+							2 * inferior.TargetMemoryInfo.TargetAddressSize);
+						instance = (TargetClassObject) class_type.GetObject (
+							inferior, new_loc);
+					}
+
+					Report.Debug (DebugFlags.SSE,
+						      "{0} rti got virtual method #1: {1} {2}", sse, class_type,
+						      instance);
+
+					stage = Stage.HasVirtualMethod;
+					do_execute ();
+					args = null;
+					return EventResult.Running;
+				}
+
+				case Stage.CompilingMethod: {
+					invoke = new TargetAddress (inferior.AddressDomain, data1);
+
+					Report.Debug (DebugFlags.SSE,
+						      "{0} rti compiled method: {1}", sse, invoke);
+
+					stage = Stage.CompiledMethod;
+					do_execute ();
+					args = null;
+					return EventResult.Running;
+				}
+
+				case Stage.InvokedMethod: {
+					RTI.Completed (data1, data2);
+					RestoreStack ();
+					args = null;
+					return EventResult.Completed;
+				}
+
+				default:
+					throw new InternalError ();
+				}
+			}
+
+			protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+								       out TargetEventArgs args)
+			{
+				if ((cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) ||
+				    ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
+				     (cevent.Argument == 0))) {
+					if (inferior.CurrentFrame == invoke) {
+						Report.Debug (DebugFlags.SSE,
+							      "{0} stopped at invoke method {1} / {2}",
+							      sse, invoke, stage);
+
+						inferior.MarkRuntimeInvokeFrame ();
+						RTI.SetupCallback (ID);
+
+						args = null;
+						return EventResult.AskParent;
+					} 
+
+					Report.Debug (DebugFlags.SSE,
+						      "{0} stopped at {1} during runtime-invoke: {2}",
+						      sse, inferior.CurrentFrame, cevent);
+				}
+
+				return base.DoProcessEvent (cevent, out args);
+			}
+
+			public override bool HandleException (TargetAddress stack, TargetAddress exc)
+			{
+				return false;
+			}
+
+			public void CompletedRTI ()
+			{
+				RestoreStack ();
+			}
+		}
+	}
+
+	protected class OperationCallMethod : OperationCallback
+	{
+		public readonly CallMethodType Type;
+		public readonly TargetAddress Method;
+		public readonly long Argument1;
+		public readonly long Argument2;
+		public readonly long Argument3;
+		public readonly TargetObject ObjectArgument;
+		public readonly string StringArgument;
+
+		public OperationCallMethod (SingleSteppingEngine sse,
+					    TargetAddress method, long arg1, long arg2, long arg3,
+					    string sarg)
+			: base (sse)
+		{
+			this.Type = CallMethodType.LongLongLongString;
+			this.Method = method;
+			this.Argument1 = arg1;
+			this.Argument2 = arg2;
+			this.Argument3 = arg3;
+			this.StringArgument = sarg;
+		}
+
+		public OperationCallMethod (SingleSteppingEngine sse,
+					    TargetAddress method, long arg1, long arg2)
+			: base (sse)
+		{
+			this.Type = CallMethodType.LongLong;
+			this.Method = method;
+			this.Argument1 = arg1;
+			this.Argument2 = arg2;
+		}
+
+		public OperationCallMethod (SingleSteppingEngine sse, TargetAddress method,
+					    TargetAddress method_arg, TargetObject object_arg)
+			: base (sse)
+		{
+			this.Type = CallMethodType.LongObject;
+			this.Method = method;
+			this.Argument1 = method_arg.Address;
+			this.ObjectArgument = object_arg;
+		}
+
+		bool interrupted_syscall;
+
+		protected override void DoExecute ()
+		{
+			if (!interrupted_syscall &&
+			    inferior.Architecture.IsSyscallInstruction (inferior, inferior.CurrentFrame)) {
+				if (!sse.Process.CanExecuteCode)
+					throw new TargetException (TargetError.InvocationException,
+								   "Current thread stopped on a system " +
+								   "call; cannot invoke any methods");
+
+				/*
+				 * The backend automatically sets %orig_rax to -1 before modifying %rip
+				 * to prevent the kernel from restarting the system call.
+				 *
+				 * Unfortunately, the kernel clobbers %rcx, which may be used to pass
+				 * parameters to the method.  Because of this, we need to execute a
+				 * dummy instruction first.
+				 */
+				byte[] nop_insn = inferior.Architecture.Opcodes.GenerateNopInstruction ();
+				sse.PushOperation (new OperationExecuteInstruction (sse, nop_insn, false));
+				interrupted_syscall = true;
+				return;
+			}
+
+			interrupted_syscall = false;
+
+			switch (Type) {
+			case CallMethodType.LongLong:
+				inferior.CallMethod (Method, Argument1, Argument2, ID);
+				break;
+
+			case CallMethodType.LongLongLongString:
+				inferior.CallMethod (Method, Argument1, Argument2, Argument3,
+						     StringArgument, ID);
+				break;
+
+			case CallMethodType.LongObject:
+				inferior.CallMethod (Method, Argument1, ObjectArgument, ID);
+				break;
+
+			default:
+				throw new InvalidOperationException ();
+			}
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			if (!interrupted_syscall)
+				return base.DoProcessEvent (cevent, out args);
+
+			Report.Debug (DebugFlags.EventLoop,
+				      "{0} received event {1} at {2} while waiting for " +
+				      "callback {4}:{3}", sse, cevent, inferior.CurrentFrame,
+				      ID, this);
+
+			args = null;
+			if ((cevent.Type != Inferior.ChildEventType.CHILD_STOPPED) &&
+			    (cevent.Argument != 0)) {
+				Report.Debug (DebugFlags.SSE,
+					      "{0} aborting callback {1} ({2}) at {3}: {4}",
+					      sse, this, ID, inferior.CurrentFrame, cevent);
+				AbortOperation ();
+				return EventResult.Completed;
+			}
+
+			DoExecute ();
+			return EventResult.Running;
+		}
+
+		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
+		{
+			if (inferior.TargetAddressSize == 4)
+				data1 &= 0xffffffffL;
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} call method done: {1:x} {2:x} {3}",
+				      sse, data1, data2, Result);
+
+			RestoreStack ();
+			Result.Result = new TargetAddress (inferior.AddressDomain, data1);
+			args = null;
+			return EventResult.Completed;
+		}
+	}
+
+	protected class OperationMonoTrampoline : Operation
+	{
+		public readonly Instruction CallSite;
+		public readonly TargetAddress Trampoline;
+		public readonly TrampolineHandler TrampolineHandler;
+
+		bool compiled;
+
+		public OperationMonoTrampoline (SingleSteppingEngine sse, Instruction call_site,
+						TargetAddress trampoline, TrampolineHandler handler)
+			: base (sse, null)
+		{
+			this.CallSite = call_site;
+			this.Trampoline = trampoline;
+			this.TrampolineHandler = handler;
+		}
+
+		public override bool IsSourceOperation {
+			get { return true; }
+		}
+
+		protected override void DoExecute ()
+		{
+			sse.enable_extended_notification (NotificationType.Trampoline);
+			sse.do_continue ();
+		}
+
+		public override bool ResumeOperation ()
+		{
+			sse.do_continue ();
+			return true;
+		}
+
+		protected void TrampolineCompiled (TargetAddress mono_method, TargetAddress code)
+		{
+			sse.disable_extended_notification (NotificationType.Trampoline);
+
+			if (TrampolineHandler != null) {
+				Method method = sse.Lookup (code);
+				if (!TrampolineHandler (method)) {
+					sse.do_continue (CallSite.Address + CallSite.InstructionSize);
+					return;
+				}
+			}
+
+			sse.do_continue (code);
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_NOTIFICATION) &&
+			    ((NotificationType) cevent.Argument == NotificationType.Trampoline)) {
+				TargetAddress method = new TargetAddress (
+					inferior.AddressDomain, cevent.Data1);
+				TargetAddress code = new TargetAddress (
+					inferior.AddressDomain, cevent.Data2);
+
+				args = null;
+				compiled = true;
+				TrampolineCompiled (method, code);
+				return EventResult.Running;
+			}
+
+			args = null;
+			if (!compiled) {
+				sse.disable_extended_notification (NotificationType.Trampoline);
+				return EventResult.Completed;
+			} else
+				return EventResult.ResumeOperation;
+		}
+	}
+
+	protected class OperationNativeTrampoline : Operation
+	{
+		public readonly TrampolineHandler TrampolineHandler;
+		public readonly TargetAddress Trampoline;
+
+		TargetAddress stack_pointer;
+		bool entered_trampoline;
+		bool done;
+
+		public OperationNativeTrampoline (SingleSteppingEngine sse, TargetAddress trampoline,
+						  TrampolineHandler handler)
+			: base (sse, null)
+		{
+			this.TrampolineHandler = handler;
+			this.Trampoline = trampoline;
+		}
+
+		public override bool IsSourceOperation {
+			get { return true; }
+		}
+
+		protected override void DoExecute ()
+		{
+			Inferior.StackFrame frame = inferior.GetCurrentFrame ();
+			stack_pointer = frame.StackPointer;
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} starting native trampoline {1} at {2}: {3}",
+				      sse, Trampoline, frame.Address, stack_pointer);
+
+			sse.do_continue (Trampoline);
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} native trampoline event: {1}", sse, cevent);
+
+			args = null;
+
+			Inferior.StackFrame frame = inferior.GetCurrentFrame ();
+
+			if (done)
+				return EventResult.Completed;
+
+			if (!entered_trampoline) {
+				stack_pointer = frame.StackPointer;
+
+				sse.do_step_native ();
+				entered_trampoline = true;
+				return EventResult.Running;
+			}
+
+			if (frame.StackPointer <= stack_pointer) {
+				sse.do_next ();
+				return EventResult.Running;
+			}
+
+			done = true;
+
+			Instruction instruction = sse.Architecture.ReadInstruction (
+				inferior, frame.Address);
+			if ((instruction == null) || !instruction.HasInstructionSize) {
+				sse.do_step_native ();
+				return EventResult.Running;
+			}
+
+			if (instruction.InstructionType != Instruction.Type.Jump) {
+				sse.do_step_native ();
+				return EventResult.Running;
+			}
+
+			return EventResult.Completed;
+		}
+	}
+
+	protected class OperationException : Operation
+	{
+		TargetAddress ip;
+		TargetAddress exc;
+		TargetObject exc_object;
+		bool unhandled;
+
+		public OperationException (SingleSteppingEngine sse, TargetAddress ip, TargetAddress exc,
+					   bool unhandled)
+			: base (sse, null)
+		{
+			this.ip = ip;
+			this.exc = exc;
+			this.unhandled = unhandled;
+		}
+
+		public override bool IsSourceOperation {
+			get { return false; }
+		}
+
+		protected override void DoExecute ()
+		{
+			try {
+				exc_object = sse.ProcessServant.MonoLanguage.CreateObject (inferior, exc);
+			} catch {
+				exc_object = null;
+			}
+
+			sse.remove_temporary_breakpoint ();
+			sse.do_continue (ip);
+		}
+
+		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
+							       out TargetEventArgs args)
+		{
+			Report.Debug (DebugFlags.SSE,
+				      "{0} processing OperationException at {1}: {2} {3} {4}",
+				      sse, inferior.CurrentFrame, ip, exc, unhandled);
+
+			if (unhandled) {
+				sse.frame_changed (inferior.CurrentFrame, null);
+				sse.current_frame.SetExceptionObject (exc_object);
+				args = new TargetEventArgs (
+					TargetEventType.UnhandledException,
+					exc_object, sse.current_frame);
+				return EventResult.SuspendOperation;
+			} else {
+				sse.frame_changed (inferior.CurrentFrame, null);
+				sse.current_frame.SetExceptionObject (exc_object);
+				args = new TargetEventArgs (
+					TargetEventType.Exception,
+					exc_object, sse.current_frame);
+				return EventResult.SuspendOperation;
+			}
+		}
+	}
+
+	protected class OperationWrapper : OperationStepBase
+	{
+		Method method;
+
+		public OperationWrapper (SingleSteppingEngine sse,
+					 Method method, CommandResult result)
+			: base (sse, result)
+		{
+			this.method = method;
+		}
+
+		public override bool IsSourceOperation {
+			get { return true; }
+		}
+
+		protected override void DoExecute ()
+		{
+			sse.do_step ();
+		}
+
+		protected override bool DoProcessEvent ()
+		{
+			TargetAddress current_frame = inferior.CurrentFrame;
+
+			Report.Debug (DebugFlags.SSE, "{0} wrapper stopped at {1} ({2}:{3})",
+				      sse, current_frame, method.StartAddress, method.EndAddress);
+			if ((current_frame < method.StartAddress) || (current_frame > method.EndAddress))
+				return true;
+
+			/*
+			 * If this is not a call instruction, continue stepping until we leave
+			 * the current method.
+			 */
+			Instruction instruction = inferior.Architecture.ReadInstruction (
+				inferior, current_frame);
+			if ((instruction == null) || !instruction.HasInstructionSize) {
+				sse.do_step ();
+				return false;
+			}
+
+			if (sse.CheckTrampoline (instruction, TrampolineHandler))
+				return false;
+
+			sse.do_step ();
+			return false;
+		}
+
+		protected override bool TrampolineHandler (Method method)
+		{
+			if (method == null)
+				return false;
+
+			if (method.IsInvokeWrapper)
+				return true;
+
+			return sse.MethodHasSource (method);
+		}
+	}
+
+	protected class OperationDelegateInvoke : OperationStepBase
+	{
+		public OperationDelegateInvoke (SingleSteppingEngine sse)
+			: base (sse, null)
+		{ }
+
+		public override bool IsSourceOperation {
+			get { return true; }
+		}
+
+		protected override void DoExecute ()
+		{
+			sse.do_step ();
+		}
+
+		bool finished;
+
+		protected override bool DoProcessEvent ()
+		{
+			TargetAddress current_frame = inferior.CurrentFrame;
+
+			Report.Debug (DebugFlags.SSE, "{0} delegate impl stopped at {1}",
+				      sse, current_frame);
+
+			if (finished)
+				return true;
+
+			/*
+			 * If this is not a call instruction, continue stepping until we leave
+			 * the current method.
+			 */
+			Instruction instruction = inferior.Architecture.ReadInstruction (
+				inferior, current_frame);
+			if ((instruction == null) || !instruction.HasInstructionSize) {
+				sse.do_step ();
+				return false;
+			}
+
+			Report.Debug (DebugFlags.SSE, "{0} delegate impl stopped at {1}: {2}",
+				      sse, current_frame, instruction);
+
+			if ((instruction.InstructionType == Instruction.Type.IndirectJump) ||
+			    (instruction.InstructionType == Instruction.Type.IndirectCall))
+				finished = true;
+
+			sse.do_step ();
+			return false;
+		}
+
+		protected override bool TrampolineHandler (Method method)
+		{
+			return false;
+		}
+	}
+
+	protected class OperationStepIterator : OperationStepBase
+	{
+		Method method;
+
+		public OperationStepIterator (SingleSteppingEngine sse,
+					      Method method, CommandResult result)
+			: base (sse, result)
+		{
+			this.method = method;
+		}
+
+		public override bool IsSourceOperation {
+			get { return true; }
+		}
+
+		protected override void DoExecute ()
+		{
+			sse.do_next ();
+		}
+
+		protected override bool DoProcessEvent ()
+		{
+			TargetAddress current_frame = inferior.CurrentFrame;
+
+			Report.Debug (DebugFlags.SSE, "{0} iterator stopped at {1} ({2}:{3})",
+				      sse, current_frame, method.StartAddress, method.EndAddress);
+			if ((current_frame < method.StartAddress) || (current_frame > method.EndAddress))
+				return true;
+
+			Block block = method.LookupBlock (inferior, current_frame);
+			Report.Debug (DebugFlags.SSE, "{0} iterator block: {1}", sse, block);
+			if ((block != null) && block.IsIteratorBody)
+				return true;
+
+			sse.do_next ();
+			return false;
+		}
+
+		protected override bool TrampolineHandler (Method method)
+		{
+			if (method == null)
+				return false;
+
+			if (method.IsInvokeWrapper)
+				return true;
+
+			return sse.MethodHasSource (method);
+		}
+	}
+
+	protected class OperationStepCompilerGenerated : OperationStepBase
+	{
+		Method method;
+		Block block;
+
+		public OperationStepCompilerGenerated (SingleSteppingEngine sse, Method method,
+						       Block block, CommandResult result)
+			: base (sse, result)
+		{
+			this.method = method;
+			this.block = block;
+		}
+
+		public override bool IsSourceOperation {
+			get { return true; }
+		}
+
+		protected override void DoExecute ()
+		{
+			sse.do_next ();
+		}
+
+		protected override bool DoProcessEvent ()
+		{
+			TargetAddress current_frame = inferior.CurrentFrame;
+
+			Report.Debug (DebugFlags.SSE, "{0} compiler generated stopped at {1} ({2}:{3})",
+				      sse, current_frame, block.StartAddress, block.EndAddress);
+			if ((current_frame < method.StartAddress + block.StartAddress) ||
+			    (current_frame > method.StartAddress + block.EndAddress))
+				return true;
+
+			sse.do_next ();
+			return false;
+		}
+
+		protected override bool TrampolineHandler (Method method)
+		{
+			if (method == null)
+				return false;
+
+			if (method.IsInvokeWrapper)
+				return true;
+
+			return sse.MethodHasSource (method);
+		}
+	}
+
+	protected class OperationReturn : OperationCallback
+	{
+		public readonly Backtrace Backtrace;
+		public readonly ReturnMode Mode;
+		OperationRuntimeInvoke aborted_rti;
+		int level = 0;
+
+		public OperationReturn (SingleSteppingEngine sse, Backtrace bt, ReturnMode mode)
+			: base (sse)
+		{
+			this.Backtrace = bt;
+			this.Mode = mode;
+		}
+
+		protected override void DoExecute ()
+		{
+			Report.Debug (DebugFlags.SSE, "{0} executing return: {1} {2}\n{2}", sse, Mode, level, Backtrace.Print ());
+			inferior.CallMethod (sse.MonoDebuggerInfo.RunFinally, null, ID);
+		}
+
+		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
+		{
+			args = null;
+			StackFrame parent_frame = Backtrace.Frames [++level];
+			inferior.SetRegisters (parent_frame.Registers);
+
+			Inferior.CallbackFrame cframe = inferior.GetCallbackFrame (parent_frame.StackPointer, true);
+			Report.Debug (DebugFlags.SSE, "{0} return: {1} {2}\n{3}", sse, level, cframe, parent_frame);
+			if (cframe != null) {
+				Report.Debug (DebugFlags.SSE, "{0} return aborting rti: {1}", sse, cframe);
+				aborted_rti = sse.AbortRuntimeInvoke (cframe.ID);
+				return EventResult.Completed;
+			}
+
+			if (level == Backtrace.Count) {
+				Report.Debug (DebugFlags.SSE, "{0} completed return", sse);
+				return EventResult.Completed;
+			}
+
+			DoExecute ();
+			return EventResult.Running;
+		}
+
+		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
+		{
+			if (aborted_rti != null)
+				return aborted_rti.OperationCompleted (frame, suspended);
+			else
+				return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
+		}
+	}
+
+	protected abstract class InterruptibleOperation : Operation
+	{
+		public bool IsSuspended {
+			get; set;
+		}
+
+		protected InterruptibleOperation (SingleSteppingEngine sse, CommandResult result)
+			: base (sse, result)
+		{ }
+
+		long callback_id;
+
+		public override EventResult ProcessEvent (Inferior.ChildEvent cevent,
+							  out TargetEventArgs args)
+		{
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_CALLBACK) ||
+			    (cevent.Type == Inferior.ChildEventType.RUNTIME_INVOKE_DONE)) {
+				if ((callback_id > 0) && (cevent.Argument == callback_id))
+					return CallbackCompleted (cevent.Data1, cevent.Data2, out args);
+			}
+
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) && (cevent.Argument != 0)) {
+				sse.frame_changed (inferior.CurrentFrame, null);
+				args = new TargetEventArgs (TargetEventType.TargetStopped, (int) cevent.Argument, sse.current_frame);
+				return EventResult.SuspendOperation;
+			}
+
+			return base.ProcessEvent (cevent, out args);
+		}
+
+		protected void SetupCallback (long id)
+		{
+			Report.Debug (DebugFlags.SSE, "{0} interruptible operation setup callback: {1}", sse, id);
+			this.callback_id = id;
+		}
+
+		protected abstract EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args);
+	}
+#endregion
+	}
+
+	internal class ManagedCallbackData
+	{
+		public readonly ManagedCallbackFunction Func;
+		public readonly CommandResult Result;
+
+		public bool Running;
+		public bool Completed;
+
+		public ManagedCallbackData (ManagedCallbackFunction func, CommandResult result)
+		{
+			this.Func = func;
+			this.Result = result;
+		}
+	}
+
+	[Serializable]
+	internal enum CommandType {
+		TargetAccess,
+		CreateProcess
+	}
+
+	[Serializable]
+	internal class Command {
+		public SingleSteppingEngine Engine;
+		public readonly CommandType Type;
+		public object Data1, Data2;
+		public object Result;
+
+		public Command (SingleSteppingEngine sse, TargetAccessDelegate func, object data)
+		{
+			this.Type = CommandType.TargetAccess;
+			this.Engine = sse;
+			this.Data1 = func;
+			this.Data2 = data;
+		}
+
+		public Command (CommandType type, object data)
+		{
+			this.Type = type;
+			this.Data1 = data;
+		}
+
+		public override string ToString ()
+		{
+			return String.Format ("Command ({0}:{1}:{2}:{3})",
+					      Engine, Type, Data1, Data2);
+		}
+	}
+
+	[Serializable]
+	internal enum CallMethodType
+	{
+		LongLong,
+		LongLongLongString,
+		LongObject
+	}
+}
diff --git a/backend/server/library.c b/backend/server/library.c
index 8f48607..ef75b97 100644
--- a/backend/server/library.c
+++ b/backend/server/library.c
@@ -79,12 +79,12 @@ mono_debugger_server_initialize_process (ServerHandle *handle)
 }
 
 ServerCommandError
-mono_debugger_server_initialize_thread (ServerHandle *handle, guint32 pid)
+mono_debugger_server_initialize_thread (ServerHandle *handle, guint32 pid, gboolean wait)
 {
 	if (!global_vtable->initialize_thread)
 		return COMMAND_ERROR_NOT_IMPLEMENTED;
 
-	return (* global_vtable->initialize_thread) (handle, pid);
+	return (* global_vtable->initialize_thread) (handle, pid, wait);
 }
 
 ServerCommandError
diff --git a/backend/server/server.h b/backend/server/server.h
index 7e2eda6..69e75a6 100644
--- a/backend/server/server.h
+++ b/backend/server/server.h
@@ -166,7 +166,8 @@ struct InferiorVTable {
 	ServerCommandError    (* initialize_process)  (ServerHandle       *handle);
 
 	ServerCommandError    (* initialize_thread)   (ServerHandle       *handle,
-						       guint32             pid);
+						       guint32             pid,
+						       gboolean            wait);
 
 	void                  (* set_runtime_info)    (ServerHandle       *handle,
 						       MonoRuntimeInfo    *mono_runtime_info);
@@ -478,7 +479,8 @@ mono_debugger_server_initialize_process   (ServerHandle       *handle);
 
 ServerCommandError
 mono_debugger_server_initialize_thread    (ServerHandle       *handle,
-					   guint32             pid);
+					   guint32             pid,
+					   gboolean            wait);
 
 void
 mono_debugger_server_io_thread_main       (IOThreadData       *io_data,
diff --git a/backend/server/x86-ptrace.c b/backend/server/x86-ptrace.c
index ae24934..7a6d9be 100644
--- a/backend/server/x86-ptrace.c
+++ b/backend/server/x86-ptrace.c
@@ -451,7 +451,7 @@ server_ptrace_spawn (ServerHandle *handle, const gchar *working_directory,
 }
 
 static ServerCommandError
-server_ptrace_initialize_thread (ServerHandle *handle, guint32 pid)
+server_ptrace_initialize_thread (ServerHandle *handle, guint32 pid, gboolean wait)
 {
 	InferiorHandle *inferior = handle->inferior;
 
@@ -462,7 +462,7 @@ server_ptrace_initialize_thread (ServerHandle *handle, guint32 pid)
 	inferior->os.thread = get_thread_from_index(GET_THREAD_INDEX(pid));
 #else
 	inferior->pid = pid;
-	if (!_server_ptrace_wait_for_new_thread (handle))
+	if (wait && !_server_ptrace_wait_for_new_thread (handle))
 		return COMMAND_ERROR_INTERNAL_ERROR;
 #endif
 

--------------1.5.6--



From ad6d8bd16a52414c18bb423e556e0c58a7a97f2d Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 15 Jul 2009 03:25:04 +0200
Subject: [PATCH] Tests ...
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs        |    1 +
 test/testsuite/TestExec.cs       |    6 +++++-
 test/testsuite/testnativeexec.cs |    1 +
 test/testsuite/testnativefork.cs |    1 +
 4 files changed, 8 insertions(+), 1 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="ad6d8bd16a52414c18bb423e556e0c58a7a97f2d.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="ad6d8bd16a52414c18bb423e556e0c58a7a97f2d.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index f2d1638..9c9b3a6 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -293,6 +293,7 @@ namespace Mono.Debugger.Backend
 			manager.Debugger.OnThreadCreatedEvent (new_thread.Thread);
 			initialized = is_forked = false;
 
+			current_state = ProcessState.SingleThreaded; // FIXME
 			new_thread.StartExecedChild ();
 		}
 
diff --git a/test/testsuite/TestExec.cs b/test/testsuite/TestExec.cs
index 7ad2811..5b163e5 100644
--- a/test/testsuite/TestExec.cs
+++ b/test/testsuite/TestExec.cs
@@ -25,6 +25,8 @@ namespace Mono.Debugger.Tests
 		public override void SetUp ()
 		{
 			base.SetUp ();
+			Config.FollowFork = true;
+			Config.ThreadingModel = ThreadingModel.Single;
 
 			bpt_main = AssertBreakpoint (
 				String.Format ("-local {0}:{1}", FileName, line_main_3));
@@ -63,6 +65,8 @@ namespace Mono.Debugger.Tests
 			       !child_exited || !thread_exited) {
 				DebuggerEvent e = AssertEvent ();
 
+				Report.Debug (DebugFlags.NUnit, "EXEC EVENT: {0}", e);
+
 				if (e.Type == DebuggerEventType.ProcessExited) {
 					if ((Process) e.Data == child.Process) {
 						child_exited = true;
@@ -139,7 +143,7 @@ namespace Mono.Debugger.Tests
 			       !child_exited || !thread_exited) {
 				DebuggerEvent e = AssertEvent ();
 
-				Report.Debug (DebugFlags.Threads, "EXEC EVENT: {0}", e);
+				Report.Debug (DebugFlags.NUnit, "EXEC EVENT: {0}", e);
 
 				if (e.Type == DebuggerEventType.ProcessExited) {
 					if ((Process) e.Data == child.Process) {
diff --git a/test/testsuite/testnativeexec.cs b/test/testsuite/testnativeexec.cs
index 141cfbc..7e975a0 100644
--- a/test/testsuite/testnativeexec.cs
+++ b/test/testsuite/testnativeexec.cs
@@ -27,6 +27,7 @@ namespace Mono.Debugger.Tests
 		{
 			base.SetUp ();
 			Config.FollowFork = true;
+			Config.ThreadingModel = ThreadingModel.Single;
 
 			bpt_local_waitpid = AssertBreakpoint (String.Format ("-local {0}:{1}", FileName, LineWaitpid+1));
 			bpt_waitpid = AssertBreakpoint (String.Format ("-local {0}:{1}", FileName, LineWaitpid));
diff --git a/test/testsuite/testnativefork.cs b/test/testsuite/testnativefork.cs
index a7a65e9..fabd337 100644
--- a/test/testsuite/testnativefork.cs
+++ b/test/testsuite/testnativefork.cs
@@ -28,6 +28,7 @@ namespace Mono.Debugger.Tests
 		{
 			base.SetUp ();
 			Config.FollowFork = true;
+			Config.ThreadingModel = ThreadingModel.Single;
 
 			bpt_child = AssertBreakpoint (String.Format ("-global {0}:{1}", FileName, LineChild));
 			bpt_waitpid = AssertBreakpoint (String.Format ("-local {0}:{1}", FileName, LineWaitpid + 1));

--------------1.5.6--



From f9501ed1409e176cd2c84e019cea7877d34414cf Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 15 Jul 2009 04:21:45 +0200
Subject: [PATCH] Clone breakpoints into forked childs.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |    2 +-
 backend/SingleSteppingEngine.cs |    2 +-
 classes/DebuggerSession.cs      |   54 +++++++++++++++++++++++++++++++++------
 frontend/Command.cs             |    2 +-
 frontend/Expression.cs          |   21 ++++++++++++---
 frontend/Interpreter.cs         |    2 +
 test/src/TestChild.cs           |    2 +
 test/testsuite/TestExec.cs      |   15 +++++++++-
 8 files changed, 83 insertions(+), 17 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="f9501ed1409e176cd2c84e019cea7877d34414cf.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="f9501ed1409e176cd2c84e019cea7877d34414cf.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 9c9b3a6..7215343 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -255,7 +255,7 @@ namespace Mono.Debugger.Backend
 			if (breakpoint_manager != null)
 				breakpoint_manager.Dispose ();
 
-			session = session.Clone (start.Options, "@" + id);
+			session = session.Clone (client, start.Options, "@" + id);
 			session.OnProcessCreated (client);
 
 			breakpoint_manager = new BreakpointManager ();
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 322feb7..15a13f6 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1753,7 +1753,7 @@ namespace Mono.Debugger.Backend
 				update_current_frame (main_frame);
 			}
 
-			Report.Debug (DebugFlags.SSE, "{0} activate pending breakpoints", this);
+			Report.Debug (DebugFlags.SSE, "{0} activate pending breakpoints: {1}", this, process.Session.Events.Length);
 
 			Queue pending = new Queue ();
 			foreach (Event e in process.Session.Events) {
diff --git a/classes/DebuggerSession.cs b/classes/DebuggerSession.cs
index 8478318..7229fa7 100644
--- a/classes/DebuggerSession.cs
+++ b/classes/DebuggerSession.cs
@@ -31,6 +31,8 @@ namespace Mono.Debugger
 
 	public interface IExpressionParser
 	{
+		IExpressionParser Clone (DebuggerSession session);
+
 		SourceLocation ParseLocation (Thread target, StackFrame frame,
 					      LocationType type, string name);
 	}
@@ -56,12 +58,10 @@ namespace Mono.Debugger
 		IExpressionParser parser;
 		XmlDocument saved_session;
 
-		private DebuggerSession (DebuggerConfiguration config, string name,
-					 IExpressionParser parser)
+		private DebuggerSession (DebuggerConfiguration config, string name)
 		{
 			this.Config = config;
 			this.Name = name;
-			this.parser = parser;
 
 			modules = Hashtable.Synchronized (new Hashtable ());
 			events = Hashtable.Synchronized (new Hashtable ());
@@ -75,17 +75,41 @@ namespace Mono.Debugger
 
 		public DebuggerSession (DebuggerConfiguration config, DebuggerOptions options,
 					string name, IExpressionParser parser)
-			: this (config, name, parser)
+			: this (config, name)
 		{
 			this.Options = options;
+			this.parser = parser;
 
 			if (Options.StopInMain)
 				AddEvent (new MainMethodBreakpoint (this));
 		}
 
-		internal DebuggerSession Clone (DebuggerOptions new_options, string new_name)
+		protected DebuggerSession (DebuggerConfiguration config, Process process, DebuggerOptions options,
+					   string name, IExpressionParser parser, XPathNavigator nav)
+			: this (config, name)
+		{
+			this.main_process = process;
+			this.Options = options;
+			this.parser = parser.Clone (this);
+
+			XPathNodeIterator event_iter = nav.Select ("Events/*");
+			LoadEvents (event_iter);
+
+			XPathNodeIterator display_iter = nav.Select ("Displays/*");
+			LoadDisplays (display_iter);
+		}
+
+		internal DebuggerSession Clone (Process new_process, DebuggerOptions new_options, string new_name)
 		{
-			return new DebuggerSession (Config, new_options, new_name, parser);
+			XmlDocument document = SaveSession ();
+
+			XPathNavigator nav = document.CreateNavigator ();
+			XPathNodeIterator session_iter = nav.Select (
+				"/DebuggerConfiguration/DebuggerSession[@name='" + Name + "']");
+			if (!session_iter.MoveNext ())
+				throw new InternalError ();
+
+			return new DebuggerSession (Config, new_process, new_options, new_name, parser, session_iter.Current);
 		}
 
 		public void SaveSession (Stream stream)
@@ -141,8 +165,10 @@ namespace Mono.Debugger
 
 		public DebuggerSession (DebuggerConfiguration config, Stream stream,
 					IExpressionParser parser)
-			: this (config, "main", parser)
+			: this (config, "main")
 		{
+			this.parser = parser;
+
 			XmlReaderSettings settings = new XmlReaderSettings ();
 			Assembly ass = Assembly.GetExecutingAssembly ();
 			using (Stream schema = ass.GetManifestResourceStream ("DebuggerConfiguration"))
@@ -329,6 +355,14 @@ namespace Mono.Debugger
 			}
 
 			XPathNodeIterator event_iter = session_iter.Current.Select ("Events/*");
+			LoadEvents (event_iter);
+
+			XPathNodeIterator display_iter = session_iter.Current.Select ("Displays/*");
+			LoadDisplays (display_iter);
+		}
+
+		protected void LoadEvents (XPathNodeIterator event_iter)
+		{
 			while (event_iter.MoveNext ()) {
 				if (event_iter.Current.Name != "Breakpoint")
 					throw new InternalError ();
@@ -359,8 +393,10 @@ namespace Mono.Debugger
 				e.IsEnabled = enabled;
 				AddEvent (e);
 			}
+		}
 
-			XPathNodeIterator display_iter = session_iter.Current.Select ("Displays/*");
+		protected void LoadDisplays (XPathNodeIterator display_iter)
+		{
 			while (display_iter.MoveNext ()) {
 				if (display_iter.Current.Name != "Display")
 					throw new InternalError ();
@@ -374,6 +410,7 @@ namespace Mono.Debugger
 			}
 		}
 
+
 		protected Event ParseEvent (XPathNavigator navigator, int index, ThreadGroup group)
 		{
 			if (navigator.Name == "Location") {
@@ -394,6 +431,7 @@ namespace Mono.Debugger
 				throw new InternalError ();
 		}
 
+
 		//
 		// Modules.
 		//
diff --git a/frontend/Command.cs b/frontend/Command.cs
index 04b41fc..4d8863c 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -3159,7 +3159,7 @@ namespace Mono.Debugger.Frontend
 
 				context.CurrentFrame = frame;
 
-				if (ExpressionParser.ParseLocation (context, Argument, out location))
+				if (context.Interpreter.ExpressionParser.ParseLocation (context, Argument, out location))
 					return true;
 			}
 
diff --git a/frontend/Expression.cs b/frontend/Expression.cs
index 4d6851b..f0b54a1 100644
--- a/frontend/Expression.cs
+++ b/frontend/Expression.cs
@@ -14,7 +14,13 @@ namespace Mono.Debugger.Frontend
 {
 	public class ExpressionParser : IExpressionParser
 	{
-		public readonly Interpreter Interpreter;
+		public DebuggerSession Session {
+			get; internal set;
+		}
+
+		public Interpreter Interpreter {
+			get; private set;
+		}
 
 		private readonly CSharp.ExpressionParser parser;
 
@@ -25,6 +31,13 @@ namespace Mono.Debugger.Frontend
 			parser = new CSharp.ExpressionParser ("C#");
 		}
 
+		public IExpressionParser Clone (DebuggerSession session)
+		{
+			ExpressionParser parser = new ExpressionParser (Interpreter);
+			parser.Session = session;
+			return parser;
+		}
+
 		/*
 		 * This version throws an `ExpressionParsingException' containing a detailed
 		 * error message and the location of the error.
@@ -42,10 +55,10 @@ namespace Mono.Debugger.Frontend
 			return new MyExpression (this, parser.Parse (text));
 		}
 
-		protected static SourceLocation FindFile (ScriptingContext context, string filename,
+		protected SourceLocation FindFile (ScriptingContext context, string filename,
 							  int line)
 		{
-			SourceFile file = context.Interpreter.Session.FindFile (filename);
+			SourceFile file = Session.FindFile (filename);
 			if (file == null)
 				throw new ScriptingException ("Cannot find source file `{0}'.",
 							      filename);
@@ -71,7 +84,7 @@ namespace Mono.Debugger.Frontend
 				return context.FindMethod (arg);
 		}
 
-		public static bool ParseLocation (ScriptingContext context, string arg,
+		public bool ParseLocation (ScriptingContext context, string arg,
 						  out SourceLocation location)
 		{
 			int line;
diff --git a/frontend/Interpreter.cs b/frontend/Interpreter.cs
index 3382c17..3eedb79 100644
--- a/frontend/Interpreter.cs
+++ b/frontend/Interpreter.cs
@@ -62,6 +62,8 @@ namespace Mono.Debugger.Frontend
 			this.session = new DebuggerSession (config, options, "main", parser);
 			this.engine = new DebuggerEngine (this);
 
+			parser.Session = session;
+
 			source_factory = new SourceFileFactory ();
 
 			interrupt_event = new ManualResetEvent (false);
diff --git a/test/src/TestChild.cs b/test/src/TestChild.cs
index 548e228..32fb3c8 100644
--- a/test/src/TestChild.cs
+++ b/test/src/TestChild.cs
@@ -1,9 +1,11 @@
 using System;
+using System.Threading;
 
 class X
 {
 	static int Main ()
 	{
+		Thread.Sleep (500);
 		Console.WriteLine ("Hello World");
 		return 0;
 	}
diff --git a/test/testsuite/TestExec.cs b/test/testsuite/TestExec.cs
index 5b163e5..4d551d5 100644
--- a/test/testsuite/TestExec.cs
+++ b/test/testsuite/TestExec.cs
@@ -19,8 +19,10 @@ namespace Mono.Debugger.Tests
 
 		const int line_main = 8;
 		const int line_main_3 = 12;
+		const int line_child = 9;
 
 		int bpt_main;
+		int bpt_child;
 
 		public override void SetUp ()
 		{
@@ -28,8 +30,10 @@ namespace Mono.Debugger.Tests
 			Config.FollowFork = true;
 			Config.ThreadingModel = ThreadingModel.Single;
 
-			bpt_main = AssertBreakpoint (
-				String.Format ("-local {0}:{1}", FileName, line_main_3));
+			bpt_main = AssertBreakpoint (String.Format ("-local {0}:{1}", FileName, line_main_3));
+
+			string child_file = Path.GetFullPath (Path.Combine (SourceDirectory, "TestChild.cs"));
+			bpt_child = AssertBreakpoint (String.Format ("-global -lazy {0}:{1}", child_file, line_child));
 		}
 
 		[Test]
@@ -42,6 +46,9 @@ namespace Mono.Debugger.Tests
 				Path.Combine (BuildDirectory, "testnativechild")
 			};
 
+			AssertExecute ("disable " + bpt_child);
+
+			Interpreter.DebuggerConfiguration.ThreadingModel = ThreadingModel.Single;
 
 			Process process = Start ();
 			Assert.IsTrue (process.IsManaged);
@@ -121,6 +128,10 @@ namespace Mono.Debugger.Tests
 				MonoExecutable, Path.Combine (BuildDirectory, "TestChild.exe")
 			};
 
+			Interpreter.DebuggerConfiguration.ThreadingModel = ThreadingModel.Single;
+
+			AssertExecute ("disable " + bpt_child);
+
 			Process process = Start ();
 			Assert.IsTrue (process.IsManaged);
 			Assert.IsTrue (process.MainThread.IsStopped);

--------------1.5.6--



From 1413b416f8362a1817224e15ba62dca1b815a540 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 15 Jul 2009 04:56:06 +0200
Subject: [PATCH] Some more work on follow-exec.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs             |   33 +++++++++-
 backend/SingleSteppingEngine.cs       |    4 +-
 test/framework/DebuggerTestFixture.cs |    1 +
 test/testsuite/TestExec.cs            |  110 ++++++++++++++++++++++++++++++++-
 4 files changed, 143 insertions(+), 5 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="1413b416f8362a1817224e15ba62dca1b815a540.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="1413b416f8362a1817224e15ba62dca1b815a540.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 7215343..f725da0 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -33,6 +33,8 @@ namespace Mono.Debugger.Backend
 		protected ThreadServant main_thread;
 		Hashtable thread_hash;
 
+		ProcessServant parent;
+
 		ThreadDB thread_db;
 
 		bool is_attached;
@@ -91,6 +93,8 @@ namespace Mono.Debugger.Backend
 			this.is_forked = true;
 			this.initialized = true;
 
+			this.parent = parent;
+
 			breakpoint_manager = new BreakpointManager (parent.breakpoint_manager);
 
 			exception_handlers = new Dictionary<int,ExceptionCatchPoint> ();
@@ -293,8 +297,25 @@ namespace Mono.Debugger.Backend
 			manager.Debugger.OnThreadCreatedEvent (new_thread.Thread);
 			initialized = is_forked = false;
 
+#if FIXME
 			current_state = ProcessState.SingleThreaded; // FIXME
 			new_thread.StartExecedChild ();
+#elif FUCK
+			if (parent != null) {
+				Console.WriteLine ("CHILD EXECD: {0} {1}", parent.current_state, parent.current_operation);
+
+				current_state = parent.current_state;
+				current_operation = parent.current_operation;
+			} else {
+				current_state = ProcessState.Running;
+				current_operation = new ProcessOperationResult (this);
+			}
+			new_thread.StartExecedChild (current_operation);
+#else
+			current_state = ProcessState.RunningAfterExec;
+			current_operation = new ProcessOperationResult (this);
+			new_thread.StartExecedChild (current_operation);
+#endif
 		}
 
 		internal CommandResult StartApplication ()
@@ -681,6 +702,7 @@ namespace Mono.Debugger.Backend
 			Unknown,
 			SingleThreaded,
 			Running,
+			RunningAfterExec,
 			Stopping,
 			Stopped,
 			Exited
@@ -698,19 +720,26 @@ namespace Mono.Debugger.Backend
 
 			Report.Debug (DebugFlags.EventLoop, "{0} completed operation: {1} {2} {3}", caller, current_state, caller.State, result);
 
-			if (current_state == ProcessState.Running) {
-				if ((result != null) &&
+			if ((current_state == ProcessState.Running) || (current_state == ProcessState.RunningAfterExec)) {
+				if ((result != null) && (caller != main_thread) &&
 				    ((result.Type == TargetEventType.TargetExited) || (result.Type == TargetEventType.TargetSignaled)))
 					return;
 
+				bool running_after_exec = current_state == ProcessState.RunningAfterExec;
+
 				current_state = ProcessState.Stopping;
 				SuspendUserThreads (ThreadingModel.Process, caller);
 				current_state = ProcessState.Stopped;
 				current_operation.Completed ();
 				current_operation = null;
 				stopped_event.Set ();
+
+				if (running_after_exec) {
+					parent.OperationCompleted (caller, result);
+				} else {
 				if (result != null)
 					OnTargetEvent (caller, result);
+				}
 			} else if (current_state == ProcessState.SingleThreaded) {
 				if (result != null)
 					OnTargetEvent (caller, result);
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 15a13f6..edfa209 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -121,12 +121,12 @@ namespace Mono.Debugger.Backend
 			return result;
 		}
 
-		public void StartExecedChild ()
+		public CommandResult StartExecedChild (CommandResult result)
 		{
 			engine_stopped = false;
-			CommandResult result = new ThreadCommandResult (thread);
 			current_operation = new OperationStart (this, result);
 			current_operation.Execute ();
+			return result;
 		}
 
 		public CommandResult StartThread ()
diff --git a/test/framework/DebuggerTestFixture.cs b/test/framework/DebuggerTestFixture.cs
index fc9245f..2290ade 100644
--- a/test/framework/DebuggerTestFixture.cs
+++ b/test/framework/DebuggerTestFixture.cs
@@ -132,6 +132,7 @@ namespace Mono.Debugger.Test.Framework
 
 		internal void AddEvent (DebuggerEvent e)
 		{
+			Console.WriteLine ("ADD EVENT: {0}", e);
 			lock (queue.SyncRoot) {
 				queue.Enqueue (e);
 				wait_event.Set ();
diff --git a/test/testsuite/TestExec.cs b/test/testsuite/TestExec.cs
index 4d551d5..c7ef67f 100644
--- a/test/testsuite/TestExec.cs
+++ b/test/testsuite/TestExec.cs
@@ -9,7 +9,7 @@ using Mono.Debugger.Test.Framework;
 
 namespace Mono.Debugger.Tests
 {
-	[DebuggerTestFixture]
+	[DebuggerTestFixture(Timeout = -1)]
 	public class TestExec : DebuggerTestFixture
 	{
 		public TestExec ()
@@ -200,5 +200,113 @@ namespace Mono.Debugger.Tests
 			AssertExecute ("continue");
 			AssertTargetExited (thread.Process);
 		}
+
+		[Test]
+		[Category("Test")]
+		[Category("Fork")]
+		public void ProcessThreadModel ()
+		{
+			Interpreter.Options.File = Path.Combine (BuildDirectory, "TestExec.exe");
+			Interpreter.Options.InferiorArgs = new string [] {
+				MonoExecutable, Path.Combine (BuildDirectory, "TestChild.exe")
+			};
+
+			AssertExecute ("enable " + bpt_child);
+
+			Interpreter.DebuggerConfiguration.ThreadingModel = ThreadingModel.Process;
+
+			Process process = Start ();
+			Assert.IsTrue (process.IsManaged);
+			Assert.IsTrue (process.MainThread.IsStopped);
+			Thread thread = process.MainThread;
+
+			AssertStopped (thread, "X.Main(string[])", line_main);
+			AssertExecute ("continue");
+
+			Thread child = AssertProcessCreated ();
+			Thread execd_child = null;
+
+			bool execd = false;
+			bool stopped = false;
+			bool thread_created = false;
+
+			while (!stopped || !execd || !thread_created) {
+				DebuggerEvent e = AssertEvent ();
+
+				Report.Debug (DebugFlags.NUnit, "EXEC EVENT: {0}", e);
+
+				if (e.Type == DebuggerEventType.ProcessExecd) {
+					if ((Process) e.Data == child.Process) {
+						execd = true;
+						continue;
+					}
+				} else if (e.Type == DebuggerEventType.ThreadCreated) {
+					execd_child = (Thread) e.Data;
+					thread_created = true;
+					continue;
+				} else if (e.Type == DebuggerEventType.TargetEvent) {
+					Thread e_thread = (Thread) e.Data;
+					TargetEventArgs args = (TargetEventArgs) e.Data2;
+
+					if ((e_thread == execd_child) &&
+					    (args.Type == TargetEventType.TargetHitBreakpoint) &&
+					    ((int) args.Data == bpt_child)) {
+						stopped = true;
+						continue;
+					}
+				}
+
+				Assert.Fail ("Received unexpected event {0}", e);
+			}
+
+			AssertFrame (execd_child, "X.Main()", line_child);
+
+			AssertExecute ("continue -bg");
+			AssertExecute ("continue -thread " + thread.ID);
+
+			bool thread_exited = false;
+			bool child_exited = false;
+			bool reached_waitpid = false;
+
+			while (!child_exited || !thread_exited || !reached_waitpid) {
+				DebuggerEvent e = AssertEvent ();
+
+				Report.Debug (DebugFlags.NUnit, "EXEC EVENT: {0}", e);
+				Console.WriteLine ("THE EVENT: {0}", e);
+
+				if (e.Type == DebuggerEventType.ProcessExited) {
+					if ((Process) e.Data == child.Process) {
+						child_exited = true;
+						continue;
+					}
+				} else if (e.Type == DebuggerEventType.ThreadExited) {
+					if ((Thread) e.Data == execd_child) {
+						thread_exited = true;
+						continue;
+					}
+				} else if (e.Type == DebuggerEventType.TargetEvent) {
+					Thread e_thread = (Thread) e.Data;
+					TargetEventArgs args = (TargetEventArgs) e.Data2;
+
+					if ((e_thread == thread) &&
+					    (args.Type == TargetEventType.TargetHitBreakpoint) &&
+					    ((int) args.Data == bpt_main)) {
+						reached_waitpid = true;
+						continue;
+					}
+				}
+
+				Assert.Fail ("Received unexpected event {0}", e);
+			}
+
+			AssertTargetOutput ("Hello World");
+			AssertNoTargetOutput ();
+
+			AssertFrame (thread, "X.Main(string[])", line_main_3);
+			AssertPrint (thread, "process.ExitCode", "(int) 0");
+
+			AssertExecute ("continue");
+			AssertTargetExited (thread.Process);
+		}
 	}
 }

--------------1.5.6--



From 624f550141919a0a952395ff971717466f4f3911 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 15 Jul 2009 05:03:38 +0200
Subject: [PATCH] la la la
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs             |   21 +++++----------------
 backend/ThreadManager.cs              |   32 --------------------------------
 test/framework/DebuggerTestFixture.cs |    1 -
 test/testsuite/TestExec.cs            |    8 +++++---
 4 files changed, 10 insertions(+), 52 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="624f550141919a0a952395ff971717466f4f3911.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="624f550141919a0a952395ff971717466f4f3911.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index f725da0..2ccf062 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -297,25 +297,14 @@ namespace Mono.Debugger.Backend
 			manager.Debugger.OnThreadCreatedEvent (new_thread.Thread);
 			initialized = is_forked = false;
 
-#if FIXME
-			current_state = ProcessState.SingleThreaded; // FIXME
-			new_thread.StartExecedChild ();
-#elif FUCK
-			if (parent != null) {
-				Console.WriteLine ("CHILD EXECD: {0} {1}", parent.current_state, parent.current_operation);
-
-				current_state = parent.current_state;
-				current_operation = parent.current_operation;
-			} else {
-				current_state = ProcessState.Running;
-				current_operation = new ProcessOperationResult (this);
-			}
-			new_thread.StartExecedChild (current_operation);
-#else
+			if (parent.current_state == ProcessState.Running) {
 			current_state = ProcessState.RunningAfterExec;
 			current_operation = new ProcessOperationResult (this);
 			new_thread.StartExecedChild (current_operation);
-#endif
+			} else {
+				current_state = ProcessState.SingleThreaded;
+				new_thread.StartExecedChild (new ThreadCommandResult (new_thread.Thread));
+			}
 		}
 
 		internal CommandResult StartApplication ()
diff --git a/backend/ThreadManager.cs b/backend/ThreadManager.cs
index 123ab32..212bdee 100644
--- a/backend/ThreadManager.cs
+++ b/backend/ThreadManager.cs
@@ -628,38 +628,6 @@ namespace Mono.Debugger.Backend
 			}
 		}
 
-#region Stopping / Starting threads
-
-#if FIXME
-
-		bool stopped_all_threads;
-
-		internal void StopAllThreads (ThreadingModel model, SingleSteppingEngine caller)
-		{
-			Report.Debug (DebugFlags.SSE, "Stopping all threads: {0} {1}", model, caller);
-
-			caller.Process.SuspendUserThreads (model, caller);
-			stopped_all_threads = true;
-
-			Report.Debug (DebugFlags.SSE, "Stopped all threads: {0} {1}",
-				      model, caller.Inferior.CurrentFrame);
-		}
-
-		internal void ResumeAllThreads (SingleSteppingEngine engine)
-		{
-			if (!stopped_all_threads)
-				return;
-
-			Report.Debug (DebugFlags.SSE, "Resuming all threads: {0}", engine);
-
-			engine.Process.ResumeUserThreads (engine);
-			stopped_all_threads = false;
-		}
-
-#endif
-
-#endregion
-
 #region IDisposable implementation
 		private bool disposed = false;
 
diff --git a/test/framework/DebuggerTestFixture.cs b/test/framework/DebuggerTestFixture.cs
index 2290ade..fc9245f 100644
--- a/test/framework/DebuggerTestFixture.cs
+++ b/test/framework/DebuggerTestFixture.cs
@@ -132,7 +132,6 @@ namespace Mono.Debugger.Test.Framework
 
 		internal void AddEvent (DebuggerEvent e)
 		{
-			Console.WriteLine ("ADD EVENT: {0}", e);
 			lock (queue.SyncRoot) {
 				queue.Enqueue (e);
 				wait_event.Set ();
diff --git a/test/testsuite/TestExec.cs b/test/testsuite/TestExec.cs
index c7ef67f..699a878 100644
--- a/test/testsuite/TestExec.cs
+++ b/test/testsuite/TestExec.cs
@@ -202,9 +202,8 @@ namespace Mono.Debugger.Tests
 		}
 
 		[Test]
-		[Category("Test")]
 		[Category("Fork")]
-		public void ProcessThreadModel ()
+		public void ThreadingModelProcess ()
 		{
 			Interpreter.Options.File = Path.Combine (BuildDirectory, "TestExec.exe");
 			Interpreter.Options.InferiorArgs = new string [] {
@@ -259,6 +258,10 @@ namespace Mono.Debugger.Tests
 				Assert.Fail ("Received unexpected event {0}", e);
 			}
 
+			Assert.IsTrue (thread.IsStopped);
+			Assert.IsTrue (execd_child.IsStopped);
+			Assert.IsTrue (Interpreter.CurrentThread == execd_child);
+
 			AssertFrame (execd_child, "X.Main()", line_child);
 
 			AssertExecute ("continue -bg");
@@ -272,7 +275,6 @@ namespace Mono.Debugger.Tests
 				DebuggerEvent e = AssertEvent ();
 
 				Report.Debug (DebugFlags.NUnit, "EXEC EVENT: {0}", e);
-				Console.WriteLine ("THE EVENT: {0}", e);
 
 				if (e.Type == DebuggerEventType.ProcessExited) {
 					if ((Process) e.Data == child.Process) {

--------------1.5.6--



From 863a194c0606bc64cd5cbd7de2d7ebceed6292e2 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 15 Jul 2009 05:14:12 +0200
Subject: [PATCH] Fork is now working.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs        |    9 ++++++++-
 backend/SingleSteppingEngine.cs  |    3 +--
 test/testsuite/testnativeexec.cs |    4 +---
 test/testsuite/testnativefork.cs |    2 +-
 4 files changed, 11 insertions(+), 7 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="863a194c0606bc64cd5cbd7de2d7ebceed6292e2.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="863a194c0606bc64cd5cbd7de2d7ebceed6292e2.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 2ccf062..0e77cf5 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -235,7 +235,14 @@ namespace Mono.Debugger.Backend
 			manager.Debugger.OnProcessCreatedEvent (new_process);
 			new_process.OnThreadCreatedEvent (new_thread);
 
-			new_thread.StartForkedChild ();
+			if (current_state == ProcessState.Running) {
+				new_process.current_state = ProcessState.RunningAfterExec;
+				new_process.current_operation = new ProcessOperationResult (new_process);
+				new_thread.StartForkedChild (new_process.current_operation);
+			} else {
+				new_process.current_state = ProcessState.SingleThreaded;
+				new_thread.StartForkedChild (new ThreadCommandResult (new_thread.Thread));
+			}
 		}
 
 		internal void ChildExecd (Inferior inferior)
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index edfa209..7732795 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -137,10 +137,9 @@ namespace Mono.Debugger.Backend
 			return current_operation.Result;
 		}
 
-		public CommandResult StartForkedChild ()
+		public CommandResult StartForkedChild (CommandResult result)
 		{
 			engine_stopped = false;
-			CommandResult result = new ThreadCommandResult (thread);
 			current_operation = new OperationStep (this, StepMode.Run, result);
 			PushOperation (new OperationInitAfterFork (this));
 			return result;
diff --git a/test/testsuite/testnativeexec.cs b/test/testsuite/testnativeexec.cs
index 7e975a0..cc11d44 100644
--- a/test/testsuite/testnativeexec.cs
+++ b/test/testsuite/testnativeexec.cs
@@ -202,8 +202,6 @@ namespace Mono.Debugger.Tests
 			AssertExecute ("enable " + bpt_local_waitpid);
 			AssertExecute ("enable " + bpt_child);
 
-			// int bpt_child = AssertBreakpoint ("-global " + LineChild);
-
 			AssertExecute ("continue -bg");
 
 			Thread child = AssertProcessCreated ();
@@ -242,7 +240,7 @@ namespace Mono.Debugger.Tests
 			AssertPrint (child, "pid", "(pid_t) 0");
 
 			AssertExecute ("background -thread " + child.ID);
-			AssertExecute ("continue -wait");
+			AssertExecute ("continue -wait -thread " + thread.ID);
 
 			Thread execd_child = null;
 			bool exited = false;
diff --git a/test/testsuite/testnativefork.cs b/test/testsuite/testnativefork.cs
index fabd337..8986ecc 100644
--- a/test/testsuite/testnativefork.cs
+++ b/test/testsuite/testnativefork.cs
@@ -215,7 +215,7 @@ namespace Mono.Debugger.Tests
 			AssertPrint (child, "pid", "(pid_t) 0");
 
 			AssertExecute ("background -thread " + child.ID);
-			AssertExecute ("continue -wait");
+			AssertExecute ("continue -wait -thread " + thread.ID);
 
 			bool exited = false;
 			bool child_exited = false;

--------------1.5.6--



From 08112691150ccf0cd9f97f7016a52f30217e35e3 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 15 Jul 2009 05:26:36 +0200
Subject: [PATCH] Remove some obsolete code.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs     |    4 +-
 backend/SingleSteppingEngine.cs.new | 4901 -----------------------------------
 frontend/Command.cs                 |   19 +-
 3 files changed, 15 insertions(+), 4909 deletions(-)
 delete mode 100644 backend/SingleSteppingEngine.cs.new
--------------1.5.6
Content-Type: text/x-patch; name="08112691150ccf0cd9f97f7016a52f30217e35e3.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="08112691150ccf0cd9f97f7016a52f30217e35e3.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 7732795..6d200bb 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -553,7 +553,7 @@ namespace Mono.Debugger.Backend
 			if (rti.ID != rti_id)
 				throw new InternalError ("{0} aborting rti failed: {1} {2}", this, rti.ID, rti_id);
 
-			rti.Abort ();
+			rti.AbortInvoke ();
 
 			if (rti.IsSuspended) {
 				InterruptibleOperation io = nested_break_stack.Pop ();
@@ -3913,7 +3913,7 @@ namespace Mono.Debugger.Backend
 			return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
 		}
 
-		public void Abort ()
+		public void AbortInvoke ()
 		{
 			inferior.AbortInvoke (ID);
 			Result.InvocationAborted = true;
diff --git a/backend/SingleSteppingEngine.cs.new b/backend/SingleSteppingEngine.cs.new
deleted file mode 100644
index 3e90643..0000000
--- a/backend/SingleSteppingEngine.cs.new
+++ /dev/null
@@ -1,4901 +0,0 @@
-using System;
-using System.IO;
-using System.Text;
-using System.Threading;
-using System.Configuration;
-using System.Globalization;
-using System.Reflection;
-using System.Diagnostics;
-using System.Collections;
-using System.Collections.Generic;
-using System.Collections.Specialized;
-using System.Runtime.InteropServices;
-using System.Runtime.Serialization;
-using System.Runtime.Remoting.Messaging;
-
-using Mono.Debugger.Languages;
-using Mono.Debugger.Languages.Mono;
-using Mono.Debugger.Architectures;
-
-namespace Mono.Debugger.Backend
-{
-// <summary>
-//   The single stepping engine is responsible for doing all the stepping
-//   operations.
-//
-//     sse                  - short for single stepping engine.
-//
-//     stepping operation   - an operation which has been invoked by the user such
-//                            as StepLine(), NextLine() etc.
-//
-//     atomic operation     - an operation which the sse invokes on the target
-//                            such as stepping one machine instruction or resuming
-//                            the target until a breakpoint is hit.
-//
-//     step frame           - an address range; the sse invokes atomic operations
-//                            until the target hit a breakpoint, received a signal
-//                            or stopped at an address outside this range.
-//
-//     temporary breakpoint - a breakpoint which is automatically removed the next
-//                            time the target stopped; it is used to step over
-//                            method calls.
-//
-//     source stepping op   - stepping operation based on the program's source code,
-//                            such as StepLine() or NextLine().
-//
-//     native stepping op   - stepping operation based on the machine code such as
-//                            StepInstruction() or NextInstruction().
-//
-//   The SingleSteppingEngine supports both synchronous and asynchronous
-//   operations; in synchronous mode, the engine waits until the child has stopped
-//   before returning.  In either case, the step commands return true on success
-//   and false an error.
-//
-//   Since the SingleSteppingEngine can be used from multiple threads at the same
-//   time, you can no longer safely use the `State' property to find out whether
-//   the target is stopped or not.  It is safe to call all the step commands from
-//   multiple threads, but for obvious reasons only one command can run at a
-//   time.  So if you attempt to issue a step command while the engine is still
-//   busy, the step command will return false to signal this error.
-// </summary>
-
-	// <summary>
-	//   The ThreadManager creates one SingleSteppingEngine instance for each thread
-	//   in the target.
-	//
-	//   The `SingleSteppingEngine' class is basically just responsible for whatever happens
-	//   in the background thread: processing commands and events.  Their methods
-	//   are just meant to be called from the SingleSteppingEngine (since it's a
-	//   protected nested class they can't actually be called from anywhere else).
-	//
-	//   See the `Thread' class for the "user interface".
-	// </summary>
-	internal class SingleSteppingEngine : ThreadServant
-	{
-		// <summary>
-		//   This is invoked after compiling a trampoline - it returns whether or
-		//   not we should enter that trampoline.
-		// </summary>
-		internal delegate bool TrampolineHandler (Method method);
-		internal delegate bool CheckBreakpointHandler ();
-
-		protected SingleSteppingEngine (ThreadManager manager, ProcessServant process)
-			: base (manager, process)
-		{
-			Report.Debug (DebugFlags.Threads, "New SSE ({0}): {1}",
-				      DebuggerWaitHandle.CurrentThread, this);
-		}
-
-		public SingleSteppingEngine (ThreadManager manager, ProcessServant process,
-					     ProcessStart start)
-			: this (manager, process)
-		{
-			inferior = Inferior.CreateInferior (manager, process, start);
-
-			if (start.PID != 0) {
-				this.pid = start.PID;
-				inferior.Attach (pid);
-			} else {
-				pid = inferior.Run ();
-			}
-
-			manager.AddEngine (this);
-		}
-
-		public SingleSteppingEngine (ThreadManager manager, ProcessServant process,
-					     Inferior inferior, int pid)
-			: this (manager, process)
-		{
-			this.inferior = inferior;
-			this.pid = pid;
-
-			engine_stopped = true;
-			manager.AddEngine (this);
-		}
-
-		public CommandResult StartApplication (CommandResult result)
-		{
-			engine_stopped = false;
-			current_operation = new OperationStart (this, result);
-			current_operation.Execute ();
-			return result;
-		}
-
-		public void StartExecedChild ()
-		{
-			engine_stopped = false;
-			CommandResult result = new ThreadCommandResult (thread);
-			current_operation = new OperationStart (this, result);
-			current_operation.Execute ();
-		}
-
-		public CommandResult StartThread ()
-		{
-			engine_stopped = false;
-			current_operation = new OperationStep (this, StepMode.Run, new ThreadCommandResult (thread));
-			current_operation.Execute ();
-			return current_operation.Result;
-		}
-
-		public CommandResult StartForkedChild ()
-		{
-			engine_stopped = false;
-			CommandResult result = new ThreadCommandResult (thread);
-			current_operation = new OperationStep (this, StepMode.Run, result);
-			PushOperation (new OperationInitAfterFork (this));
-			return result;
-		}
-
-#region child event processing
-		// <summary>
-		//   This is called from the SingleSteppingEngine's main event loop to give
-		//   us the next event - `status' has no meaning to us, it's just meant to
-		//   be passed to inferior.ProcessEvent() to get the actual event.
-		// </summary>
-		// <remarks>
-		//   Actually, `status' is the waitpid() status code.  In Linux 2.6.x, you
-		//   can call waitpid() from any thread in the debugger, but we need to get
-		//   the target's registers to find out whether it's a breakpoint etc.
-		//   That's done in inferior.ProcessEvent() - which must always be called
-		//   from the engine's thread.
-		// </remarks>
-		public void ProcessEvent (int status)
-		{
-			if (inferior == null)
-				return;
-
-			ProcessEvent (inferior.ProcessEvent (status));
-		}
-
-		public bool ProcessEvent (Inferior.ChildEvent cevent)
-		{
-			Report.Debug (DebugFlags.EventLoop, "{0} received event {1}",
-				      this, cevent);
-
-			if (killed) {
-				if (cevent.Type == Inferior.ChildEventType.CHILD_INTERRUPTED) {
-					inferior.Continue ();
-					return true;
-				} else if (cevent.Type != Inferior.ChildEventType.CHILD_EXITED) {
-					Report.Debug (DebugFlags.EventLoop,
-						      "{0} received event {1} when already killed",
-						      this, cevent);
-					return true;
-				}
-			}
-
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_EXITED) ||
-			    (cevent.Type == Inferior.ChildEventType.CHILD_SIGNALED)) {
-				Report.Debug (DebugFlags.SSE, "{0} received {1}", this, cevent);
-				// we can't remove the breakpoint anymore after
-				// the target exited, but we need to clear this id.
-				temp_breakpoint = null;
-				dead = true;
-			} else {
-				string frame_text = "";
-				Inferior.StackFrame iframe = inferior.GetCurrentFrame (true);
-				if (iframe != null)
-					frame_text = "at " + iframe.Address.ToString ();
-
-				string running_text;
-				if (HasThreadLock)
-					running_text = String.Format ("being thread-locked ({0})", thread_lock);
-				else
-					running_text = String.Format ("running {0}", current_operation);
-
-				string event_text;
-				if (cevent.Type == Inferior.ChildEventType.CHILD_NOTIFICATION)
-					event_text = String.Format ("notification {0} ({1})", cevent, (NotificationType) cevent.Argument);
-				else
-					event_text = "event " + cevent.ToString ();
-
-				Report.Debug (DebugFlags.EventLoop, "{0} received {1} {2} while {3}",
-					      this, event_text, frame_text, running_text);
-
-				if (HasThreadLock) {
-					thread_lock.SetStopEvent (cevent);
-					return false;
-				}
-			}
-
-			if (ProcessServant.IsAttached && !attach_initialized) {
-				attach_initialized = true;
-
-				if (cevent.Type == Inferior.ChildEventType.CHILD_INTERRUPTED)
-					cevent = new Inferior.ChildEvent (Inferior.ChildEventType.CHILD_STOPPED, 0, 0, 0);
-			}
-
-			bool resume_target;
-			if (manager.HandleChildEvent (this, inferior, ref cevent, out resume_target)) {
-				Report.Debug (DebugFlags.EventLoop,
-					      "{0} done handling event: {1}{2}{3}{4}",
-					      this, cevent, resume_target ? " resume-target" : "" ,
-					      stop_requested ? " stop-requested" : "",
-					      HasThreadLock ? " thread-lock" : "");
-				if (stop_requested) {
-					OperationInterrupted ();
-				} else if (resume_target) {
-					if (!current_operation.ResumeOperation ())
-						inferior.Continue ();
-				}
-				return true;
-			}
-
-			Inferior.ChildEventType message = cevent.Type;
-			int arg = (int) cevent.Argument;
-
-			switch (message) {
-			case Inferior.ChildEventType.CHILD_INTERRUPTED:
-				OperationInterrupted ();
-				return true;
-			case Inferior.ChildEventType.CHILD_SIGNALED:
-				if (killed)
-					OperationCompleted (new TargetEventArgs (TargetEventType.TargetExited, 0));
-				else
-					OperationCompleted (new TargetEventArgs (TargetEventType.TargetSignaled, arg));
-				return true;
-
-			case Inferior.ChildEventType.CHILD_EXITED:
-				OperationCompleted (new TargetEventArgs (TargetEventType.TargetExited, arg));
-				return true;
-
-			case Inferior.ChildEventType.CHILD_CALLBACK_COMPLETED:
-				frame_changed (inferior.CurrentFrame, null);
-				OperationCompleted (new TargetEventArgs (TargetEventType.TargetStopped, 0, current_frame));
-				return true;
-
-			case Inferior.ChildEventType.RUNTIME_INVOKE_DONE:
-				OperationRuntimeInvoke rti = rti_stack.Pop ();
-				if (rti.ID != cevent.Argument)
-					throw new InternalError ("{0} got unknown RUNTIME_INVOKE_DONE: {1} {2}", this, rti.ID, cevent);
-
-				frame_changed (inferior.CurrentFrame, null);
-				rti.Completed (cevent.Data1, cevent.Data2);
-
-				if (rti.IsSuspended) {
-					InterruptibleOperation io = nested_break_stack.Pop ();
-					if (io != rti)
-						throw new InternalError ("{0} unexpected item on nested break state stack: {1}", this, io);
-					process.OnLeaveNestedBreakState (this);
-				}
-
-				if (current_operation != rti)
-					current_operation.Result.Completed ();
-				current_operation = rti;
-
-				TargetEventArgs args = rti.OperationCompleted (current_frame, false);
-				OperationCompleted (args);
-				return true;
-			}
-
-			if (stop_requested) {
-				switch (message) {
-				case Inferior.ChildEventType.CHILD_STOPPED:
-				case Inferior.ChildEventType.CHILD_CALLBACK:
-				case Inferior.ChildEventType.CHILD_HIT_BREAKPOINT:
-					OperationInterrupted ();
-					return true;
-
-				case Inferior.ChildEventType.UNHANDLED_EXCEPTION:
-				case Inferior.ChildEventType.THROW_EXCEPTION:
-				case Inferior.ChildEventType.HANDLE_EXCEPTION:
-				case Inferior.ChildEventType.CHILD_NOTIFICATION:
-					inferior.RestartNotification ();
-					OperationInterrupted ();
-					return true;
-
-				default:
-					OperationInterrupted ();
-					return false;
-				}
-			}
-
-			DoProcessEvent (cevent);
-			return true;
-		}
-
-		protected void DoProcessEvent (Inferior.ChildEvent cevent)
-		{
-			Inferior.ChildEventType message = cevent.Type;
-			int arg = (int) cevent.Argument;
-
-			if (message == Inferior.ChildEventType.THROW_EXCEPTION) {
-				TargetAddress info = new TargetAddress (inferior.AddressDomain, cevent.Data1);
-				TargetAddress ip = new TargetAddress (manager.AddressDomain, cevent.Data2);
-
-				Report.Debug (DebugFlags.EventLoop,
-					      "{0} received exception: {1} {2} {3}", this, message, info, ip);
-
-				TargetAddress stack = inferior.ReadAddress (info);
-				TargetAddress exc = inferior.ReadAddress (info + inferior.TargetAddressSize);
-
-				ExceptionAction action = throw_exception (stack, exc, ip);
-
-				Report.Debug (DebugFlags.SSE,
-					      "{0} throw exception ({1}:{2}:{3}) - {4} - {5} - {6}",
-					      this, stack, exc, ip, action, current_operation, temp_breakpoint);
-
-				switch (action) {
-				case ExceptionAction.None:
-					do_continue ();
-					return;
-
-				case ExceptionAction.Stop:
-					inferior.WriteInteger (info + 2 * inferior.TargetAddressSize, 1);
-					PushOperation (new OperationException (this, ip, exc, false));
-					return;
-
-				case ExceptionAction.StopUnhandled:
-					if (!check_runtime_version (81, 1) && !check_runtime_version (80, 1))
-						goto case ExceptionAction.Stop;
-					inferior.WriteInteger (info + 4 + 2 * inferior.TargetAddressSize, 1);
-					do_continue ();
-					return;
-				}
-			}
-
-			if (message == Inferior.ChildEventType.HANDLE_EXCEPTION) {
-				TargetAddress info = new TargetAddress (inferior.AddressDomain, cevent.Data1);
-				TargetAddress ip = new TargetAddress (manager.AddressDomain, cevent.Data2);
-
-				Report.Debug (DebugFlags.EventLoop,
-					      "{0} received exception: {1} {2} {3}", this, message, info, ip);
-
-				TargetAddress stack = inferior.ReadAddress (info);
-				TargetAddress exc = inferior.ReadAddress (info + inferior.TargetAddressSize);
-
-				bool stop = handle_exception (stack, exc, ip);
-
-				Report.Debug (DebugFlags.SSE,
-					      "{0} {1}stopping at exception handler ({2}:{3}:{4}) - {4} - {5}",
-					      this, stop ? "" : "not ", stack, exc, ip, current_operation, temp_breakpoint);
-
-				if (stop) {
-					inferior.WriteInteger (info + 2 * inferior.TargetAddressSize, 1);
-					PushOperation (new OperationException (this, ip, exc, false));
-					return;
-				}
-
-				do_continue ();
-				return;
-			}
-
-
-			if (lmf_breakpoint != null) {
-				if ((message == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) &&
-				    (arg == lmf_breakpoint.Breakpoint.ID)) {
-					remove_lmf_breakpoint ();
-
-					Report.Debug (DebugFlags.SSE, "{0} back in managed land: {1}",
-						      this, inferior.CurrentFrame);
-
-					Method method = Lookup (inferior.CurrentFrame);
-
-					bool is_managed = (method != null) && method.Module.Language.IsManaged;
-					Report.Debug (DebugFlags.SSE, "{0} back in managed land #1: {1}", this, is_managed);
-
-					Queue<ManagedCallbackData> queue = process.MonoManager.ClearManagedCallbacks (inferior);
-					OnManagedCallback (queue);
-					return;
-				}
-			}
-
-			// To step over a method call, the sse inserts a temporary
-			// breakpoint immediately after the call instruction and then
-			// resumes the target.
-			//
-			// If the target stops and we have such a temporary breakpoint, we
-			// need to distinguish a few cases:
-			//
-			// a) we may have received a signal
-			// b) we may have hit another breakpoint
-			// c) we actually hit the temporary breakpoint
-			//
-			// In either case, we need to remove the temporary breakpoint if
-			// the target is to remain stopped.  Note that this piece of code
-			// here only deals with the temporary breakpoint, the handling of
-			// a signal or another breakpoint is done later.
-			if ((temp_breakpoint != null) &&
-			    (message == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) && (arg == temp_breakpoint.ID)) {
-				// we hit the temporary breakpoint; this'll always
-				// happen in the `correct' thread since the
-				// `temp_breakpoint_id' is only set in this
-				// SingleSteppingEngine and not in any other thread's.
-
-				remove_temporary_breakpoint ();
-
-				Breakpoint bpt = lookup_breakpoint (arg);
-				Report.Debug (DebugFlags.SSE,
-					      "{0} hit temporary breakpoint {1} at {2} {3}",
-					      this, arg, inferior.CurrentFrame, bpt);
-				if ((bpt == null) || !bpt.Breaks (thread.ID) || bpt.HideFromUser) {
-					message = Inferior.ChildEventType.CHILD_STOPPED;
-					arg = 0;
-					cevent = new Inferior.ChildEvent (Inferior.ChildEventType.CHILD_STOPPED, 0, 0, 0);
-				} else {
-					ProcessOperationEvent (cevent);
-					return;
-				}
-			}
-
-			if (message == Inferior.ChildEventType.UNHANDLED_EXCEPTION) {
-				TargetAddress exc = new TargetAddress (manager.AddressDomain, cevent.Data1);
-				TargetAddress ip = new TargetAddress (manager.AddressDomain, cevent.Data2);
-				PushOperation (new OperationException (this, ip, exc, true));
-				return;
-			} else if (message == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) {
-				// Ok, the next thing we need to check is whether this is actually "our"
-				// breakpoint or whether it belongs to another thread.  In this case,
-				// `step_over_breakpoint' does everything for us and we can just continue
-				// execution.
-				Breakpoint bpt;
-				bool remain_stopped = child_breakpoint (cevent, arg, out bpt);
-				if (!remain_stopped) {
-					do_continue ();
-					return;
-				}
-			}
-
-			ProcessOperationEvent (cevent);
-		}
-
-		protected void ProcessOperationEvent (Inferior.ChildEvent cevent)
-		{
-			TargetEventArgs result = null;
-
-			Inferior.ChildEventType message = cevent.Type;
-			int arg = (int) cevent.Argument;
-
-			//
-			// Sometimes, we need to do just one atomic operation - in all
-			// other cases, `current_operation' is the current stepping
-			// operation.
-			//
-			// ProcessEvent() will either start another atomic operation
-			// (and return false) or tell us the stepping operation is
-			// completed by returning true.
-			//
-
-			if (current_operation == null)
-				throw new InternalError ("SSE {0} has no current operation, but received event {1}", this, cevent);
-
-			Report.Debug (DebugFlags.EventLoop, "{0} process operation event: {1} {2}", this, current_operation, cevent);
-
-			Operation.EventResult status = current_operation.ProcessEvent (cevent, out result);
-
-			Report.Debug (DebugFlags.EventLoop, "{0} processed operation event: {1} {2} {3} {4}", this,
-				      current_operation, cevent, status, result);
-
-			switch (status) {
-			case Operation.EventResult.Running:
-				return;
-
-			case Operation.EventResult.Completed:
-			case Operation.EventResult.SuspendOperation: {
-				Operation.EventResult new_status = current_operation.CompletedOperation (cevent, status, ref result);
-				if (new_status == Operation.EventResult.Running)
-					return;
-				else if (new_status == Operation.EventResult.Completed)
-					OperationCompleted (result);
-				else if (new_status == Operation.EventResult.SuspendOperation)
-					OperationCompleted (result, true);
-				else
-					throw new InternalError ("Got unexpected event result: {0}", new_status);
-
-				return;
-			}
-
-			case Operation.EventResult.ResumeOperation:
-				if (current_operation.ResumeOperation ())
-					return;
-				status = Operation.EventResult.Completed;
-				goto case Operation.EventResult.Completed;
-
-			default:
-				throw new InternalError ("Got unexpected event result: {0}", status);
-			}
-		}
-
-		bool check_runtime_version (int major, int minor)
-		{
-			if (MonoDebuggerInfo.MajorVersion < major)
-				return false;
-			if (MonoDebuggerInfo.MajorVersion > major)
-				return true;
-			return MonoDebuggerInfo.MinorVersion >= minor;
-		}
-
-#endregion
-
-		void OperationInterrupted ()
-		{
-			frame_changed (inferior.CurrentFrame, null);
-
-			long abort_rti = -1;
-			lock (this) {
-				abort_rti = abort_requested;
-				abort_requested = -1;
-			}
-			Report.Debug (DebugFlags.SSE, "{0} operation interrupted: {1} - {2}", this, abort_rti, current_frame);
-			if (abort_rti >= 0) {
-				DoAbortInvocation (abort_rti);
-			} else {
-				OperationCompleted (new TargetEventArgs (TargetEventType.TargetInterrupted, 0, current_frame));
-			}
-		}
-
-		OperationRuntimeInvoke AbortRuntimeInvoke (long rti_id)
-		{
-			OperationRuntimeInvoke rti = rti_stack.Pop ();
-			if (rti.ID != rti_id)
-				throw new InternalError ("{0} aborting rti failed: {1} {2}", this, rti.ID, rti_id);
-
-			rti.Abort ();
-
-			if (rti.IsSuspended) {
-				InterruptibleOperation io = nested_break_stack.Pop ();
-				if (io != rti)
-					throw new InternalError ("{0} aborting rti failed: {1}", this, io);
-				process.OnLeaveNestedBreakState (this);
-			}
-
-			return rti;
-		}
-
-		void OperationCompleted (TargetEventArgs result)
-		{
-			OperationCompleted (result, false);
-		}
-
-		void OperationCompleted (TargetEventArgs result, bool suspended)
-		{
-			lock (this) {
-				remove_temporary_breakpoint ();
-				engine_stopped = true;
-				stop_requested = false;
-				last_target_event = result;
-
-				process.OperationCompleted (this, result);
-
-				operation_completed_event.Set ();
-
-				Report.Debug (DebugFlags.EventLoop, "{0} {1} operation {2}: {3}",
-					      this, suspended ? "suspending" : "terminating", current_operation, result);
-
-				if (suspended) {
-					process.OnEnterNestedBreakState (this);
-					((InterruptibleOperation) current_operation).IsSuspended = true;
-					nested_break_stack.Push ((InterruptibleOperation) current_operation);
-					current_operation.CompletedOperation (true);
-					current_operation = null;
-				} else {
-					if (current_operation != null) {
-						Report.Debug (DebugFlags.EventLoop, "{0} setting completed: {1} {2}",
-							      this, current_operation, current_operation.Result);
-						current_operation.CompletedOperation (false);
-						current_operation = null;
-					}
-				}
-			}
-		}
-
-		internal void OnManagedThreadCreated (TargetAddress end_stack_address)
-		{
-			this.end_stack_address = end_stack_address;
-		}
-
-		internal void SetTID (long tid)
-		{
-			this.tid = tid;
-		}
-
-		internal void SetManagedThreadData (TargetAddress lmf_address,
-						    TargetAddress extended_notifications_addr)
-		{
-			this.lmf_address = lmf_address;
-			this.extended_notifications_addr = extended_notifications_addr;
-		}
-
-		internal void SetMainReturnAddress (TargetAddress main_ret)
-		{
-			if(main_ret.IsNull)
-				this.main_retaddr = TargetAddress.Null;
-			else
-			{
-				this.main_retaddr = main_ret + inferior.TargetAddressSize;
-				this.reached_main = true;
-			}
-		}
-
-		internal void OnManagedThreadExited ()
-		{
-			this.end_stack_address = TargetAddress.Null;
-			process.OnManagedThreadExitedEvent (this);
-		}
-
-		internal void OnThreadExited (Inferior.ChildEvent cevent)
-		{
-			TargetEventArgs result;
-			int arg = (int) cevent.Argument;
-			if (killed)
-				result = new TargetEventArgs (TargetEventType.TargetExited, 0);
-			else if (cevent.Type == Inferior.ChildEventType.CHILD_SIGNALED)
-				result = new TargetEventArgs (TargetEventType.TargetSignaled, arg);
-			else
-				result = new TargetEventArgs (TargetEventType.TargetExited, arg);
-			temp_breakpoint = null;
-			OperationCompleted (result);
-
-			process.OnThreadExitedEvent (this);
-			Dispose ();
-		}
-
-		Breakpoint lookup_breakpoint (int index)
-		{
-			BreakpointHandle handle = process.BreakpointManager.LookupBreakpoint (index);
-			if (handle == null)
-				return null;
-
-			return handle.Breakpoint;
-		}
-
-		void set_registers (Registers registers)
-		{
-			if (!registers.FromCurrentFrame)
-				throw new InvalidOperationException ();
-
-			this.registers = registers;
-			inferior.SetRegisters (registers);
-		}
-
-		// <summary>
-		//   Start a new stepping operation.
-		//
-		//   All stepping operations are done asynchronously.
-		//
-		//   The inferior basically just knows two kinds of stepping operations:
-		//   there is do_continue() to continue execution (until a breakpoint is
-		//   hit or the target receives a signal or exits) and there is do_step_native()
-		//   to single-step one machine instruction.  There's also a version of
-		//   do_continue() which takes an address - it inserts a temporary breakpoint
-		//   on that address and calls do_continue().
-		//
-		//   Let's call these "atomic operations" while a "stepping operation" is
-		//   something like stepping until the next source line.  We normally need to
-		//   do several atomic operations for each stepping operation.
-		//
-		//   We start a new stepping operation here, but what we actually do is
-		//   starting an atomic operation on the target.  Note that we just start it,
-		//   but don't wait until is completed.  Once the target is running, we go
-		//   back to the main event loop and wait for it (or another thread) to stop
-		//   (or to get another command from the user).
-		// </summary>
-		void StartOperation ()
-		{
-			lock (this) {
-				Report.Debug (DebugFlags.SSE, "{0} start operation: {1} {2}",
-					      this, engine_stopped, HasThreadLock);
-
-				if (!engine_stopped || HasThreadLock) {
-					Report.Debug (DebugFlags.Wait, "{0} not stopped: {1} {2}",
-						      this, engine_stopped, HasThreadLock);
-					throw new TargetException (TargetError.NotStopped);
-				}
-
-				engine_stopped = false;
-				last_target_event = null;
-				operation_completed_event.Reset ();
-			}
-		}
-
-		object SendCommand (TargetAccessDelegate target)
-		{
-			if (inferior == null)
-				throw new TargetException (TargetError.NoTarget);
-
-			if (ThreadManager.InBackgroundThread)
-				return target (thread, null);
-			else
-				return manager.SendCommand (this, target, null);
-		}
-
-		CommandResult StartOperation (Operation operation)
-		{
-			StartOperation ();
-
-			return (CommandResult) SendCommand (delegate {
-				return ProcessOperation (operation);
-			});
-		}
-
-		CommandResult ProcessOperation (Operation operation)
-		{
-			Report.Debug (DebugFlags.SSE,  "{0} starting {1}", this, operation);
-			PushOperation (operation);
-			return operation.Result;
-		}
-
-		void PushOperation (Operation operation)
-		{
-			if (current_operation != null)
-				current_operation.PushOperation (operation);
-			else
-				current_operation = operation;
-			ExecuteOperation (operation);
-		}
-
-		void ExecuteOperation (Operation operation)
-		{
-			try {
-				check_inferior ();
-
-				InterruptibleOperation iop = operation as InterruptibleOperation;
-				if ((iop != null) && iop.IsSuspended) {
-					iop.IsSuspended = false;
-					do_continue ();
-					return;
-				} else {
-					operation.Execute ();
-				}
-			} catch (Exception ex) {
-				Report.Debug (DebugFlags.SSE, "{0} caught exception while " +
-					      "processing operation {1}: {2}", this, operation, ex);
-				operation.Result.Result = ex;
-				OperationCompleted (null);
-			}
-		}
-
-		public override TargetEventArgs LastTargetEvent {
-			get { return last_target_event; }
-		}
-
-		public override Method Lookup (TargetAddress address)
-		{
-			process.UpdateSymbolTable (inferior);
-			Method method = process.SymbolTableManager.Lookup (address);
-			Report.Debug (DebugFlags.JitSymtab, "{0} lookup {1}: {2}",
-				      this, address, method);
-			return method;
-		}
-
-		public override Symbol SimpleLookup (TargetAddress address, bool exact_match)
-		{
-			return process.SymbolTableManager.SimpleLookup (address, exact_match);
-		}
-
-#region public properties
-		internal Inferior Inferior {
-			get { return inferior; }
-		}
-
-		internal override Architecture Architecture {
-			get { return inferior.Architecture; }
-		}
-
-		public Thread Thread {
-			get { return thread; }
-		}
-
-		public override int PID {
-			get { return pid; }
-		}
-
-		public override long TID {
-			get { return tid; }
-		}
-
-		public override bool IsAlive {
-			get { return !dead && !killed && (inferior != null); }
-		}
-
-		public override TargetAddress LMFAddress {
-			get { return lmf_address; }
-		}
-
-		public override bool CanRun {
-			get { return true; }
-		}
-
-		public override bool CanStep {
-			get { return true; }
-		}
-
-		public override bool IsStopped {
-			get { return engine_stopped; }
-		}
-
-		public override WaitHandle WaitHandle {
-			get { return operation_completed_event; }
-		}
-
-		internal override ProcessServant ProcessServant {
-			get { return process; }
-		}
-
-		internal override ThreadManager ThreadManager {
-			get { return manager; }
-		}
-
-		public override Backtrace CurrentBacktrace {
-			get { return current_backtrace; }
-		}
-
-		public override StackFrame CurrentFrame {
-			get { return current_frame; }
-		}
-
-		public override Method CurrentMethod {
-			get { return current_method; }
-		}
-
-		public override TargetAddress CurrentFrameAddress {
-			get { return inferior.CurrentFrame; }
-		}
-
-		protected MonoDebuggerInfo MonoDebuggerInfo {
-			get { return process.MonoManager.MonoDebuggerInfo; }
-		}
-
-		public override TargetState State {
-			get {
-				if (inferior == null)
-					return TargetState.NoTarget;
-				else if (HasThreadLock)
-					return TargetState.Busy;
-				else
-					return inferior.State;
-			}
-		}
-#endregion
-
-		internal bool HasThreadLock {
-			get { return thread_lock != null; }
-		}
-
-		protected TargetAddress EndStackAddress {
-			get { return end_stack_address; }
-		}
-
-		public override TargetMemoryInfo TargetMemoryInfo {
-			get {
-				check_inferior ();
-				return inferior.TargetMemoryInfo;
-			}
-		}
-
-		public override TargetMemoryArea[] GetMemoryMaps ()
-		{
-			check_inferior ();
-			return inferior.GetMemoryMaps ();
-		}
-
-		public override void Kill ()
-		{
-			killed = true;
-			SendCommand (delegate {
-				Inferior.ChildEvent stop_event;
-				Report.Debug (DebugFlags.SSE, "{0} kill: {1}", this, engine_stopped);
-				if (!engine_stopped) {
-					bool stopped = inferior.Stop (out stop_event);
-					Report.Debug (DebugFlags.SSE, "{0} kill #1: {1} {2} {3}",
-						      this, engine_stopped, stopped, stop_event);
-				}
-				inferior.Kill ();
-				Report.Debug (DebugFlags.SSE, "{0} kill #2", this);
-				return null;
-			});
-		}
-
-		public void SetKilledFlag ()
-		{
-			killed = true;
-		}
-
-		internal override object DoTargetAccess (TargetAccessHandler func)
-		{
-			return SendCommand (delegate {
-				return func (inferior);
-			});
-		}
-
-		public override void Detach ()
-		{
-			SendCommand (delegate {
-				if (!engine_stopped) {
-					Report.Debug (DebugFlags.Wait,
-						      "{0} not stopped", this);
-					throw new TargetException (TargetError.NotStopped);
-				}
-
-				process.AcquireGlobalThreadLock (this);
-				process.BreakpointManager.RemoveAllBreakpoints (inferior);
-
-				if (process.MonoManager != null)
-					process.MonoManager.Detach (inferior);
-				DoDetach ();
-
-				process.DropGlobalThreadLock ();
-				return null;
-			});
-		}
-
-		protected void DoDetach ()
-		{
-			foreach (ThreadServant servant in process.ThreadServants)
-				servant.DetachThread ();
-		}
-
-		internal override void DetachThread ()
-		{
-			if (inferior != null) {
-				inferior.Detach ();
-				inferior.Dispose ();
-				inferior = null;
-			}
-
-			OperationCompleted (new TargetEventArgs (TargetEventType.TargetExited, 0));
-			process.OnThreadExitedEvent (this);
-			Dispose ();
-		}
-
-		public override void Stop ()
-		{
-			lock (this) {
-				Report.Debug (DebugFlags.EventLoop, "{0} interrupt: {1} {2}",
-					      this, engine_stopped, current_operation);
-
-				if (engine_stopped)
-					return;
-
-				bool stopped = inferior.Stop ();
-				if (!Inferior.HasThreadEvents && !stopped)
-					OperationInterrupted ();
-				
-				Report.Debug (DebugFlags.EventLoop, "{0} interrupt #1: {1}",
-					      this, stopped);
-			}
-		}
-
-		protected void check_inferior ()
-		{
-			if (inferior == null)
-				throw new TargetException (TargetError.NoTarget);
-		}
-
-		// <summary>
-		//   A breakpoint has been hit; now the sse needs to find out what do do:
-		//   either ignore the breakpoint and continue or keep the target stopped
-		//   and send out the notification.
-		//
-		//   If @index is zero, we hit an "unknown" breakpoint - ie. a
-		//   breakpoint which we did not create.  Normally, this means that there
-		//   is a breakpoint instruction (such as G_BREAKPOINT ()) in the code.
-		//   Such unknown breakpoints are handled by the Debugger; one of
-		//   the language backends may recognize the breakpoint's address, for
-		//   instance if this is the JIT's breakpoint trampoline.
-		//
-		//   Returns true if the target should remain stopped and false to
-		//   continue stepping.
-		//
-		//   If we can't find a handler for the breakpoint, the default is to stop
-		//   the target and let the user decide what to do.
-		// </summary>
-		bool child_breakpoint (Inferior.ChildEvent cevent, int index, out Breakpoint bpt)
-		{
-			// The inferior knows about breakpoints from all threads, so if this is
-			// zero, then no other thread has set this breakpoint.
-			if (index == 0) {
-				bpt = null;
-				return true;
-			}
-
-			bpt = lookup_breakpoint (index);
-			if ((bpt == null) || !bpt.Breaks (thread.ID))
-				return false;
-
-			if (!process.BreakpointManager.IsBreakpointEnabled (index))
-				return false;
-
-			index = bpt.Index;
-
-			bool remain_stopped;
-			if (bpt.BreakpointHandler (inferior, out remain_stopped))
-				return remain_stopped;
-
-			TargetAddress address = inferior.CurrentFrame;
-			return bpt.CheckBreakpointHit (thread, address);
-		}
-
-		bool step_over_breakpoint (bool singlestep, TargetAddress until)
-		{
-			int index;
-			bool is_enabled;
-			process.BreakpointManager.LookupBreakpoint (
-				inferior.CurrentFrame, out index, out is_enabled);
-
-			if ((index == 0) || !is_enabled)
-				return false;
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} stepping over breakpoint {1} at {2} until {3}",
-				      this, index, inferior.CurrentFrame, until);
-
-			Instruction instruction = inferior.Architecture.ReadInstruction (
-				inferior, inferior.CurrentFrame);
-
-			if ((instruction == null) || !instruction.HasInstructionSize ||
-			    !process.CanExecuteCode) {
-				PushOperation (new OperationStepOverBreakpoint (this, index, until));
-				return true;
-			}
-
-			if (instruction.InterpretInstruction (inferior)) {
-				if (!singlestep)
-					return false;
-
-				byte[] nop_insn = Architecture.Opcodes.GenerateNopInstruction ();
-				PushOperation (new OperationExecuteInstruction (this, nop_insn, false));
-				return true;
-			}
-
-			if (instruction.IsIpRelative) {
-				PushOperation (new OperationStepOverBreakpoint (this, index, until));
-				return true;
-			}
-
-			PushOperation (new OperationExecuteInstruction (this, instruction.Code, true));
-			return true;
-		}
-
-		void enable_extended_notification (NotificationType type)
-		{
-			long notifications = inferior.ReadLongInteger (extended_notifications_addr);
-			notifications |= (uint) type;
-			inferior.WriteLongInteger (extended_notifications_addr, notifications);
-		}
-
-		void disable_extended_notification (NotificationType type)
-		{
-			long notifications = inferior.ReadLongInteger (extended_notifications_addr);
-			notifications &= ~(long) type;
-			inferior.WriteLongInteger (extended_notifications_addr, notifications);
-		}
-
-		ExceptionAction throw_exception (TargetAddress stack, TargetAddress exc, TargetAddress ip)
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} throwing exception {1} at {2} / {3} while running {4}", this, exc, ip,
-				      stack, current_operation);
-
-			OperationRuntimeInvoke rti = current_operation as OperationRuntimeInvoke;
-			if ((rti != null) && !rti.NestedBreakStates)
-				return ExceptionAction.None;
-
-			TargetObject exc_obj = process.MonoLanguage.CreateObject (inferior, exc);
-			if (exc_obj == null)
-				return ExceptionAction.None; // OOOPS
-
-			Report.Debug (DebugFlags.SSE, "{0} throwing exception: {1}", this, exc_obj.Type.Name);
-
-			ExceptionAction action;
-			if (process.Client.GenericExceptionCatchPoint (exc_obj.Type.Name, out action)) {
-				Report.Debug (DebugFlags.SSE,
-					      "{0} generic exception catchpoint: {1}", this, action);
-				return action;
-			}
-
-			foreach (ExceptionCatchPoint handle in process.ExceptionCatchPoints) {
-				Report.Debug (DebugFlags.SSE,
-					      "{0} invoking exception handler {1} for {0}",
-					      this, handle.Name, exc);
-
-				if (!handle.CheckException (process.MonoLanguage, inferior, exc))
-					continue;
-
-				return handle.Unhandled ? ExceptionAction.StopUnhandled : ExceptionAction.Stop;
-			}
-
-			return ExceptionAction.None;
-		}
-
-		bool handle_exception (TargetAddress stack, TargetAddress exc, TargetAddress ip)
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} handling exception {1} at {2} while running {3}", this, exc, ip,
-				      current_operation);
-
-			if (current_operation == null)
-				return true;
-
-			return current_operation.HandleException (stack, exc);
-		}
-
-		// <summary>
-		//   Check whether @address is inside @frame.
-		// </summary>
-		bool is_in_step_frame (StepFrame frame, TargetAddress address)
-                {
-			if (address.IsNull || frame.Start.IsNull)
-				return false;
-
-                        if ((address < frame.Start) || (address >= frame.End))
-                                return false;
-
-                        return true;
-                }
-
-		// <summary>
-		//   This is called when a stepping operation is completed or something
-		//   unexpected happened (received signal etc.).
-		//
-		//   Normally, we just compute the new StackFrame here, but we may also
-		//   discover that we need to do one more stepping operation, see
-		//   check_method_operation().
-		// </summary>
-		Operation frame_changed (TargetAddress address, Operation operation)
-		{
-			// Mark the current stack frame and backtrace as invalid.
-			frames_invalid ();
-
-			bool same_method = false;
-
-			// Only do a method lookup if we actually need it.
-			if ((current_method != null) &&
-			    Method.IsInSameMethod (current_method, address))
-				same_method = true;
-			else
-				current_method = Lookup (address);
-
-			// If some clown requested a backtrace while doing the symbol lookup ....
-			frames_invalid ();
-
-			Inferior.StackFrame iframe = inferior.GetCurrentFrame ();
-			registers = inferior.GetRegisters ();
-
-			if ((operation != null) && !main_retaddr.IsNull && (iframe.StackPointer >= main_retaddr))
-				return new OperationStep (this, StepMode.Run, operation.Result);
-
-			// Compute the current stack frame.
-			if ((current_method != null) && current_method.HasLineNumbers) {
-				Block block = current_method.LookupBlock (inferior, address);
-				if (block != null) {
-					if (block.BlockType == Block.Type.IteratorDispatcher)
-						return new OperationStepIterator (
-							this, current_method, operation.Result);
-					else if (block.BlockType == Block.Type.CompilerGenerated)
-						return new OperationStepCompilerGenerated (
-							this, current_method, block, operation.Result);
-				}
-
-				SourceAddress source = current_method.LineNumberTable.Lookup (address);
-
-				if (!same_method) {
-					// If check_method_operation() returns true, it already
-					// started a stepping operation, so the target is
-					// currently running.
-					Operation new_operation = check_method_operation (
-						address, current_method, source, operation);
-					if (new_operation != null)
-						return new_operation;
-				}
-
-				if (source != null)
-					update_current_frame (new StackFrame (
-						thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
-						iframe.FrameAddress, registers, current_method, source));
-				else
-					update_current_frame (new StackFrame (
-						thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
-						iframe.FrameAddress, registers, current_method));
-			} else {
-				if (!same_method && (current_method != null)) {
-					Operation new_operation = check_method_operation (
-						address, current_method, null, operation);
-					if (new_operation != null)
-						return new_operation;
-				}
-
-				if (current_method != null)
-					update_current_frame (new StackFrame (
-						thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
-						iframe.FrameAddress, registers, current_method));
-				else {
-					Symbol name;
-					try {
-						name = SimpleLookup (address, false);
-					} catch {
-						name = null;
-					}
-					update_current_frame (new StackFrame (
-						thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
-						iframe.FrameAddress, registers, thread.NativeLanguage,
-						name));
-				}
-			}
-
-			return null;
-		}
-
-		// <summary>
-		//   Checks whether to do a "method operation".
-		//
-		//   This is only used while doing a source stepping operation and ensures
-		//   that we don't stop somewhere inside a method's prologue code or
-		//   between two source lines.
-		// </summary>
-		Operation check_method_operation (TargetAddress address, Method method,
-						  SourceAddress source, Operation operation)
-		{
-			// Do nothing if this is not a source stepping operation.
-			if ((operation == null) || !operation.IsSourceOperation)
-				return null;
-
-			if (method.WrapperType != WrapperType.None)
-				return new OperationWrapper (this, method, operation.Result);
-			if (method.IsIterator)
-				return new OperationStepIterator (this, method, operation.Result);
-
-			Language language = method.Module.Language;
-			if (source == null)
-				return null;
-
-			if ((source.LineOffset > 0) && (source.LineRange > 0)) {
-				// We stopped between two source lines.  This normally
-				// happens when returning from a method call; in this
-				// case, we need to continue stepping until we reach the
-				// next source line.
-				StepFrame sframe = new StepFrame (
-					language, StepMode.SourceLine, null,
-					address - source.LineOffset, address + source.LineRange);
-				return new OperationStep (this, sframe, operation.Result);
-			}
-
-			LineNumberTable lnt = method.LineNumberTable;
-			if (lnt.HasMethodBounds && (address < lnt.MethodStartAddress)) {
-				StepFrame sframe = new StepFrame (
-					null, StepMode.Finish, null,
-					method.StartAddress, lnt.MethodStartAddress);
-				return new OperationStep (this, sframe, operation.Result);
-			} else if (method.HasMethodBounds && (address < method.MethodStartAddress)) {
-				// Do not stop inside a method's prologue code, but stop
-				// immediately behind it (on the first instruction of the
-				// method's actual code).
-				StepFrame sframe = new StepFrame (
-					null, StepMode.Finish, null,
-					method.StartAddress, method.MethodStartAddress);
-				return new OperationStep (this, sframe, operation.Result);
-			}
-
-			return null;
-		}
-
-		void frames_invalid ()
-		{
-			current_frame = null;
-			current_backtrace = null;
-			registers = null;
-		}
-
-		void update_current_frame (StackFrame new_frame)
-		{
-			current_frame = new_frame;
-		}
-
-		TemporaryBreakpointData temp_breakpoint = null;
-
-		void insert_temporary_breakpoint (TargetAddress address)
-		{
-			check_inferior ();
-
-			if (temp_breakpoint != null)
-				throw new InternalError ("temp_breakpoint_id != 0");
-
-			int dr_index;
-			int id = inferior.InsertHardwareBreakpoint (address, true, out dr_index);
-			temp_breakpoint = new TemporaryBreakpointData (id, address);
-
-			Report.Debug (DebugFlags.SSE, "{0} inserted temp breakpoint {1}:{2} at {3}",
-				      this, id, dr_index, address);
-		}
-
-		void remove_temporary_breakpoint ()
-		{
-			if (temp_breakpoint != null) {
-				Report.Debug (DebugFlags.SSE, "{0} removing temp breakpoint {1}",
-					      this, temp_breakpoint);
-
-				inferior.RemoveBreakpoint (temp_breakpoint.ID);
-				temp_breakpoint = null;
-			}
-		}
-
-		// <summary>
-		//   Step over the next machine instruction.
-		// </summary>
-		void do_next ()
-		{
-			check_inferior ();
-			frames_invalid ();
-			TargetAddress address = inferior.CurrentFrame;
-
-			// Check whether this is a call instruction.
-			Instruction instruction = inferior.Architecture.ReadInstruction (
-				inferior, address);
-			if ((instruction == null) || !instruction.HasInstructionSize) {
-				do_step ();
-				return;
-			}
-
-			Report.Debug (DebugFlags.SSE, "{0} do_next: {1} {2}", this,
-				      address, instruction.InstructionType);
-
-			// Step one instruction unless this is a call
-			if (!instruction.IsCall) {
-				do_step ();
-				return;
-			}
-
-			// Insert a temporary breakpoint immediately behind it and continue.
-			address += instruction.InstructionSize;
-			do_continue (address);
-		}
-
-		// <summary>
-		//   Resume the target.
-		// </summary>
-		void do_continue ()
-		{
-			do_continue (TargetAddress.Null);
-		}
-
-		void do_continue (TargetAddress until)
-		{
-			check_inferior ();
-			frames_invalid ();
-
-			if (step_over_breakpoint (false, until))
-				return;
-
-			if (!until.IsNull)
-				insert_temporary_breakpoint (until);
-			inferior.Continue ();
-		}
-
-		void do_step_native ()
-		{
-			if (step_over_breakpoint (true, TargetAddress.Null))
-				return;
-
-			inferior.Step ();
-		}
-
-		void do_step ()
-		{
-			if (step_over_breakpoint (true, TargetAddress.Null))
-				return;
-
-			/*
-			 * Don't step into any signal handlers.
-			 */
-
-			if (inferior.IsManagedSignal (inferior.GetPendingSignal ())) {
-				do_continue (inferior.CurrentFrame);
-			} else {
-				inferior.Step ();
-			}
-		}
-
-		protected bool CheckTrampoline (Instruction instruction, TrampolineHandler handler)
-		{
-			TargetAddress trampoline;
-			Instruction.TrampolineType type = instruction.CheckTrampoline (
-				inferior, out trampoline);
-			if (type == Instruction.TrampolineType.None)
-				return false;
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} found trampoline {1}:{2} at {3} while running {4}",
-				      this, type, trampoline, instruction.Address, current_operation);
-
-			if (type == Instruction.TrampolineType.NativeTrampolineStart) {
-				PushOperation (new OperationNativeTrampoline (this, trampoline, handler));
-				return true;
-			} else if (type == Instruction.TrampolineType.NativeTrampoline) {
-				Method method = Lookup (trampoline);
-				if (!MethodHasSource (method))
-					do_next ();
-				else
-					do_continue (trampoline);
-				return true;
-			} else if (type == Instruction.TrampolineType.MonoTrampoline) {
-				PushOperation (new OperationMonoTrampoline (
-					this, instruction, trampoline, handler));
-				return true;
-			} else if (type == Instruction.TrampolineType.DelegateInvoke) {
-				PushOperation (new OperationDelegateInvoke (this));
-				return true;
-			}
-
-			return false;
-		}
-
-		protected bool MethodHasSource (Method method)
-		{
-			if ((method == null) || !method.HasLineNumbers || !method.HasMethodBounds)
-				return false;
-
-			if (method.WrapperType == WrapperType.ManagedToNative) {
-				DebuggerConfiguration config = process.Session.Config;
-				ModuleGroup native_group = config.GetModuleGroup ("native");
-				if (!native_group.StepInto)
-					return false;
-			}
-
-			if (current_method != null) {
-				if ((method.Module != current_method.Module) && !method.Module.StepInto)
-					return false;
-			} else {
-				if (!method.Module.StepInto)
-					return false;
-			}
-
-			if (!method.HasSource || method.IsWrapper || method.IsCompilerGenerated)
-				return false;
-
-			LineNumberTable lnt = method.LineNumberTable;
-			if (lnt == null)
-				return false;
-
-			SourceAddress addr = lnt.Lookup (method.MethodStartAddress);
-			if (addr == null) {
-				Report.Error ("OOOOPS - No source for method: {0}", method);
-				lnt.DumpLineNumbers (Console.Out);
-				return false;
-			}
-
-			return true;
-		}
-
-		// <summary>
-		//   Create a step frame to step until the next source line.
-		// </summary>
-		StepFrame CreateStepFrame ()
-		{
-			check_inferior ();
-			StackFrame frame = current_frame;
-			Language language = (frame.Method != null) ? frame.Method.Module.Language : null;
-
-			if (frame.SourceAddress == null)
-				return new StepFrame (language, StepMode.SingleInstruction);
-
-			// The current source line started at the current address minus
-			// SourceOffset; the next source line will start at the current
-			// address plus SourceRange.
-
-			int offset = frame.SourceAddress.LineOffset;
-			int range = frame.SourceAddress.LineRange;
-
-			TargetAddress start = frame.TargetAddress - offset;
-			TargetAddress end = frame.TargetAddress + range;
-
-			return new StepFrame (language, StepMode.StepFrame, frame, start, end);
-		}
-
-		// <summary>
-		//   Create a step frame for a native stepping operation.
-		// </summary>
-		StepFrame CreateStepFrame (StepMode mode)
-		{
-			check_inferior ();
-			Language language = (current_method != null) ?
-				current_method.Module.Language : null;
-
-			return new StepFrame (language, mode);
-		}
-
-		StackData save_stack (long id)
-		{
-			//
-			// Save current state.
-			//
-			StackData stack_data = new StackData (
-				id, current_method, inferior.CurrentFrame, current_frame,
-				current_backtrace, registers);
-
-			current_method = null;
-			current_frame = null;
-			current_backtrace = null;
-			registers = null;
-
-			return stack_data;
-		}
-
-		void restore_stack (StackData stack)
-		{
-			if (inferior.CurrentFrame != stack.Address) {
-				Report.Debug (DebugFlags.SSE,
-					      "{0} discarding saved stack: stopped " +
-					      "at {1}, but recorded {2}", this,
-					      inferior.CurrentFrame, stack.Frame.TargetAddress);
-				frame_changed (inferior.CurrentFrame, null);
-				return;
-			}
-
-			current_method = stack.Method;
-			current_frame = stack.Frame;
-			current_backtrace = stack.Backtrace;
-			registers = stack.Registers;
-		}
-
-		// <summary>
-		//   Interrupt any currently running stepping operation, but don't send
-		//   any notifications to the caller.  The currently running operation is
-		//   automatically resumed when ReleaseThreadLock() is called.
-		// </summary>
-		internal override void AcquireThreadLock ()
-		{
-			if (HasThreadLock)
-				throw new InternalError ("Recursive thread lock");
-
-			Report.Debug (DebugFlags.Threads,
-				      "{0} acquiring thread lock: {1} {2}",
-				      this, engine_stopped, current_operation);
-
-			if (engine_stopped)
-				return;
-
-			Inferior.ChildEvent stop_event;
-			bool stopped = inferior.Stop (out stop_event);
-			thread_lock = new ThreadLockData (stopped, stop_event, true);
-
-			Report.Debug (DebugFlags.Threads,
-				      "{0} acquiring thread lock #1: {1} {2}",
-				      this, stopped, stop_event);
-
-			if ((stop_event != null) &&
-			    ((stop_event.Type == Inferior.ChildEventType.CHILD_EXITED) ||
-			     ((stop_event.Type == Inferior.ChildEventType.CHILD_SIGNALED))))
-				return;
-
-			TargetAddress new_rsp = inferior.PushRegisters ();
-
-			Report.Debug (DebugFlags.Threads,
-				      "{0} acquired thread lock: {1} {2} {3} {4} {5}",
-				      this, stopped, stop_event, EndStackAddress,
-				      new_rsp, inferior.CurrentFrame);
-
-			if (!EndStackAddress.IsNull)
-				inferior.WriteAddress (EndStackAddress, new_rsp);
-
-			frame_changed (inferior.CurrentFrame, null);
-			engine_stopped = true;
-		}
-
-		internal override void ReleaseThreadLock ()
-		{
-			if (thread_lock == null) {
-				Report.Debug (DebugFlags.Threads,
-					      "{0} thread lock already released!", this);
-				return;
-			}
-
-			Report.Debug (DebugFlags.Threads,
-				      "{0} releasing thread lock: {1} {2} {3}", this, thread_lock,
-				      inferior.CurrentFrame, current_operation);
-
-			thread_lock.PopRegisters (inferior);
-			if (thread_lock.StopEvent != null)
-				manager.AddPendingEvent (this, thread_lock.StopEvent);
-			if (thread_lock.Stopped)
-				engine_stopped = false;
-
-			thread_lock = null;
-		}
-
-		internal void ReleaseThreadLock (Inferior.ChildEvent cevent)
-		{
-			Report.Debug (DebugFlags.Threads,
-				      "{0} releasing thread lock #1: {1} {2} {3}",
-				      this, cevent, inferior.CurrentFrame,
-				      current_operation);
-
-			// The target stopped before we were able to send the SIGSTOP,
-			// but we haven't processed this event yet.
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
-			    (cevent.Argument == 0)) {
-				if (current_operation != null)
-					current_operation.ResumeOperation ();
-
-				return;
-			}
-
-			if (cevent.Type == Inferior.ChildEventType.CHILD_INTERRUPTED) {
-				inferior.Resume ();
-				return;
-			}
-
-			ProcessEvent (cevent);
-		}
-
-		internal override void SuspendUserThread ()
-		{
-			if (!ThreadManager.InBackgroundThread)
-				throw new InternalError ();
-			if (HasThreadLock)
-				throw new InternalError ("Recursive thread lock");
-
-			Report.Debug (DebugFlags.Threads,
-				      "{0} suspend user thread: {1} {2}",
-				      this, engine_stopped, current_operation);
-
-			if (engine_stopped)
-				return;
-
-			Inferior.ChildEvent stop_event;
-			bool stopped = inferior.Stop (out stop_event);
-
-			stop_requested = true;
-
-			if (stop_event != null) {
-				if (ProcessEvent (stop_event))
-					stop_event = null;
-			} else {
-				OperationInterrupted ();
-			}
-
-			Report.Debug (DebugFlags.Threads,
-				      "{0} suspend user thread done: {1} {2}",
-				      this, stopped, stop_event);
-
-			if (stop_event != null)
-				thread_lock = new ThreadLockData (stopped, stop_event, false);
-		}
-
-		internal override void ResumeUserThread ()
-		{
-			if (!ThreadManager.InBackgroundThread)
-				throw new InternalError ();
-
-			Report.Debug (DebugFlags.Threads,
-				      "{0} resume user thread: {1} {2} {3}", this, engine_stopped,
-				      HasThreadLock, thread.ThreadFlags);
-
-			CommandResult result = new ThreadCommandResult (thread);
-
-			if (thread_lock != null) {
-				if (thread_lock.PushedRegisters || (thread_lock.StopEvent == null))
-					throw new InternalError ();
-
-				manager.AddPendingEvent (this, thread_lock.StopEvent);
-
-				thread_lock = null;
-				engine_stopped = false;
-
-				current_operation = new OperationStep (this, StepMode.Run, result);
-				return;
-			}
-
-			if (!engine_stopped)
-				return;
-
-			StartOperation (new OperationStep (this, StepMode.Run, result));
-		}
-
-		internal bool OnModuleLoaded (Module module)
-		{
-			return ActivatePendingBreakpoints (module);
-		}
-
-		internal bool ActivatePendingBreakpoints (Module module)
-		{
-			Inferior.StackFrame iframe = inferior.GetCurrentFrame ();
-			Registers registers = inferior.GetRegisters ();
-
-			StackFrame main_frame;
-			if (process.MonoManager != null) {
-				MonoLanguageBackend mono = process.MonoLanguage;
-
-				MonoFunctionType main = mono.MainMethod;
-				if (main == null)
-					return false;
-
-				MethodSource source = main.SymbolFile.GetMethodByToken (main.Token);
-				if (source != null) {
-					SourceLocation location = new SourceLocation (source);
-
-					main_frame = new StackFrame (
-						thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
-						iframe.FrameAddress, registers, main, location);
-				} else {
-					main_frame = new StackFrame (
-						thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
-						iframe.FrameAddress, registers);
-				}
-
-				update_current_frame (main_frame);
-			} else {
-				TargetAddress main_address = Process.OperatingSystem.LookupSymbol ("main");
-				if (main_address.IsNull)
-					return false;
-
-				Method method = Lookup (main_address);
-
-				if (method == null)
-					return false;
-
-				main_frame = new StackFrame (
-					thread, FrameType.Normal, iframe.Address, iframe.StackPointer,
-					iframe.FrameAddress, registers, method);
-				update_current_frame (main_frame);
-			}
-
-			Report.Debug (DebugFlags.SSE, "{0} activate pending breakpoints", this);
-
-			Queue pending = new Queue ();
-			foreach (Event e in process.Session.Events) {
-				Breakpoint breakpoint = e as Breakpoint;
-				if (breakpoint == null)
-					continue;
-
-				if (!e.IsEnabled || e.IsActivated)
-					continue;
-
-				if (e.IsUserModule && (module != null) && (module.ModuleGroup.Name != "user"))
-					continue;
-
-				try {
-					BreakpointHandle handle = breakpoint.Resolve (thread, main_frame);
-					if (handle == null)
-						continue;
-
-					FunctionBreakpointHandle fh = handle as FunctionBreakpointHandle;
-					if (fh == null) {
-						handle.Insert (thread);
-						continue;
-					}
-
-					pending.Enqueue (fh);
-				} catch (TargetException ex) {
-					if (ex.Type == TargetError.LocationInvalid)
-						breakpoint.OnResolveFailed ();
-					else
-						breakpoint.OnBreakpointError (
-							"Cannot insert breakpoint {0}: {1}", e.Index, ex.Message);
-				} catch (Exception ex) {
-					breakpoint.OnBreakpointError (
-						"Cannot insert breakpoint {0}: {1}", e.Index, ex.Message);
-				}
-			}
-
-			if (pending.Count == 0)
-				return false;
-
-			PushOperation (new OperationActivateBreakpoints (this, pending));
-			return true;
-		}
-
-		public override string ToString ()
-		{
-			return String.Format ("SSE ({0}:{1}:{2:x})", ID, PID, TID);
-		}
-
-#region SSE Commands
-
-		internal override ThreadCommandResult Old_Step (StepMode mode, StepFrame frame)
-		{
-			ThreadCommandResult result = new OldOperationCommandResult (thread);
-			StartOperation (new OperationStep (this, mode, frame, result));
-			return result;
-		}
-
-		public override CommandResult Step (ThreadingModel model, StepMode mode, StepFrame frame)
-		{
-			StartOperation ();
-
-			return (CommandResult) SendCommand (delegate {
-				Report.Debug (DebugFlags.SSE, "{0} step: {1} {2} {3}", this, model, mode, frame);
-				CommandResult result = process.StartOperation (model, this);
-				return ProcessOperation (new OperationStep (this, mode, frame, result));
-			});
-		}
-
-		public override void RuntimeInvoke (TargetFunctionType function,
-						    TargetStructObject object_argument,
-						    TargetObject[] param_objects,
-						    RuntimeInvokeFlags flags,
-						    RuntimeInvokeResult result)
-		{
-			StartOperation (new OperationRuntimeInvoke (
-				this, function, object_argument, param_objects,
-				flags, result));
-		}
-
-		public override CommandResult CallMethod (TargetAddress method, long arg1, long arg2,
-							  long arg3, string string_argument)
-		{
-			return StartOperation (new OperationCallMethod (
-				this, method, arg1, arg2, arg3, string_argument));
-		}
-
-		public override CommandResult CallMethod (TargetAddress method, long arg1, long arg2)
-		{
-			return StartOperation (new OperationCallMethod (this, method, arg1, arg2));
-		}
-
-		public override CommandResult CallMethod (TargetAddress method, TargetAddress method_arg,
-							  TargetObject object_arg)
-		{
-			return StartOperation (new OperationCallMethod (this, method, method_arg, object_arg));
-		}
-
-		public override CommandResult Return (ReturnMode mode)
-		{
-			return (CommandResult) SendCommand (delegate {
-				if (!engine_stopped) {
-					Report.Debug (DebugFlags.Wait,
-						      "{0} not stopped", this);
-					throw new TargetException (TargetError.NotStopped);
-				}
-
-				if (current_frame == null)
-					throw new TargetException (TargetError.NoStack);
-
-				process.UpdateSymbolTable (inferior);
-
-				if (!process.IsManagedApplication) {
-					if (mode == ReturnMode.Managed)
-						mode = ReturnMode.Native;
-					else if (mode == ReturnMode.Invocation)
-						throw new TargetException (TargetError.InvalidReturn, "Not a managed application.");
-				}
-
-				Backtrace bt = new Backtrace (current_frame);
-
-				if (mode == ReturnMode.Invocation) {
-					Inferior.CallbackFrame cframe = inferior.GetCallbackFrame (current_frame.StackPointer, false);
-					if (cframe == null)
-						throw new TargetException (TargetError.NoInvocation);
-					bt.GetBacktrace (this, inferior, Backtrace.Mode.Native, cframe.StackPointer, -1);
-					for (int i = 0; i < bt.Count; i++) {
-						if (bt.Frames [i].Type == FrameType.Normal)
-							continue;
-						else if ((bt.Frames [i].Type == FrameType.RuntimeInvoke) && (i + 1 == bt.Count))
-							break;
-						throw new TargetException (TargetError.InvalidReturn,
-									   "Cannot abort an invocation which contains non-managed frames.");
-					}
-				} else {
-					bt.GetBacktrace (this, inferior, Backtrace.Mode.Native,
-							 TargetAddress.Null, 2);
-				}
-
-				if (bt.Count < 2)
-					throw new TargetException (TargetError.NoStack);
-
-				StackFrame parent_frame = bt.Frames [1];
-				if (parent_frame == null)
-					return null;
-
-				Report.Debug (DebugFlags.SSE, "{0} return: {1} {2} {3}", this, mode, current_frame.Type,
-					      parent_frame.Type);
-
-				if (mode == ReturnMode.Native) {
-					if ((current_frame.Type == FrameType.Signal) || (parent_frame.Type == FrameType.Signal) ||
-					    (current_frame.Type == FrameType.Callback) || (parent_frame.Type == FrameType.Callback))
-						throw new TargetException (TargetError.InvalidReturn,
-									   "Cannot return from a signal handler or mdb-internal callback.");
-					if ((current_frame.Type != FrameType.Normal) || (parent_frame.Type != FrameType.Normal))
-						throw new TargetException (TargetError.InvalidReturn);
-				} else if (mode == ReturnMode.Managed) {
-					bool ok = true;
-					if (((current_frame.Type == FrameType.Normal) &&
-					     ((current_frame.Language == null) || !current_frame.Language.IsManaged)) ||
-					    ((current_frame.Type != FrameType.RuntimeInvoke) && (current_frame.Type != FrameType.Normal)))
-						ok = false;
-					if (((parent_frame.Type == FrameType.Normal) &&
-					     ((parent_frame.Language == null) || !parent_frame.Language.IsManaged)) ||
-					    ((parent_frame.Type != FrameType.RuntimeInvoke) && (parent_frame.Type != FrameType.Normal)))
-						ok = false;
-					if (!ok)
-						throw new TargetException (TargetError.InvalidReturn,
-									   "Cannot return from a non-managed frame.");
-				}
-
-				if (mode == ReturnMode.Native) {
-					inferior.SetRegisters (parent_frame.Registers);
-					frame_changed (inferior.CurrentFrame, null);
-					TargetEventArgs args = new TargetEventArgs (
-						TargetEventType.TargetStopped, 0, current_frame);
-					process.OnTargetEvent (this, args);
-					return null;
-				}
-
-				return StartOperation (new OperationReturn (this, bt, mode));
-			});
-		}
-
-		internal override void AbortInvocation (long rti_id)
-		{
-			if (!process.IsManagedApplication)
-				throw new TargetException (TargetError.InvalidReturn, "Not a managed application.");
-
-			SendCommand (delegate {
-				Report.Debug (DebugFlags.SSE, "{0} test abort: {1}", this, engine_stopped);
-
-				lock (this) {
-					if (abort_requested >= 0)
-						throw new TargetException (TargetError.InvalidReturn, "Already queued an abort.");
-
-					bool stopped = inferior.Stop ();
-					Report.Debug (DebugFlags.SSE, "{0} abort invocation: {1} {2}", this, rti_id, stopped);
-					if (stopped) {
-						abort_requested = rti_id;
-						return null;
-					}
-				}
-
-				DoAbortInvocation (rti_id);
-				return null;
-			});
-		}
-
-		void DoAbortInvocation (long rti_id)
-		{
-			Report.Debug (DebugFlags.SSE, "{0} do abort invocation: {1}", this, rti_id);
-
-			if (current_frame == null)
-				throw new TargetException (TargetError.NoStack);
-
-			process.UpdateSymbolTable (inferior);
-
-			Inferior.CallbackFrame cframe = inferior.GetCallbackFrame (current_frame.StackPointer, false);
-
-			bool found = false;
-			foreach (OperationRuntimeInvoke rti in rti_stack) {
-				if (rti.ID == rti_id) {
-					found = true;
-					break;
-				}
-			}
-
-			if (!found) {
-				throw new TargetException (TargetError.NoInvocation);
-			} else {
-				if (cframe == null)
-					throw new TargetException (TargetError.InvalidReturn, "No invocation found.");
-				else if (cframe.ID != rti_id)
-					throw new TargetException (TargetError.InvalidReturn,
-								   "Requested to abort invocation {0}, but current invocation has id {1}.",
-								   rti_id, cframe.ID);
-			}
-
-			Backtrace bt = new Backtrace (current_frame);
-
-			bt.GetBacktrace (this, inferior, Backtrace.Mode.Native, cframe.StackPointer, -1);
-			for (int i = 0; i < bt.Count; i++) {
-				if (bt.Frames [i].Type == FrameType.Normal)
-					continue;
-				else if ((bt.Frames [i].Type == FrameType.RuntimeInvoke) && (i + 1 == bt.Count))
-					break;
-				throw new TargetException (TargetError.InvalidReturn,
-							   "Cannot abort an invocation which contains non-managed frames.");
-			}
-
-			if (bt.Count < 2)
-				throw new TargetException (TargetError.NoStack);
-
-			PushOperation (new OperationReturn (this, bt, ReturnMode.Invocation));
-		}
-
-		public override Backtrace GetBacktrace (Backtrace.Mode mode, int max_frames)
-		{
-			return (Backtrace) SendCommand (delegate {
-				if (!engine_stopped) {
-					Report.Debug (DebugFlags.Wait,
-						      "{0} not stopped", this);
-					throw new TargetException (TargetError.NotStopped);
-				}
-
-				process.UpdateSymbolTable (inferior);
-
-				if (current_frame == null)
-					throw new TargetException (TargetError.NoStack);
-
-				current_backtrace = new Backtrace (current_frame);
-
-				current_backtrace.GetBacktrace (
-					this, inferior, mode, TargetAddress.Null, max_frames);
-
-				return current_backtrace;
-			});
-		}
-
-		public override Registers GetRegisters ()
-		{
-			return (Registers) SendCommand (delegate {
-				registers = inferior.GetRegisters ();
-				return registers;
-			});
-		}
-
-		public override void SetRegisters (Registers registers)
-		{
-			if (!registers.FromCurrentFrame)
-				throw new InvalidOperationException ();
-
-			this.registers = registers;
-			SendCommand (delegate {
-				inferior.SetRegisters (registers);
-				return registers;
-			});
-		}
-
-		internal override void InsertBreakpoint (BreakpointHandle handle,
-							 TargetAddress address, int domain)
-		{
-			SendCommand (delegate {
-				process.BreakpointManager.InsertBreakpoint (
-					inferior, handle, address, domain);
-				return null;
-			});
-		}
-
-		internal override void RemoveBreakpoint (BreakpointHandle handle)
-		{
-			SendCommand (delegate {
-				process.BreakpointManager.RemoveBreakpoint (inferior, handle);
-				return null;
-			});
-		}
-
-		public override int GetInstructionSize (TargetAddress address)
-		{
-			return (int) SendCommand (delegate {
-				return Architecture.Disassembler.GetInstructionSize (inferior, address);
-			});
-		}
-
-		public override AssemblerLine DisassembleInstruction (Method method, TargetAddress address)
-		{
-			return (AssemblerLine) SendCommand (delegate {
-				return Architecture.Disassembler.DisassembleInstruction (
-					inferior, method, address);
-			});
-		}
-
-		public override AssemblerMethod DisassembleMethod (Method method)
-		{
-			return (AssemblerMethod) SendCommand (delegate {
-				return Architecture.Disassembler.DisassembleMethod (inferior, method);
-			});
-		}
-
-		public override byte[] ReadBuffer (TargetAddress address, int size)
-		{
-			return (byte[]) SendCommand (delegate {
-				return inferior.ReadBuffer (address, size);
-			});
-		}
-
-		public override TargetBlob ReadMemory (TargetAddress address, int size)
-		{
-			return new TargetBlob (ReadBuffer (address, size), TargetMemoryInfo);
-		}
-
-		public override byte ReadByte (TargetAddress address)
-		{
-			return (byte) SendCommand (delegate {
-				return inferior.ReadByte (address);
-			});
-		}
-
-		public override int ReadInteger (TargetAddress address)
-		{
-			return (int) SendCommand (delegate {
-				return inferior.ReadInteger (address);
-			});
-		}
-
-		public override long ReadLongInteger (TargetAddress address)
-		{
-			return (long) SendCommand (delegate {
-				return inferior.ReadLongInteger (address);
-			});
-		}
-
-		public override TargetAddress ReadAddress (TargetAddress address)
-		{
-			return (TargetAddress) SendCommand (delegate {
-				return inferior.ReadAddress (address);
-			});
-		}
-
-		public override string ReadString (TargetAddress address)
-		{
-			return (string) SendCommand (delegate {
-				return inferior.ReadString (address);
-			});
-		}
-
-		internal override Inferior.CallbackFrame GetCallbackFrame (TargetAddress stack_pointer,
-									   bool exact_match)
-		{
-			return (Inferior.CallbackFrame) SendCommand (delegate {
-				return inferior.GetCallbackFrame (stack_pointer, exact_match);
-			});
-		}
-
-		internal override TargetFunctionType GetRuntimeInvokedFunction (long ID)
-		{
-			foreach (OperationRuntimeInvoke rti in rti_stack) {
-				if (rti.ID != ID)
-					continue;
-
-				return rti.Function;
-			}
-
-			return null;
-		}
-
-		public override void WriteBuffer (TargetAddress address, byte[] buffer)
-		{
-			SendCommand (delegate {
-				inferior.WriteBuffer (address, buffer);
-				return null;
-			});
-		}
-
-		public override void WriteByte (TargetAddress address, byte value)
-		{
-			SendCommand (delegate {
-				inferior.WriteByte (address, value);
-				return null;
-			});
-		}
-
-		public override void WriteInteger (TargetAddress address, int value)
-		{
-			SendCommand (delegate {
-				inferior.WriteInteger (address, value);
-				return null;
-			});
-		}
-
-		public override void WriteLongInteger (TargetAddress address, long value)
-		{
-			SendCommand (delegate {
-				inferior.WriteLongInteger (address, value);
-				return null;
-			});
-		}
-
-		public override void WriteAddress (TargetAddress address, TargetAddress value)
-		{
-			SendCommand (delegate {
-				inferior.WriteAddress (address, value);
-				return null;
-			});
-		}
-
-		public override bool CanWrite {
-			get { return true; }
-		}
-
-		public override string PrintObject (Style style, TargetObject obj,
-						    DisplayFormat format)
-		{
-			return (string) SendCommand (delegate {
-				return style.FormatObject (thread, obj, format);
-			});
-		}
-
-		public override string PrintType (Style style, TargetType type)
-		{
-			return (string) SendCommand (delegate {
-				return style.FormatType (thread, type);
-			});
-		}
-
-		internal override object Invoke (TargetAccessDelegate func, object data)
-		{
-			return SendCommand (delegate {
-				return func (thread, data);
-			});
-		}
-#endregion
-
-		public void ManagedCallback (ManagedCallbackFunction func, CommandResult result)
-		{
-			ManagedCallbackData data = new ManagedCallbackData (func, result);
-
-			SendCommand (delegate {
-				Report.Debug (DebugFlags.SSE, "{0} starting managed callback: {1}", this, func);
-
-				AcquireThreadLock ();
-
-				if (!do_managed_callback (data)) {
-					Report.Debug (DebugFlags.SSE, "{0} managed callback needs thread lock", this);
-
-					bool ok = false;
-					process.AcquireGlobalThreadLock (this);
-					foreach (SingleSteppingEngine engine in process.ThreadServants) {
-					try {
-						if (engine.do_managed_callback (data)) {
-							ok = true;
-							break;
-						}
-					} catch (Exception ex) {
-						Console.WriteLine ("FUCK: {0} {1}", engine, ex);
-						}
-
-					}
-
-					if (!ok) {
-						TargetAddress lmf_address = inferior.ReadAddress (LMFAddress);
-						StackFrame lmf_frame = Architecture.GetLMF (this, inferior, ref lmf_address);
-
-						Report.Debug (DebugFlags.SSE, "{0} requesting managed callback: {1}", this, lmf_frame);
-						process.MonoManager.AddManagedCallback (inferior, data);
-
-						/*
-						 * Prevent a race condition:
-						 * If we stopped just before returning from native code,
-						 * mono_thread_interruption_checkpoint_request() may not be called again
-						 * before returning back to managed code; it's called next time we're entering
-						 * native code again.
-						 *
-						 * This could lead to problems if the managed code does some CPU-intensive
-						 * before going unmanaged next time - or even loops forever.
-						 *
-						 * I have a test case where an icall contains a sleep() and the managed code
-						 * contains an infinite loop (`for (;;) ;) immediately after returning from
-						 * this icall.
-						 *
-						 * To prevent this from happening, we insert a breakpoint on the last managed
-						 * frame.
-						 */
-
-						if (lmf_frame != null)
-							insert_lmf_breakpoint (lmf_frame.TargetAddress);
-						else {
-							Report.Error ("{0} unable to compute LMF for managed callback: {1}",
-								      this, inferior.CurrentFrame);
-						}
-					}
-
-					Report.Debug (DebugFlags.SSE, "{0} managed callback releasing thread lock", this);
-					process.ReleaseGlobalThreadLock (this);
-				}
-
-				ReleaseThreadLock ();
-
-				Report.Debug (DebugFlags.SSE, "{0} managed callback done: {1} {2}", this, data.Running, data.Completed);
-				return null;
-			});
-		}
-
-		void insert_lmf_breakpoint (TargetAddress lmf_address)
-		{
-			lmf_breakpoint = new LMFBreakpointData (lmf_address);
-
-			/*
-			 * Insert a breakpoint on the last managed frame (LMF).  We use a hardware breakpoint for this
-			 * since the JIT might inspect / modify the callsite and we don't know whether we're at a safe
-			 * spot right now.
-			 *
-			 * If we already have a single-stepping breakpoint, we "steal" it here, so we only use one single
-			 * hardware register internally in the SSE.
-			 *
-			 */
-
-			if (temp_breakpoint != null) {
-				Report.Debug (DebugFlags.SSE, "{0} stealing temporary breakpoint {1} at {2} -> lmf breakpoint at {2}.",
-					      temp_breakpoint.ID, temp_breakpoint.Address, lmf_address);
-
-				lmf_breakpoint.StolenBreakpoint = temp_breakpoint;
-				temp_breakpoint = null;
-
-				/*
-				 * The breakpoint is already at the requested location -> keep and reuse it.
-				 */
-
-				if (lmf_address == temp_breakpoint.Address) {
-					lmf_breakpoint.Breakpoint = lmf_breakpoint.StolenBreakpoint;
-					return;
-				}
-
-				inferior.RemoveBreakpoint (lmf_breakpoint.StolenBreakpoint.ID);
-			}
-
-			/*
-			 * The SSE's internal hardware breakpoint register is now free.
-			 */
-
-			int dr_index;
-			int id = inferior.InsertHardwareBreakpoint (lmf_address, true, out dr_index);
-
-			Report.Debug (DebugFlags.SSE, "{0} inserted lmf breakpoint: {1} {2} {3}", this, lmf_address, id, dr_index);
-
-			lmf_breakpoint.Breakpoint = new TemporaryBreakpointData (id, lmf_address);
-		}
-
-		void remove_lmf_breakpoint ()
-		{
-			if (lmf_breakpoint == null)
-				return;
-
-			/*
-			 * We reused an already existing single-stepping breakpoint at the requested location.
-			 */
-			if (lmf_breakpoint.Breakpoint == lmf_breakpoint.StolenBreakpoint)
-				return;
-
-			inferior.RemoveBreakpoint (lmf_breakpoint.Breakpoint.ID);
-
-			/*
-			 * We stole the single-stepping breakpoint -> restore it here.
-			 */
-
-			if (lmf_breakpoint.StolenBreakpoint != null) {
-				int dr_index;
-				TargetAddress address = lmf_breakpoint.StolenBreakpoint.Address;
-				int id = inferior.InsertHardwareBreakpoint (address, true, out dr_index);
-
-				temp_breakpoint = new TemporaryBreakpointData (id, address);
-
-				Report.Debug (DebugFlags.SSE, "{0} restored stolen breakpoint: {1}", this, temp_breakpoint);
-			}
-
-			lmf_breakpoint = null;
-		}
-
-		bool do_managed_callback (ManagedCallbackData data)
-		{
-			Inferior.StackFrame sframe = inferior.GetCurrentFrame ();
-			Method method = Lookup (inferior.CurrentFrame);
-
-			Report.Debug (DebugFlags.SSE, "{0} managed callback checking frame: {1} ({2:x} - {3:x} - {4:x}) {5} {6}",
-				      this, inferior.CurrentFrame, sframe.Address, sframe.StackPointer, sframe.FrameAddress,
-				      method, method != null);
-			if ((method == null) || !method.Module.Language.IsManaged)
-				return false;
-
-			Report.Debug (DebugFlags.SSE, "{0} found managed frame: {1} {2}", this,
-				      inferior.CurrentFrame, method);
-
-			PushOperation (new OperationManagedCallback (this, data));
-			return true;
-		}
-
-		LMFBreakpointData lmf_breakpoint = null;
-
-		internal void OnManagedCallback (Queue<ManagedCallbackData> callbacks)
-		{
-			Report.Debug (DebugFlags.SSE, "{0} on managed callback", this);
-			PushOperation (new OperationManagedCallback (this, callbacks));
-		}
-
-#region IDisposable implementation
-		protected override void DoDispose ()
-		{
-			if (inferior != null) {
-				inferior.Dispose ();
-				inferior = null;
-			}
-
-			base.DoDispose ();
-		}
-#endregion
-
-		protected Method current_method;
-		protected StackFrame current_frame;
-		protected Backtrace current_backtrace;
-		protected Registers registers;
-
-		Operation current_operation;
-
-		Inferior inferior;
-		Disassembler disassembler;
-		bool engine_stopped;
-		bool reached_main;
-		bool killed, dead;
-		bool stop_requested;
-		bool attach_initialized;
-		long tid;
-		int pid;
-
-		ThreadLockData thread_lock;
-
-		long abort_requested = -1;
-
-		int stepping_over_breakpoint;
-
-		TargetEventArgs last_target_event;
-
-		TargetAddress lmf_address = TargetAddress.Null;
-		TargetAddress end_stack_address = TargetAddress.Null;
-		TargetAddress extended_notifications_addr = TargetAddress.Null;
-		TargetAddress main_retaddr = TargetAddress.Null;
-
-		Stack<InterruptibleOperation> nested_break_stack = new Stack<InterruptibleOperation> ();
-		Stack<OperationRuntimeInvoke> rti_stack = new Stack<OperationRuntimeInvoke> ();
-
-		ManualResetEvent operation_completed_event = new ManualResetEvent (false);
-
-#region Nested SSE classes
-		protected sealed class StackData : DebuggerMarshalByRefObject
-		{
-			public readonly long ID;
-			public readonly Method Method;
-			public readonly TargetAddress Address;
-			public readonly StackFrame Frame;
-			public readonly Backtrace Backtrace;
-			public readonly Registers Registers;
-
-			public StackData (long id, Method method, TargetAddress address,
-					  StackFrame frame, Backtrace backtrace,
-					  Registers registers)
-			{
-				this.ID = id;
-				this.Method = method;
-				this.Address = address;
-				this.Frame = frame;
-				this.Backtrace = backtrace;
-				this.Registers = registers;
-			}
-		}
-
-		protected sealed class TemporaryBreakpointData
-		{
-			public readonly int ID;
-			public readonly TargetAddress Address;
-
-			public TemporaryBreakpointData (int id, TargetAddress address)
-			{
-				this.ID = id;
-				this.Address = address;
-			}
-
-			public override string ToString ()
-			{
-				return String.Format ("TemporaryBreakpoint ({0}:{1})", ID, Address);
-			}
-		}
-
-		protected sealed class LMFBreakpointData
-		{
-			public readonly TargetAddress Address;
-			public TemporaryBreakpointData Breakpoint;
-			public TemporaryBreakpointData StolenBreakpoint;
-
-			public LMFBreakpointData (TargetAddress address)
-			{
-				this.Address = address;
-			}
-		}
-
-		protected sealed class ThreadLockData
-		{
-			public bool Stopped {
-				get; private set;
-			}
-
-			public Inferior.ChildEvent StopEvent {
-				get; private set;
-			}
-
-			public bool PushedRegisters {
-				get; private set;
-			}
-
-			public ThreadLockData (bool stopped, Inferior.ChildEvent stop_event, bool pushed_regs)
-			{
-				this.Stopped = stopped;
-				this.StopEvent = stop_event;
-				this.PushedRegisters = pushed_regs;
-			}
-
-			public void SetStopEvent (Inferior.ChildEvent stop_event)
-			{
-				if (StopEvent != null)
-					throw new InternalError ();
-
-				StopEvent = stop_event;
-				Stopped = true;
-			}
-
-			public void PopRegisters (Inferior inferior)
-			{
-				if (PushedRegisters)
-					inferior.PopRegisters ();
-				PushedRegisters = false;
-			}
-
-			public override string ToString ()
-			{
-				return String.Format ("ThreadLock ({0}:{1}:{2})", Stopped, StopEvent, PushedRegisters);
-			}
-		}
-#endregion
-
-#region SSE Operations
-	protected abstract class Operation {
-		public enum EventResult
-		{
-			Running,
-			Completed,
-			AskParent,
-			ResumeOperation,
-			ParentResumed,
-			SuspendOperation
-		}
-
-		public abstract bool IsSourceOperation {
-			get;
-		}
-
-		public virtual bool CheckBreakpointsOnCompletion {
-			get { return false; }
-		}
-
-		protected bool HasChild {
-			get { return child != null; }
-		}
-
-		protected readonly SingleSteppingEngine sse;
-		protected readonly Inferior inferior;
-
-		public readonly CommandResult Result;
-		public Inferior.StackFrame StartFrame;
-
-		protected int ReportBreakpointHit = -1;
-		protected bool ReportSuspend;
-
-		protected Operation (SingleSteppingEngine sse, CommandResult result)
-		{
-			this.sse = sse;
-			this.inferior = sse.inferior;
-
-			if (result != null)
-				this.Result = result;
-			else
-				this.Result = new SimpleCommandResult (this);
-		}
-
-		public virtual void Execute ()
-		{
-			StartFrame = inferior.GetCurrentFrame (true);
-			Report.Debug (DebugFlags.SSE, "{0} executing {1} at {2}",
-				      sse, this, StartFrame != null ?
-				      StartFrame.Address : TargetAddress.Null);
-			DoExecute ();
-		}
-
-		protected abstract void DoExecute ();
-
-		protected virtual void Abort ()
-		{
-			sse.Stop ();
-		}
-
-		public virtual bool ResumeOperation ()
-		{
-			return false;
-		}
-
-		Operation child;
-
-		public void PushOperation (Operation op)
-		{
-			if (child != null)
-				child.PushOperation (op);
-			else
-				child = op;
-		}
-
-		public virtual void CompletedOperation (bool suspended)
-		{
-			if (!suspended) {
-				Result.Completed ();
-				child = null;
-			}
-		}
-
-		public virtual EventResult ProcessEvent (Inferior.ChildEvent cevent,
-							 out TargetEventArgs args)
-		{
-			if (cevent.Type == Inferior.ChildEventType.CHILD_INTERRUPTED) {
-				args = null;
-				if (ResumeOperation ())
-					return EventResult.Running;
-			}
-
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) && (cevent.Argument != 0)) {
-				sse.frame_changed (inferior.CurrentFrame, null);
-				args = new TargetEventArgs (TargetEventType.TargetStopped, (int) cevent.Argument, sse.current_frame);
-				return EventResult.Completed;
-			}
-
-			EventResult result;
-			if (child != null) {
-				Report.Debug (DebugFlags.EventLoop, "{0} child event: {1} {2}", sse, this, cevent);
-
-				result = child.ProcessEvent (cevent, out args);
-
-				Report.Debug (DebugFlags.EventLoop, "{0} child event done: {1} {2} {3} {4}", sse, this, cevent, result, args);
-
-				if (result == EventResult.ParentResumed) {
-					child = null;
-					return EventResult.Running;
-				}
-
-				if ((result != EventResult.AskParent) &&
-				    (result != EventResult.ResumeOperation))
-					return result;
-
-				Operation old_child = child;
-				child = null;
-
-				if ((result == EventResult.ResumeOperation) && ResumeOperation ()) {
-					args = null;
-					return EventResult.Running;
-				}
-
-				Report.Debug (DebugFlags.EventLoop,
-					      "{0} resending event {1} from {2} to {3}",
-					      sse, cevent, old_child, this);
-			}
-
-			result = DoProcessEvent (cevent, out args);
-
-			return result;
-		}
-
-		public virtual EventResult CompletedOperation (Inferior.ChildEvent cevent, EventResult result, ref TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.EventLoop, "{0} operation completed: {1} {2} {3} - {4} {5}",
-				      sse, this, cevent, result, ReportBreakpointHit, ReportSuspend);
-
-			child = null;
-
-			if (ReportSuspend) {
-				result = EventResult.SuspendOperation;
-				ReportSuspend = false;
-			}
-
-			if (result == EventResult.SuspendOperation) {
-				if (!(this is InterruptibleOperation) || !sse.process.Session.Config.NestedBreakStates)
-					result = EventResult.Completed;
-			}
-
-			if (args != null)
-				return result;
-
-			//
-			// We're done with our stepping operation, but first we need to
-			// compute the new StackFrame.  While doing this, `frame_changed'
-			// may discover that we need to do another stepping operation
-			// before telling the user that we're finished.  This is to avoid
-			// that we stop in things like a method's prologue or epilogue
-			// code.  If that happens, we just continue stepping until we reach
-			// the first actual source line in the method.
-			//
-			Operation new_operation = sse.frame_changed (inferior.CurrentFrame, this);
-
-			if ((ReportBreakpointHit < 0) &&
-			    (CheckBreakpointsOnCompletion || (result == EventResult.SuspendOperation))) {
-				int index;
-				bool is_enabled;
-				sse.process.BreakpointManager.LookupBreakpoint (
-					inferior.CurrentFrame, out index, out is_enabled);
-
-				if ((index != 0) && is_enabled)
-					ReportBreakpointHit = index;
-			}
-
-			if (new_operation != null) {
-				Report.Debug (DebugFlags.SSE,
-					      "{0} frame changed at {1} => new operation {2}",
-					      this, inferior.CurrentFrame, new_operation);
-
-				if (cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT)
-					ReportBreakpointHit = (int) cevent.Argument;
-				if (result == EventResult.SuspendOperation)
-					ReportSuspend = true;
-
-				sse.PushOperation (new_operation);
-
-				args = null;
-				return EventResult.Running;
-			}
-
-			//
-			// Now we're really finished.
-			//
-			int bpt_hit = ReportBreakpointHit;
-			ReportBreakpointHit = -1;
-
-			if (cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT)
-				bpt_hit = (int) cevent.Argument;
-
-			if (bpt_hit >= 0) {
-				Breakpoint bpt = sse.lookup_breakpoint (bpt_hit);
-				if ((bpt != null) && bpt.Breaks (sse.Thread.ID) && !bpt.HideFromUser) {
-					args = new TargetEventArgs (
-						TargetEventType.TargetHitBreakpoint, bpt.Index,
-						sse.current_frame);
-					return result;
-				}
-			}
-
-			args = OperationCompleted (sse.current_frame, result == EventResult.SuspendOperation);
-			return result;
-		}
-
-		public virtual TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
-		{
-			return null;
-		}
-
-		protected abstract EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args);
-
-		public virtual bool HandleException (TargetAddress stack, TargetAddress exc)
-		{
-			return true;
-		}
-
-		protected virtual string MyToString ()
-		{
-			return "";
-		}
-
-		public override string ToString ()
-		{
-			if (child == null)
-				return String.Format ("{0} ({1})", GetType ().Name, MyToString ());
-			else
-				return String.Format ("{0}:{1}", GetType ().Name, child);
-		}
-
-		protected class SimpleCommandResult : CommandResult
-		{
-			Operation operation;
-			ManualResetEvent completed_event = new ManualResetEvent (false);
-
-			internal SimpleCommandResult (Operation operation)
-			{
-				this.operation = operation;
-			}
-
-			public override WaitHandle CompletedEvent {
-				get { return completed_event; }
-			}
-
-			public override void Abort ()
-			{
-				operation.Abort ();
-			}
-
-			internal override void Completed ()
-			{
-				completed_event.Set ();
-			}
-		}
-	}
-
-	protected class OperationStart : Operation
-	{
-		public OperationStart (SingleSteppingEngine sse, CommandResult result)
-			: base (sse, result)
-		{ }
-
-		public override bool IsSourceOperation {
-			get { return true; }
-		}
-
-		protected override void DoExecute ()
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} execute start: {1} {2} {3}", sse, sse.ProcessServant.IsAttached,
-				      inferior.CurrentFrame, inferior.EntryPoint);
-
-			if (!sse.ProcessServant.IsAttached)
-				sse.do_continue (inferior.EntryPoint);
-			else
-				sse.ProcessEvent (new Inferior.ChildEvent (Inferior.ChildEventType.CHILD_STOPPED, 0, 0, 0));
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} start: {1} {2} {3} {4}", sse,
-				      cevent, sse.ProcessServant.IsAttached,
-				      inferior.CurrentFrame, inferior.EntryPoint);
-
-			args = null;
-			if ((cevent.Type != Inferior.ChildEventType.CHILD_STOPPED) &&
-			    (cevent.Type != Inferior.ChildEventType.CHILD_CALLBACK))
-				return EventResult.Completed;
-
-			if (sse.Architecture.IsSyscallInstruction (inferior, inferior.CurrentFrame)) {
-				Report.Debug (DebugFlags.SSE,
-					      "{0} start stopped on syscall instruction {1}",
-					      sse, inferior.CurrentFrame);
-				inferior.Step ();
-				return EventResult.Running;
-			}
-
-			sse.ProcessServant.OperatingSystem.UpdateSharedLibraries (inferior);
-			sse.ProcessServant.InitializeThreads (inferior, !sse.ProcessServant.IsAttached);
-
-			if (sse.ProcessServant.IsAttached)
-				return EventResult.Completed;
-
-			if (!sse.ProcessServant.IsManaged) {
-				if (sse.OnModuleLoaded (null))
-					return EventResult.Running;
-			}
-
-			Report.Debug (DebugFlags.SSE, "{0} start #1: {1}", sse, cevent);
-			sse.PushOperation (new OperationStep (sse, StepMode.Run, Result));
-			return EventResult.Running;
-		}
-
-		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
-		{
-			return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
-		}
-
-		public override bool HandleException (TargetAddress stack, TargetAddress exc)
-		{
-			return sse.reached_main ? false : true;
-		}
-	}
-
-	protected class OperationActivateBreakpoints : Operation
-	{
-		public OperationActivateBreakpoints (SingleSteppingEngine sse, Queue pending)
-			: base (sse, null)
-		{
-			this.pending_events = pending;
-		}
-
-		protected override void DoExecute ()
-		{
-			do_execute ();
-		}
-
-		public override bool IsSourceOperation {
-			get { return false; }
-		}
-
-		Queue pending_events;
-		bool completed;
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			args = null;
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} activate breakpoints: {1}", sse, completed);
-
-			while (!completed) {
-				if (do_execute ())
-					return EventResult.Running;
-
-				Report.Debug (DebugFlags.SSE,
-					      "{0} activate breakpoints done - continue", sse);
-
-				return EventResult.ResumeOperation;
-			}
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} activate breakpoints completed", sse);
-			return EventResult.AskParent;
-		}
-
-		bool do_execute ()
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} activate breakpoints execute: {1} {2}", sse,
-				      inferior.CurrentFrame, pending_events.Count);
-
-			if (pending_events.Count == 0) {
-				completed = true;
-				return false;
-			}
-
-			FunctionBreakpointHandle handle =
-				(FunctionBreakpointHandle) pending_events.Dequeue ();
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} activate breakpoints: {1}", sse, handle);
-
-			sse.PushOperation (new OperationInsertBreakpoint (sse, handle));
-			return true;
-		}
-	}
-
-	protected class OperationInsertBreakpoint : OperationCallback
-	{
-		public readonly FunctionBreakpointHandle Handle;
-		public readonly int Index;
-
-		public OperationInsertBreakpoint (SingleSteppingEngine sse,
-						  FunctionBreakpointHandle handle)
-			: base (sse, null)
-		{
-			this.Handle = handle;
-			this.Index = MonoLanguageBackend.GetUniqueID ();
-		}
-
-		protected override void DoExecute ()
-		{
-			MonoDebuggerInfo info = sse.ProcessServant.MonoManager.MonoDebuggerInfo;
-
-			MonoFunctionType func = (MonoFunctionType) Handle.Function;
-			TargetAddress image = func.SymbolFile.MonoImage;
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} insert breakpoint: {1} {2} {3:x}",
-				      sse, func, Index, func.Token);
-
-			inferior.CallMethod (
-				info.InsertSourceBreakpoint, image.Address,
-				func.Token, Index, func.DeclaringType.BaseName, ID);
-		}
-
-		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
-		{
-			TargetAddress info = new TargetAddress (inferior.AddressDomain, data1);
-
-			Report.Debug (DebugFlags.SSE, "{0} insert breakpoint done: {1}", sse, info);
-
-			sse.Process.MonoLanguage.RegisterMethodLoadHandler (inferior, info, Index, Handle.MethodLoaded);
-
-			Handle.Breakpoint.OnBreakpointBound ();
-			args = null;
-			return EventResult.AskParent;
-		}
-	}
-
-	protected class OperationInitAfterFork : Operation
-	{
-		public OperationInitAfterFork (SingleSteppingEngine sse)
-			: base (sse, null)
-		{ }
-
-		public override bool IsSourceOperation {
-			get { return false; }
-		}
-
-		protected override void DoExecute ()
-		{
-			sse.do_continue ();
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} init after fork ({1})", sse,
-				      DebuggerWaitHandle.CurrentThread);
-
-			sse.ProcessServant.BreakpointManager.InitializeAfterFork (inferior);
-
-			args = null;
-			return EventResult.AskParent;
-		}
-	}
-
-	protected class OperationInitCodeBuffer : OperationCallback
-	{
-		public OperationInitCodeBuffer (SingleSteppingEngine sse)
-			: base (sse, null)
-		{ }
-
-		public override bool IsSourceOperation {
-			get { return false; }
-		}
-
-		protected override void DoExecute ()
-		{
-			MonoDebuggerInfo info = sse.ProcessServant.MonoManager.MonoDebuggerInfo;
-			inferior.CallMethod (info.InitCodeBuffer, 0, 0, ID);
-		}
-
-		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} init code buffer: {1:x} {2:x} {3}",
-				      sse, data1, data2, Result);
-
-			TargetAddress buffer = new TargetAddress (inferior.AddressDomain, data1);
-			sse.process.MonoManager.InitCodeBuffer (inferior, buffer);
-
-			RestoreStack ();
-			args = null;
-			return EventResult.AskParent;
-		}
-	}
-
-	protected class OperationStepOverBreakpoint : Operation
-	{
-		TargetAddress until;
-		public readonly int Index;
-		bool has_thread_lock;
-
-		public OperationStepOverBreakpoint (SingleSteppingEngine sse, int index,
-						    TargetAddress until)
-			: base (sse, null)
-		{
-			this.Index = index;
-			this.until = until;
-		}
-
-		public override bool IsSourceOperation {
-			get { return false; }
-		}
-
-		protected override void DoExecute ()
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} stepping over breakpoint: {1}", sse, until);
-
-			sse.process.AcquireGlobalThreadLock (sse);
-			inferior.DisableBreakpoint (Index);
-
-			has_thread_lock = true;
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} stepping over breakpoint {1} at {2} until {3} ({4})",
-				      sse, Index, inferior.CurrentFrame, until, sse.current_method);
-
-			inferior.Step ();
-		}
-
-		bool ReleaseThreadLock (Inferior.ChildEvent cevent)
-		{
-			if (!has_thread_lock)
-				return true;
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} releasing thread lock at {1}",
-				      sse, inferior.CurrentFrame);
-
-			inferior.EnableBreakpoint (Index);
-			sse.process.ReleaseGlobalThreadLock (sse);
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} done releasing thread lock at {1} - {2}",
-				      sse, inferior.CurrentFrame, sse.HasThreadLock);
-
-			has_thread_lock = false;
-
-			if (sse.thread_lock == null)
-				return true;
-
-			sse.thread_lock.SetStopEvent (cevent);
-			return false;
-		}
-
-		public override EventResult ProcessEvent (Inferior.ChildEvent cevent,
-							  out TargetEventArgs args)
-		{
-			if (((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
-			     (cevent.Argument == 0)) ||
-			    ((cevent.Type != Inferior.ChildEventType.CHILD_CALLBACK) &&
-			     (cevent.Type != Inferior.ChildEventType.RUNTIME_INVOKE_DONE))) {
-				if (!ReleaseThreadLock (cevent)) {
-					args = null;
-					return EventResult.Running;
-				}
-			}
-			return base.ProcessEvent (cevent, out args);
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} stepped over breakpoint {1} at {2}: {3} {4}",
-				      sse, Index, inferior.CurrentFrame, cevent, until);
-
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) &&
-			    (cevent.Argument != Index)) {
-				args = null;
-				return EventResult.Completed;
-			}
-
-			if (!until.IsNull) {
-				sse.do_continue (until);
-
-				args = null;
-				until = TargetAddress.Null;
-				return EventResult.Running;
-			}
-
-			args = null;
-			return EventResult.ResumeOperation;
-		}
-	}
-
-	protected class OperationExecuteInstruction : Operation
-	{
-		public readonly byte[] Instruction;
-		public readonly bool UpdateIP;
-
-		bool pushed_code_buffer;
-
-		public OperationExecuteInstruction (SingleSteppingEngine sse, byte[] insn,
-						    bool update_ip)
-			: base (sse, null)
-		{
-			this.Instruction = insn;
-			this.UpdateIP = update_ip;
-		}
-
-		public override bool IsSourceOperation {
-			get { return false; }
-		}
-
-		protected override void DoExecute ()
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} executing instruction: {1}", sse,
-				      TargetBinaryReader.HexDump (Instruction));
-
-			if (!sse.ProcessServant.MonoManager.HasCodeBuffer) {
-				sse.PushOperation (new OperationInitCodeBuffer (sse));
-				pushed_code_buffer = true;
-				return;
-			}
-
-			inferior.ExecuteInstruction (Instruction, UpdateIP);
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} executed instruction at {1}: {2}\n{3}",
-				      sse, inferior.CurrentFrame, cevent,
-				      TargetBinaryReader.HexDump (Instruction));
-
-			args = null;
-			if (pushed_code_buffer) {
-				pushed_code_buffer = false;
-				inferior.ExecuteInstruction (Instruction, UpdateIP);
-				return EventResult.Running;
-			}
-
-			return EventResult.ResumeOperation;
-		}
-	}
-
-	protected abstract class OperationStepBase : Operation
-	{
-		public override bool CheckBreakpointsOnCompletion {
-			get { return true; }
-		}
-
-		protected OperationStepBase (SingleSteppingEngine sse, CommandResult result)
-			: base (sse, result)
-		{ }
-
-		public override void Execute ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} start stepping operation: {1}", sse, this);
-			base.Execute ();
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			args = null;
-			bool completed;
-			if (cevent.Type == Inferior.ChildEventType.CHILD_INTERRUPTED)
-				completed = !ResumeOperation ();
-			else
-				completed = DoProcessEvent ();
-
-			return completed ? EventResult.Completed : EventResult.Running;
-		}
-
-		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
-		{
-			return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
-		}
-
-		protected abstract bool DoProcessEvent ();
-
-		protected abstract bool TrampolineHandler (Method method);
-	}
-
-	protected class OperationStep : OperationStepBase
-	{
-		public readonly StepMode StepMode;
-		public StepFrame StepFrame {
-			get; private set;
-		}
-
-		public OperationStep (SingleSteppingEngine sse, StepMode mode, CommandResult result)
-			: base (sse, result)
-		{
-			this.StepMode = mode;
-		}
-
-		public OperationStep (SingleSteppingEngine sse, StepFrame frame, CommandResult result)
-			: base (sse, result)
-		{
-			this.StepFrame = frame;
-			this.StepMode = frame.Mode;
-		}
-
-		public OperationStep (SingleSteppingEngine sse, StepMode mode, StepFrame frame, CommandResult result)
-			: base (sse, result)
-		{
-			this.StepFrame = frame;
-			this.StepMode = mode;
-		}
-
-		public override bool IsSourceOperation {
-			get {
-				return (StepMode == StepMode.SourceLine) ||
-					(StepMode == StepMode.NextLine) ||
-					(StepMode == StepMode.Finish) ||
-					(StepMode == StepMode.Run);
-			}
-		}
-
-		protected override void DoExecute ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} step execute: {1}", sse, inferior.CurrentFrame);
-
-			switch (StepMode) {
-			case StepMode.Run:
-				if (StepFrame != null)
-					sse.do_continue (StepFrame.Until);
-				else
-					sse.do_continue ();
-				break;
-
-			case StepMode.NativeInstruction:
-				sse.do_step_native ();
-				break;
-
-			case StepMode.NextInstruction:
-				sse.do_next ();
-				break;
-
-			case StepMode.SourceLine:
-				if (StepFrame == null)
-					StepFrame = sse.CreateStepFrame ();
-				if (StepFrame == null)
-					sse.do_step ();
-				else
-					Step (true);
-				break;
-
-			case StepMode.NextLine:
-				// We cannot just set a breakpoint on the next line
-				// since we do not know which way the program's
-				// control flow will go; ie. there may be a jump
-				// instruction before reaching the next line.
-				StepFrame frame = sse.CreateStepFrame ();
-				if (frame == null)
-					sse.do_next ();
-				else {
-					StepFrame = new StepFrame (
-						null, StepMode.Finish, frame.StackFrame,
-						frame.Start, frame.End);
-					Step (true);
-				}
-				break;
-
-			case StepMode.SingleInstruction:
-				StepFrame = sse.CreateStepFrame (StepMode.SingleInstruction);
-				Step (true);
-				break;
-
-			case StepMode.Finish:
-			case StepMode.FinishNative:
-				Step (true);
-				break;
-
-			default:
-				throw new InvalidOperationException ();
-			}
-		}
-
-		public override bool ResumeOperation ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} resuming operation {1}", sse, this);
-
-			if (sse.temp_breakpoint != null) {
-				sse.do_continue ();
-				return true;
-			}
-
-			return !Step (false);
-		}
-
-		public override bool HandleException (TargetAddress stack, TargetAddress exc)
-		{
-			if (StepMode == StepMode.Run)
-				return false;
-			if ((StepMode != StepMode.SourceLine) && (StepMode != StepMode.NextLine) &&
-			    (StepMode != StepMode.StepFrame))
-				return true;
-
-			/*
-			 * If we don't have a StepFrame or if the StepFrame doesn't have a
-			 * SimpleStackFrame, we're doing something like instruction stepping -
-			 * always stop in this case.
-			 */
-			if ((StepFrame == null) || (StepFrame.StackFrame == null))
-				return true;
-
-			StackFrame oframe = StepFrame.StackFrame;
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} handling exception: {1} {2} - {3} {4} - {5}", sse,
-				      StepFrame, oframe, stack, oframe.StackPointer,
-				      stack < oframe.StackPointer);
-
-			if (stack < oframe.StackPointer)
-				return false;
-
-			return true;
-		}
-
-		protected override bool TrampolineHandler (Method method)
-		{
-			if (StepMode == StepMode.SingleInstruction)
-				return true;
-
-			if (method == null)
-				return false;
-
-			if (method.IsInvokeWrapper)
-				return true;
-			else if (method.WrapperType == WrapperType.Alloc)
-				return false;
-
-			if (StepMode == StepMode.SourceLine)
-				return sse.MethodHasSource (method);
-
-			return true;
-		}
-
-		bool check_method_operation (TargetAddress current_frame)
-		{
-			if ((StepMode != StepMode.SourceLine) && (StepMode != StepMode.NextLine))
-				return false;
-
-			Method method = sse.Lookup (current_frame);
-			if (method == null)
-				return false;
-
-			LineNumberTable lnt = method.LineNumberTable;
-			if (lnt.HasMethodBounds && (current_frame >= lnt.MethodEndAddress)) {
-				Report.Debug (DebugFlags.SSE, "{0} reached method epilogue: {1} {2} {3}",
-					      sse, current_frame, lnt.MethodEndAddress, method.EndAddress);
-				StepFrame = new StepFrame (
-					null, StepMode.Finish, null,
-					lnt.MethodEndAddress, method.EndAddress);
-				return true;
-			}
-
-			return false;
-		}
-
-		protected bool Step (bool first)
-		{
-			TargetAddress current_frame = inferior.CurrentFrame;
-
-			if (StepMode == StepMode.Run) {
-				TargetAddress until = StepFrame != null ? StepFrame.Until : TargetAddress.Null;
-				if (!until.IsNull && (current_frame == until))
-					return true;
-				sse.do_continue ();
-				return false;
-			}
-
-			if (StepMode == StepMode.FinishNative) {
-				Inferior.StackFrame frame = inferior.GetCurrentFrame ();
-				TargetAddress stack = frame.StackPointer;
-
-				Report.Debug (DebugFlags.SSE,
-					      "{0} finish native: stack = {1}, " +
-					      "until = {2}", sse, stack, StepFrame.Until);
-
-				if (stack <= StepFrame.Until) {
-					sse.do_next ();
-					return false;
-				}
-			}
-
-		again:
-			bool in_frame = sse.is_in_step_frame (StepFrame, current_frame);
-			Report.Debug (DebugFlags.SSE, "{0} stepping at {1} in {2} ({3}in frame)",
-				      sse, current_frame, StepFrame, !in_frame ? "not " : "");
-
-			if (!first && !in_frame) {
-				if (!check_method_operation (current_frame))
-					return true;
-
-				in_frame = sse.is_in_step_frame (StepFrame, current_frame);
-				goto again;
-			}
-
-			/*
-			 * When StepMode.SingleInstruction was requested, enter the method
-			 * no matter whether it's a system function or not.
-			 */
-			if (StepMode == StepMode.SingleInstruction) {
-				sse.do_step_native ();
-				return false;
-			}
-
-			/*
-			 * If this is not a call instruction, continue stepping until we leave
-			 * the specified step frame.
-			 */
-			Instruction instruction = inferior.Architecture.ReadInstruction (
-				inferior, current_frame);
-			if ((instruction == null) || !instruction.IsCall) {
-				sse.do_step ();
-				return false;
-			}
-
-			if (!instruction.HasInstructionSize) {
-				/* Ooops, we don't know anything about this instruction */
-				sse.do_step ();
-				return false;
-			}
-
-			TargetAddress call_target = instruction.GetEffectiveAddress (inferior);
-
-			if ((sse.current_method != null) && (sse.current_method.HasMethodBounds) &&
-			    !call_target.IsNull &&
-			    (call_target >= sse.current_method.MethodStartAddress) &&
-			    (call_target < sse.current_method.MethodEndAddress)) {
-				/* Intra-method call (we stay outside the prologue/epilogue code,
-				 * so this also can't be a recursive call). */
-				sse.do_step ();
-				return false;
-			}
-
-			/*
-			 * In StepMode.Finish, always step over all methods.
-			 */
-			if ((StepMode == StepMode.Finish) || (StepMode == StepMode.NextLine)) {
-				sse.do_next ();
-				return false;
-			}
-
-			if (sse.CheckTrampoline (instruction, TrampolineHandler))
-				return false;
-
-			/*
-			 * Try to find out whether this is a system function by doing a symbol lookup.
-			 * If it can't be found in the symbol tables, assume it's a system function
-			 * and step over it.
-			 */
-			Method method = sse.Lookup (call_target);
-
-			/*
-			 * If this is a PInvoke/icall/remoting wrapper, check whether we want
-			 * to step into the wrapped function.
-			 */
-			if ((method != null) && (method.WrapperType != WrapperType.None)) {
-				if (method.IsInvokeWrapper) {
-					sse.do_step ();
-					return false;
-				}
-			}
-
-			if (!sse.MethodHasSource (method)) {
-				sse.do_next ();
-				return false;
-			}
-
-			/*
-			 * Finally, step into the method.
-			 */
-			sse.do_step ();
-			return false;
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.EventLoop, "{0} received {1} at {2} in {3}",
-				      sse, cevent, inferior.CurrentFrame, this);
-
-			if ((StepMode == StepMode.Run) &&
-			    ((cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) ||
-			     (cevent.Type == Inferior.ChildEventType.CHILD_CALLBACK) ||
-			     (cevent.Type == Inferior.ChildEventType.RUNTIME_INVOKE_DONE))) {
-				args = null;
-				return EventResult.Completed;
-			}
-
-			return base.DoProcessEvent (cevent, out args);
-		}
-
-		protected override bool DoProcessEvent ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} processing {1} event.",
-				      sse, this);
-			return Step (false);
-		}
-
-		protected override string MyToString ()
-		{
-			return String.Format ("{0}:{1}", StepMode, StepFrame);
-		}
-	}
-
-	protected abstract class OperationCallback : Operation
-	{
-		public readonly long ID = ++next_id;
-		StackData stack_data;
-
-		static int next_id = 0;
-
-		protected OperationCallback (SingleSteppingEngine sse)
-			: base (sse, null)
-		{ }
-
-		protected OperationCallback (SingleSteppingEngine sse, CommandResult result)
-			: base (sse, result)
-		{ }
-
-		public override void Execute ()
-		{
-			stack_data = sse.save_stack (ID);
-			try {
-				base.Execute ();
-			} catch {
-				RestoreStack ();
-				throw;
-			}
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.EventLoop,
-				      "{0} received event {1} at {2} while waiting for " +
-				      "callback {4}:{3}", sse, cevent, inferior.CurrentFrame,
-				      ID, this);
-
-			args = null;
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
-			    (cevent.Argument == 0)) {
-				sse.do_continue ();
-				return EventResult.Running;
-			} else if ((cevent.Type != Inferior.ChildEventType.CHILD_CALLBACK) &&
-				   (cevent.Type != Inferior.ChildEventType.RUNTIME_INVOKE_DONE)) {
-				Report.Debug (DebugFlags.SSE,
-					      "{0} aborting callback {1} ({2}) at {3}: {4}",
-					      sse, this, ID, inferior.CurrentFrame, cevent);
-				AbortOperation ();
-				return EventResult.Completed;
-			}
-
-			if (ID != cevent.Argument) {
-				Report.Debug (DebugFlags.SSE,
-					      "{0} aborting callback {1} ({2}) at {3}: {4}",
-					      sse, this, ID, inferior.CurrentFrame, cevent);
-				AbortOperation ();
-				return EventResult.Completed;
-			}
-
-			try {
-				return CallbackCompleted (cevent.Data1, cevent.Data2, out args);
-			} catch (Exception ex) {
-				Report.Debug (DebugFlags.SSE, "{0} got exception while handling event {1}: {2}",
-					      sse, cevent, ex);
-				RestoreStack ();
-				return EventResult.Completed;
-			}
-		}
-
-		protected abstract EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args);
-
-		public override bool IsSourceOperation {
-			get { return false; }
-		}
-
-		protected void AbortOperation ()
-		{
-			stack_data = null;
-		}
-
-		protected void RestoreStack ()
-		{
-			if (stack_data != null)
-				sse.restore_stack (stack_data);
-			stack_data = null;
-		}
-
-		protected void DiscardStack ()
-		{
-			stack_data = null;
-		}
-	}
-
-	protected class OperationManagedCallback : Operation
-	{
-		ThreadLockData thread_lock;
-		Inferior.ChildEvent stop_event;
-
-		public Queue<ManagedCallbackData> CallbackFunctions {
-			get; private set;
-		}
-
-		public OperationManagedCallback (SingleSteppingEngine sse, ManagedCallbackData data)
-			: base (sse, null)
-		{
-			CallbackFunctions = new Queue<ManagedCallbackData> ();
-			CallbackFunctions.Enqueue (data);
-		}
-
-		public OperationManagedCallback (SingleSteppingEngine sse, Queue<ManagedCallbackData> list)
-			: base (sse, null)
-		{
-			this.CallbackFunctions = list;
-		}
-
-		public override bool IsSourceOperation {
-			get { return false; }
-		}
-
-		ManagedCallbackData current_callback;
-
-		protected override void DoExecute ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} managed callback execute: {1}",
-				      sse, sse.thread_lock);
-
-			if (sse.HasThreadLock) {
-				this.thread_lock = sse.thread_lock;
-				sse.thread_lock = null;
-
-				this.thread_lock.PopRegisters (inferior);
-			}
-
-			if (!do_execute ()) {
-				byte[] nop_insn = sse.Architecture.Opcodes.GenerateNopInstruction ();
-				sse.PushOperation (new OperationExecuteInstruction (sse, nop_insn, false));
-			}
-
-			Report.Debug (DebugFlags.SSE, "{0} managed callback execute done", sse);
-		}
-
-		bool do_execute ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} managed callback execute start: {1}", sse, CallbackFunctions.Count);
-
-			while (CallbackFunctions.Count > 0) {
-				current_callback = CallbackFunctions.Dequeue ();
-				Report.Debug (DebugFlags.SSE, "{0} managed callback execute: {1}",
-					      sse, current_callback.Func);
-				current_callback.Running = true;
-				bool running = current_callback.Func (sse);
-				Report.Debug (DebugFlags.SSE, "{0} managed callback execute done: {1} {2}",
-					      sse, current_callback.Func, running);
-				if (running)
-					return true;
-
-				current_callback.Completed = true;
-
-				current_callback.Result.Completed ();
-			}
-
-			return false;
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.SSE, "{0} managed callback process event: {1} {2} {3}",
-				      sse, cevent, thread_lock, current_callback);
-
-			current_callback.Result.Completed ();
-
-			args = null;
-			if (do_execute ())
-				return EventResult.Running;
-
-			if ((thread_lock != null) && (thread_lock.StopEvent != null)) {
-				sse.ThreadManager.AddPendingEvent (sse, thread_lock.StopEvent);
-				return EventResult.ParentResumed;
-			}
-
-			args = null;
-			return EventResult.ResumeOperation;
-		}
-
-		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
-		{
-			return null;
-		}
-	}
-
-	protected class OperationRuntimeInvoke : InterruptibleOperation
-	{
-		new public readonly RuntimeInvokeResult Result;
-		public readonly MonoFunctionType Function;
-		public readonly TargetStructObject Instance;
-		public readonly TargetObject[] ParamObjects;
-		public readonly RuntimeInvokeFlags Flags;
-
-		bool stopped_somewhere;
-		OperationRuntimeInvokeHelper helper;
-
-		public override bool IsSourceOperation {
-			get { return true; }
-		}
-
-		public bool Debug {
-			get { return (Flags & RuntimeInvokeFlags.BreakOnEntry) != 0; }
-		}
-
-		public bool NestedBreakStates {
-			get {
-				if (!sse.Process.Session.Config.NestedBreakStates)
-					return false;
-
-				return (Flags & RuntimeInvokeFlags.NestedBreakStates) != 0;
-			}
-		}
-
-		protected bool IsVirtual {
-			get { return (Flags & RuntimeInvokeFlags.VirtualMethod) != 0; }
-		}
-
-		public long ID {
-			get { return helper.ID; }
-		}
-
-		public OperationRuntimeInvoke (SingleSteppingEngine sse,
-					       TargetFunctionType function,
-					       TargetStructObject instance,
-					       TargetObject[] param_objects,
-					       RuntimeInvokeFlags flags,
-					       RuntimeInvokeResult result)
-			: base (sse, result)
-		{
-			this.Result = result;
-			this.Function = (MonoFunctionType) function;
-			this.Instance = instance;
-			this.ParamObjects = param_objects;
-			this.Flags = flags;
-		}
-
-		protected override void DoExecute ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} rti execute", sse);
-			if (helper != null)
-				throw new InternalError ("{0} rti already has a helper operation", sse);
-			helper = new OperationRuntimeInvokeHelper (sse, this);
-			Result.ID = helper.ID;
-			sse.PushOperation (helper);
-		}
-
-		public override bool ResumeOperation ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} rti resuming operation {1}", sse, this);
-
-			sse.do_continue ();
-			return true;
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} stopped at {1} during outer runtime-invoke: {2}",
-				      sse, inferior.CurrentFrame, cevent);
-
-			args = null;
-
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
-			    (cevent.Argument == 0)) {
-				if (Debug && (inferior.CurrentFrame == helper.InvokeMethod)) {
-					if (NestedBreakStates)
-						return EventResult.SuspendOperation;
-					else
-						return EventResult.Completed;
-				}
-
-				goto resume_target;
-			} else if (cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) {
-				if (NestedBreakStates)
-					return EventResult.SuspendOperation;
-				if (Debug)
-					return EventResult.Completed;
-
-				goto resume_target;
-			}
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} stopped abnormally at {1} during outer runtime-invoke: {2}",
-				      sse, inferior.CurrentFrame, cevent);
-			return EventResult.Completed;
-
-		resume_target:
-			Report.Debug (DebugFlags.SSE,
-				      "{0} resuming target during runtime-invoke", sse);
-
-			sse.do_continue ();
-			return EventResult.Running;
-		}
-
-		public override bool HandleException (TargetAddress stack, TargetAddress exc)
-		{
-			return false;
-		}
-
-		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
-		{
-			Completed (data1, data2);
-
-			args = null;
-			return EventResult.Completed;
-		}
-
-		public void Completed (long data1, long data2)
-		{
-			Report.Debug (DebugFlags.SSE, "{0} completed runtime-invoke: {1:x} {2:x}", sse, data1, data2);
-
-			MonoLanguageBackend language = sse.process.MonoLanguage;
-
-			if (data2 != 0) {
-				TargetAddress exc_address = new TargetAddress (inferior.AddressDomain, data2);
-				TargetFundamentalObject exc_obj = (TargetFundamentalObject) language.CreateObject (inferior, exc_address);
-
-				Result.ExceptionMessage = (string) exc_obj.GetObject (inferior);
-			}
-
-			if (data1 != 0) {
-				TargetAddress retval_address = new TargetAddress (inferior.AddressDomain, data1);
-				Result.ReturnObject = language.CreateObject (inferior, retval_address);
-
-				Report.Debug (DebugFlags.SSE, "{0} rti done: {1} {2}", sse, retval_address, Result.ReturnObject);
-			}
-
-			helper.CompletedRTI ();
-			Result.InvocationCompleted = true;
-		}
-
-		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
-		{
-			if (Result.InvocationCompleted || Result.InvocationAborted) {
-				if (stopped_somewhere || ((Flags & RuntimeInvokeFlags.SendEventOnCompletion) != 0))
-					return new TargetEventArgs (TargetEventType.RuntimeInvokeDone, Result, frame);
-				else
-					return null;
-			}
-
-			stopped_somewhere = true;
-			return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
-		}
-
-		public void Abort ()
-		{
-			inferior.AbortInvoke (ID);
-			Result.InvocationAborted = true;
-		}
-
-		protected class OperationRuntimeInvokeHelper : OperationCallback
-		{
-			public readonly OperationRuntimeInvoke RTI;
-
-			MonoLanguageBackend language;
-			TargetAddress method = TargetAddress.Null;
-			TargetAddress invoke = TargetAddress.Null;
-			TargetStructObject instance;
-			MonoClassInfo class_info;
-			Stage stage;
-
-			protected enum Stage {
-				Uninitialized,
-				ResolvedClass,
-				BoxingInstance,
-				HasMethodAddress,
-				GettingVirtualMethod,
-				HasVirtualMethod,
-				CompilingMethod,
-				CompiledMethod,
-				InvokedMethod
-			}
-
-			public override bool IsSourceOperation {
-				get { return false; }
-			}
-
-			public TargetAddress InvokeMethod {
-				get { return invoke; }
-			}
-
-			public OperationRuntimeInvokeHelper (SingleSteppingEngine sse,
-							     OperationRuntimeInvoke rti)
-				: base (sse)
-			{
-				this.RTI = rti;
-
-				this.instance = RTI.Instance;
-				this.method = TargetAddress.Null;
-				this.stage = Stage.Uninitialized;
-			}
-
-			protected override void DoExecute ()
-			{
-				language = sse.process.MonoLanguage;
-
-				class_info = RTI.Function.ResolveClass (inferior, false);
-				if (class_info == null) {
-					MonoClassType klass = RTI.Function.DeclaringType as MonoClassType;
-					if (klass == null)
-						throw new TargetException (TargetError.ClassNotInitialized,
-									   "Class `{0}' not initialized yet.",
-									   RTI.Function.DeclaringType.Name);
-
-					TargetAddress image = RTI.Function.SymbolFile.MonoImage;
-					int token = klass.Token;
-
-					Report.Debug (DebugFlags.SSE,
-						      "{0} rti resolving class {1}:{2:x}", sse, image, token);
-
-					inferior.CallMethod (
-						sse.MonoDebuggerInfo.LookupClass, image.Address, 0, 0,
-						RTI.Function.DeclaringType.Name, ID);
-					return;
-				}
-
-				stage = Stage.ResolvedClass;
-				do_execute ();
-			}
-
-			void do_execute ()
-			{
-				switch (stage) {
-				case Stage.ResolvedClass:
-					if (!get_method_address ())
-						throw new TargetException (TargetError.ClassNotInitialized,
-									   "Class `{0}' not initialized yet.",
-									   RTI.Function.DeclaringType.Name);
-					goto case Stage.HasMethodAddress;
-
-				case Stage.HasMethodAddress:
-					if (!get_virtual_method ())
-						return;
-					goto case Stage.HasVirtualMethod;
-
-				case Stage.HasVirtualMethod: {
-					Report.Debug (DebugFlags.SSE,
-						      "{0} rti compiling method: {1}", sse, method);
-
-					stage = Stage.CompilingMethod;
-					inferior.CallMethod (
-						sse.MonoDebuggerInfo.CompileMethod, method.Address, 0, ID);
-					return;
-				}
-
-				case Stage.CompiledMethod: {
-					sse.insert_temporary_breakpoint (invoke);
-					sse.rti_stack.Push (RTI);
-
-					inferior.RuntimeInvoke (
-						sse.MonoDebuggerInfo.RuntimeInvoke,
-						method, instance, RTI.ParamObjects, ID, RTI.Debug);
-
-					stage = Stage.InvokedMethod;
-					return;
-				}
-
-				default:
-					throw new InternalError ();
-				}
-			}
-
-			bool get_method_address ()
-			{
-				method = class_info.GetMethodAddress (inferior, RTI.Function.Token);
-				if (method.IsNull)
-					return false;
-
-				if ((instance == null) || instance.Type.IsByRef)
-					return true;
-
-				TargetType decl = RTI.Function.DeclaringType;
-				if ((decl.Name != "System.ValueType") && (decl.Name != "System.Object"))
-					return true;
-
-				TargetStructType parent_type = RTI.Instance.Type.GetParentType (inferior);
-
-				if (!instance.Type.IsByRef && parent_type.IsByRef) {
-					TargetAddress klass = ((MonoClassObject) instance).KlassAddress;
-					stage = Stage.BoxingInstance;
-					inferior.CallMethod (
-						sse.MonoDebuggerInfo.GetBoxedObjectMethod, klass.Address,
-						instance.Location.GetAddress (inferior).Address, ID);
-					return false;
-				}
-
-				return true;
-			}
-
-			bool get_virtual_method ()
-			{
-				if (!RTI.IsVirtual || (instance == null) || !instance.HasAddress ||
-				    !instance.Type.IsByRef)
-					return true;
-
-				Report.Debug (DebugFlags.SSE, "{0} rti get virtual method: {1}", sse, instance);
-
-				stage = Stage.GettingVirtualMethod;
-				inferior.CallMethod (
-					sse.MonoDebuggerInfo.GetVirtualMethod,
-					instance.Location.GetAddress (inferior).Address,
-					method.Address, ID);
-				return false;
-			}
-
-			protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
-			{
-				switch (stage) {
-				case Stage.Uninitialized: {
-					TargetAddress klass = new TargetAddress (inferior.AddressDomain, data1);
-
-					Report.Debug (DebugFlags.SSE,
-						      "{0} rti resolved class: {1}", sse, klass);
-
-					class_info = language.ReadClassInfo (inferior, klass);
-					((IMonoStructType) RTI.Function.DeclaringType).ClassInfo = class_info;
-					((IMonoStructType) RTI.Function.DeclaringType).ResolveClass (inferior, false);
-					stage = Stage.ResolvedClass;
-					do_execute ();
-					args = null;
-					return EventResult.Running;
-				}
-
-				case Stage.BoxingInstance: {
-					TargetAddress boxed = new TargetAddress (inferior.AddressDomain, data1);
-
-					Report.Debug (DebugFlags.SSE,
-						      "{0} rti boxed object: {1}", sse, boxed);
-
-					TargetLocation new_loc = new AbsoluteTargetLocation (boxed);
-					TargetStructType parent_type = instance.Type.GetParentType (inferior);
-					instance = (TargetStructObject) parent_type.GetObject (inferior, new_loc);
-					stage = Stage.HasMethodAddress;
-					do_execute ();
-					args = null;
-					return EventResult.Running;
-				}
-
-				case Stage.GettingVirtualMethod: {
-					method = new TargetAddress (inferior.AddressDomain, data1);
-
-					Report.Debug (DebugFlags.SSE,
-						      "{0} rti got virtual method: {1}", sse, method);
-
-					TargetAddress klass = inferior.ReadAddress (method + 8);
-					TargetType class_type = language.ReadMonoClass (inferior, klass);
-
-					if (class_type == null) {
-						RTI.Result.ExceptionMessage = String.Format (
-							"Unable to get virtual method `{0}'.", RTI.Function.FullName);
-						RTI.Result.InvocationCompleted = true;
-						RestoreStack ();
-						args = null;
-						return EventResult.Completed;
-					}
-
-					if (!class_type.IsByRef) {
-						TargetLocation new_loc = instance.Location.GetLocationAtOffset (
-							2 * inferior.TargetMemoryInfo.TargetAddressSize);
-						instance = (TargetClassObject) class_type.GetObject (
-							inferior, new_loc);
-					}
-
-					Report.Debug (DebugFlags.SSE,
-						      "{0} rti got virtual method #1: {1} {2}", sse, class_type,
-						      instance);
-
-					stage = Stage.HasVirtualMethod;
-					do_execute ();
-					args = null;
-					return EventResult.Running;
-				}
-
-				case Stage.CompilingMethod: {
-					invoke = new TargetAddress (inferior.AddressDomain, data1);
-
-					Report.Debug (DebugFlags.SSE,
-						      "{0} rti compiled method: {1}", sse, invoke);
-
-					stage = Stage.CompiledMethod;
-					do_execute ();
-					args = null;
-					return EventResult.Running;
-				}
-
-				case Stage.InvokedMethod: {
-					RTI.Completed (data1, data2);
-					RestoreStack ();
-					args = null;
-					return EventResult.Completed;
-				}
-
-				default:
-					throw new InternalError ();
-				}
-			}
-
-			protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-								       out TargetEventArgs args)
-			{
-				if ((cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) ||
-				    ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
-				     (cevent.Argument == 0))) {
-					if (inferior.CurrentFrame == invoke) {
-						Report.Debug (DebugFlags.SSE,
-							      "{0} stopped at invoke method {1} / {2}",
-							      sse, invoke, stage);
-
-						inferior.MarkRuntimeInvokeFrame ();
-						RTI.SetupCallback (ID);
-
-						args = null;
-						return EventResult.AskParent;
-					} 
-
-					Report.Debug (DebugFlags.SSE,
-						      "{0} stopped at {1} during runtime-invoke: {2}",
-						      sse, inferior.CurrentFrame, cevent);
-				}
-
-				return base.DoProcessEvent (cevent, out args);
-			}
-
-			public override bool HandleException (TargetAddress stack, TargetAddress exc)
-			{
-				return false;
-			}
-
-			public void CompletedRTI ()
-			{
-				RestoreStack ();
-			}
-		}
-	}
-
-	protected class OperationCallMethod : OperationCallback
-	{
-		public readonly CallMethodType Type;
-		public readonly TargetAddress Method;
-		public readonly long Argument1;
-		public readonly long Argument2;
-		public readonly long Argument3;
-		public readonly TargetObject ObjectArgument;
-		public readonly string StringArgument;
-
-		public OperationCallMethod (SingleSteppingEngine sse,
-					    TargetAddress method, long arg1, long arg2, long arg3,
-					    string sarg)
-			: base (sse)
-		{
-			this.Type = CallMethodType.LongLongLongString;
-			this.Method = method;
-			this.Argument1 = arg1;
-			this.Argument2 = arg2;
-			this.Argument3 = arg3;
-			this.StringArgument = sarg;
-		}
-
-		public OperationCallMethod (SingleSteppingEngine sse,
-					    TargetAddress method, long arg1, long arg2)
-			: base (sse)
-		{
-			this.Type = CallMethodType.LongLong;
-			this.Method = method;
-			this.Argument1 = arg1;
-			this.Argument2 = arg2;
-		}
-
-		public OperationCallMethod (SingleSteppingEngine sse, TargetAddress method,
-					    TargetAddress method_arg, TargetObject object_arg)
-			: base (sse)
-		{
-			this.Type = CallMethodType.LongObject;
-			this.Method = method;
-			this.Argument1 = method_arg.Address;
-			this.ObjectArgument = object_arg;
-		}
-
-		bool interrupted_syscall;
-
-		protected override void DoExecute ()
-		{
-			if (!interrupted_syscall &&
-			    inferior.Architecture.IsSyscallInstruction (inferior, inferior.CurrentFrame)) {
-				if (!sse.Process.CanExecuteCode)
-					throw new TargetException (TargetError.InvocationException,
-								   "Current thread stopped on a system " +
-								   "call; cannot invoke any methods");
-
-				/*
-				 * The backend automatically sets %orig_rax to -1 before modifying %rip
-				 * to prevent the kernel from restarting the system call.
-				 *
-				 * Unfortunately, the kernel clobbers %rcx, which may be used to pass
-				 * parameters to the method.  Because of this, we need to execute a
-				 * dummy instruction first.
-				 */
-				byte[] nop_insn = inferior.Architecture.Opcodes.GenerateNopInstruction ();
-				sse.PushOperation (new OperationExecuteInstruction (sse, nop_insn, false));
-				interrupted_syscall = true;
-				return;
-			}
-
-			interrupted_syscall = false;
-
-			switch (Type) {
-			case CallMethodType.LongLong:
-				inferior.CallMethod (Method, Argument1, Argument2, ID);
-				break;
-
-			case CallMethodType.LongLongLongString:
-				inferior.CallMethod (Method, Argument1, Argument2, Argument3,
-						     StringArgument, ID);
-				break;
-
-			case CallMethodType.LongObject:
-				inferior.CallMethod (Method, Argument1, ObjectArgument, ID);
-				break;
-
-			default:
-				throw new InvalidOperationException ();
-			}
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			if (!interrupted_syscall)
-				return base.DoProcessEvent (cevent, out args);
-
-			Report.Debug (DebugFlags.EventLoop,
-				      "{0} received event {1} at {2} while waiting for " +
-				      "callback {4}:{3}", sse, cevent, inferior.CurrentFrame,
-				      ID, this);
-
-			args = null;
-			if ((cevent.Type != Inferior.ChildEventType.CHILD_STOPPED) &&
-			    (cevent.Argument != 0)) {
-				Report.Debug (DebugFlags.SSE,
-					      "{0} aborting callback {1} ({2}) at {3}: {4}",
-					      sse, this, ID, inferior.CurrentFrame, cevent);
-				AbortOperation ();
-				return EventResult.Completed;
-			}
-
-			DoExecute ();
-			return EventResult.Running;
-		}
-
-		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
-		{
-			if (inferior.TargetAddressSize == 4)
-				data1 &= 0xffffffffL;
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} call method done: {1:x} {2:x} {3}",
-				      sse, data1, data2, Result);
-
-			RestoreStack ();
-			Result.Result = new TargetAddress (inferior.AddressDomain, data1);
-			args = null;
-			return EventResult.Completed;
-		}
-	}
-
-	protected class OperationMonoTrampoline : Operation
-	{
-		public readonly Instruction CallSite;
-		public readonly TargetAddress Trampoline;
-		public readonly TrampolineHandler TrampolineHandler;
-
-		bool compiled;
-
-		public OperationMonoTrampoline (SingleSteppingEngine sse, Instruction call_site,
-						TargetAddress trampoline, TrampolineHandler handler)
-			: base (sse, null)
-		{
-			this.CallSite = call_site;
-			this.Trampoline = trampoline;
-			this.TrampolineHandler = handler;
-		}
-
-		public override bool IsSourceOperation {
-			get { return true; }
-		}
-
-		protected override void DoExecute ()
-		{
-			sse.enable_extended_notification (NotificationType.Trampoline);
-			sse.do_continue ();
-		}
-
-		public override bool ResumeOperation ()
-		{
-			sse.do_continue ();
-			return true;
-		}
-
-		protected void TrampolineCompiled (TargetAddress mono_method, TargetAddress code)
-		{
-			sse.disable_extended_notification (NotificationType.Trampoline);
-
-			if (TrampolineHandler != null) {
-				Method method = sse.Lookup (code);
-				if (!TrampolineHandler (method)) {
-					sse.do_continue (CallSite.Address + CallSite.InstructionSize);
-					return;
-				}
-			}
-
-			sse.do_continue (code);
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_NOTIFICATION) &&
-			    ((NotificationType) cevent.Argument == NotificationType.Trampoline)) {
-				TargetAddress method = new TargetAddress (
-					inferior.AddressDomain, cevent.Data1);
-				TargetAddress code = new TargetAddress (
-					inferior.AddressDomain, cevent.Data2);
-
-				args = null;
-				compiled = true;
-				TrampolineCompiled (method, code);
-				return EventResult.Running;
-			}
-
-			args = null;
-			if (!compiled) {
-				sse.disable_extended_notification (NotificationType.Trampoline);
-				return EventResult.Completed;
-			} else
-				return EventResult.ResumeOperation;
-		}
-	}
-
-	protected class OperationNativeTrampoline : Operation
-	{
-		public readonly TrampolineHandler TrampolineHandler;
-		public readonly TargetAddress Trampoline;
-
-		TargetAddress stack_pointer;
-		bool entered_trampoline;
-		bool done;
-
-		public OperationNativeTrampoline (SingleSteppingEngine sse, TargetAddress trampoline,
-						  TrampolineHandler handler)
-			: base (sse, null)
-		{
-			this.TrampolineHandler = handler;
-			this.Trampoline = trampoline;
-		}
-
-		public override bool IsSourceOperation {
-			get { return true; }
-		}
-
-		protected override void DoExecute ()
-		{
-			Inferior.StackFrame frame = inferior.GetCurrentFrame ();
-			stack_pointer = frame.StackPointer;
-
-			Report.Debug (DebugFlags.SSE,
-				      "{0} starting native trampoline {1} at {2}: {3}",
-				      sse, Trampoline, frame.Address, stack_pointer);
-
-			sse.do_continue (Trampoline);
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} native trampoline event: {1}", sse, cevent);
-
-			args = null;
-
-			Inferior.StackFrame frame = inferior.GetCurrentFrame ();
-
-			if (done)
-				return EventResult.Completed;
-
-			if (!entered_trampoline) {
-				stack_pointer = frame.StackPointer;
-
-				sse.do_step_native ();
-				entered_trampoline = true;
-				return EventResult.Running;
-			}
-
-			if (frame.StackPointer <= stack_pointer) {
-				sse.do_next ();
-				return EventResult.Running;
-			}
-
-			done = true;
-
-			Instruction instruction = sse.Architecture.ReadInstruction (
-				inferior, frame.Address);
-			if ((instruction == null) || !instruction.HasInstructionSize) {
-				sse.do_step_native ();
-				return EventResult.Running;
-			}
-
-			if (instruction.InstructionType != Instruction.Type.Jump) {
-				sse.do_step_native ();
-				return EventResult.Running;
-			}
-
-			return EventResult.Completed;
-		}
-	}
-
-	protected class OperationException : Operation
-	{
-		TargetAddress ip;
-		TargetAddress exc;
-		TargetObject exc_object;
-		bool unhandled;
-
-		public OperationException (SingleSteppingEngine sse, TargetAddress ip, TargetAddress exc,
-					   bool unhandled)
-			: base (sse, null)
-		{
-			this.ip = ip;
-			this.exc = exc;
-			this.unhandled = unhandled;
-		}
-
-		public override bool IsSourceOperation {
-			get { return false; }
-		}
-
-		protected override void DoExecute ()
-		{
-			try {
-				exc_object = sse.ProcessServant.MonoLanguage.CreateObject (inferior, exc);
-			} catch {
-				exc_object = null;
-			}
-
-			sse.remove_temporary_breakpoint ();
-			sse.do_continue (ip);
-		}
-
-		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
-							       out TargetEventArgs args)
-		{
-			Report.Debug (DebugFlags.SSE,
-				      "{0} processing OperationException at {1}: {2} {3} {4}",
-				      sse, inferior.CurrentFrame, ip, exc, unhandled);
-
-			if (unhandled) {
-				sse.frame_changed (inferior.CurrentFrame, null);
-				sse.current_frame.SetExceptionObject (exc_object);
-				args = new TargetEventArgs (
-					TargetEventType.UnhandledException,
-					exc_object, sse.current_frame);
-				return EventResult.SuspendOperation;
-			} else {
-				sse.frame_changed (inferior.CurrentFrame, null);
-				sse.current_frame.SetExceptionObject (exc_object);
-				args = new TargetEventArgs (
-					TargetEventType.Exception,
-					exc_object, sse.current_frame);
-				return EventResult.SuspendOperation;
-			}
-		}
-	}
-
-	protected class OperationWrapper : OperationStepBase
-	{
-		Method method;
-
-		public OperationWrapper (SingleSteppingEngine sse,
-					 Method method, CommandResult result)
-			: base (sse, result)
-		{
-			this.method = method;
-		}
-
-		public override bool IsSourceOperation {
-			get { return true; }
-		}
-
-		protected override void DoExecute ()
-		{
-			sse.do_step ();
-		}
-
-		protected override bool DoProcessEvent ()
-		{
-			TargetAddress current_frame = inferior.CurrentFrame;
-
-			Report.Debug (DebugFlags.SSE, "{0} wrapper stopped at {1} ({2}:{3})",
-				      sse, current_frame, method.StartAddress, method.EndAddress);
-			if ((current_frame < method.StartAddress) || (current_frame > method.EndAddress))
-				return true;
-
-			/*
-			 * If this is not a call instruction, continue stepping until we leave
-			 * the current method.
-			 */
-			Instruction instruction = inferior.Architecture.ReadInstruction (
-				inferior, current_frame);
-			if ((instruction == null) || !instruction.HasInstructionSize) {
-				sse.do_step ();
-				return false;
-			}
-
-			if (sse.CheckTrampoline (instruction, TrampolineHandler))
-				return false;
-
-			sse.do_step ();
-			return false;
-		}
-
-		protected override bool TrampolineHandler (Method method)
-		{
-			if (method == null)
-				return false;
-
-			if (method.IsInvokeWrapper)
-				return true;
-
-			return sse.MethodHasSource (method);
-		}
-	}
-
-	protected class OperationDelegateInvoke : OperationStepBase
-	{
-		public OperationDelegateInvoke (SingleSteppingEngine sse)
-			: base (sse, null)
-		{ }
-
-		public override bool IsSourceOperation {
-			get { return true; }
-		}
-
-		protected override void DoExecute ()
-		{
-			sse.do_step ();
-		}
-
-		bool finished;
-
-		protected override bool DoProcessEvent ()
-		{
-			TargetAddress current_frame = inferior.CurrentFrame;
-
-			Report.Debug (DebugFlags.SSE, "{0} delegate impl stopped at {1}",
-				      sse, current_frame);
-
-			if (finished)
-				return true;
-
-			/*
-			 * If this is not a call instruction, continue stepping until we leave
-			 * the current method.
-			 */
-			Instruction instruction = inferior.Architecture.ReadInstruction (
-				inferior, current_frame);
-			if ((instruction == null) || !instruction.HasInstructionSize) {
-				sse.do_step ();
-				return false;
-			}
-
-			Report.Debug (DebugFlags.SSE, "{0} delegate impl stopped at {1}: {2}",
-				      sse, current_frame, instruction);
-
-			if ((instruction.InstructionType == Instruction.Type.IndirectJump) ||
-			    (instruction.InstructionType == Instruction.Type.IndirectCall))
-				finished = true;
-
-			sse.do_step ();
-			return false;
-		}
-
-		protected override bool TrampolineHandler (Method method)
-		{
-			return false;
-		}
-	}
-
-	protected class OperationStepIterator : OperationStepBase
-	{
-		Method method;
-
-		public OperationStepIterator (SingleSteppingEngine sse,
-					      Method method, CommandResult result)
-			: base (sse, result)
-		{
-			this.method = method;
-		}
-
-		public override bool IsSourceOperation {
-			get { return true; }
-		}
-
-		protected override void DoExecute ()
-		{
-			sse.do_next ();
-		}
-
-		protected override bool DoProcessEvent ()
-		{
-			TargetAddress current_frame = inferior.CurrentFrame;
-
-			Report.Debug (DebugFlags.SSE, "{0} iterator stopped at {1} ({2}:{3})",
-				      sse, current_frame, method.StartAddress, method.EndAddress);
-			if ((current_frame < method.StartAddress) || (current_frame > method.EndAddress))
-				return true;
-
-			Block block = method.LookupBlock (inferior, current_frame);
-			Report.Debug (DebugFlags.SSE, "{0} iterator block: {1}", sse, block);
-			if ((block != null) && block.IsIteratorBody)
-				return true;
-
-			sse.do_next ();
-			return false;
-		}
-
-		protected override bool TrampolineHandler (Method method)
-		{
-			if (method == null)
-				return false;
-
-			if (method.IsInvokeWrapper)
-				return true;
-
-			return sse.MethodHasSource (method);
-		}
-	}
-
-	protected class OperationStepCompilerGenerated : OperationStepBase
-	{
-		Method method;
-		Block block;
-
-		public OperationStepCompilerGenerated (SingleSteppingEngine sse, Method method,
-						       Block block, CommandResult result)
-			: base (sse, result)
-		{
-			this.method = method;
-			this.block = block;
-		}
-
-		public override bool IsSourceOperation {
-			get { return true; }
-		}
-
-		protected override void DoExecute ()
-		{
-			sse.do_next ();
-		}
-
-		protected override bool DoProcessEvent ()
-		{
-			TargetAddress current_frame = inferior.CurrentFrame;
-
-			Report.Debug (DebugFlags.SSE, "{0} compiler generated stopped at {1} ({2}:{3})",
-				      sse, current_frame, block.StartAddress, block.EndAddress);
-			if ((current_frame < method.StartAddress + block.StartAddress) ||
-			    (current_frame > method.StartAddress + block.EndAddress))
-				return true;
-
-			sse.do_next ();
-			return false;
-		}
-
-		protected override bool TrampolineHandler (Method method)
-		{
-			if (method == null)
-				return false;
-
-			if (method.IsInvokeWrapper)
-				return true;
-
-			return sse.MethodHasSource (method);
-		}
-	}
-
-	protected class OperationReturn : OperationCallback
-	{
-		public readonly Backtrace Backtrace;
-		public readonly ReturnMode Mode;
-		OperationRuntimeInvoke aborted_rti;
-		int level = 0;
-
-		public OperationReturn (SingleSteppingEngine sse, Backtrace bt, ReturnMode mode)
-			: base (sse)
-		{
-			this.Backtrace = bt;
-			this.Mode = mode;
-		}
-
-		protected override void DoExecute ()
-		{
-			Report.Debug (DebugFlags.SSE, "{0} executing return: {1} {2}\n{2}", sse, Mode, level, Backtrace.Print ());
-			inferior.CallMethod (sse.MonoDebuggerInfo.RunFinally, null, ID);
-		}
-
-		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
-		{
-			args = null;
-			StackFrame parent_frame = Backtrace.Frames [++level];
-			inferior.SetRegisters (parent_frame.Registers);
-
-			Inferior.CallbackFrame cframe = inferior.GetCallbackFrame (parent_frame.StackPointer, true);
-			Report.Debug (DebugFlags.SSE, "{0} return: {1} {2}\n{3}", sse, level, cframe, parent_frame);
-			if (cframe != null) {
-				Report.Debug (DebugFlags.SSE, "{0} return aborting rti: {1}", sse, cframe);
-				aborted_rti = sse.AbortRuntimeInvoke (cframe.ID);
-				return EventResult.Completed;
-			}
-
-			if (level == Backtrace.Count) {
-				Report.Debug (DebugFlags.SSE, "{0} completed return", sse);
-				return EventResult.Completed;
-			}
-
-			DoExecute ();
-			return EventResult.Running;
-		}
-
-		public override TargetEventArgs OperationCompleted (StackFrame frame, bool suspended)
-		{
-			if (aborted_rti != null)
-				return aborted_rti.OperationCompleted (frame, suspended);
-			else
-				return new TargetEventArgs (TargetEventType.TargetStopped, 0, frame);
-		}
-	}
-
-	protected abstract class InterruptibleOperation : Operation
-	{
-		public bool IsSuspended {
-			get; set;
-		}
-
-		protected InterruptibleOperation (SingleSteppingEngine sse, CommandResult result)
-			: base (sse, result)
-		{ }
-
-		long callback_id;
-
-		public override EventResult ProcessEvent (Inferior.ChildEvent cevent,
-							  out TargetEventArgs args)
-		{
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_CALLBACK) ||
-			    (cevent.Type == Inferior.ChildEventType.RUNTIME_INVOKE_DONE)) {
-				if ((callback_id > 0) && (cevent.Argument == callback_id))
-					return CallbackCompleted (cevent.Data1, cevent.Data2, out args);
-			}
-
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) && (cevent.Argument != 0)) {
-				sse.frame_changed (inferior.CurrentFrame, null);
-				args = new TargetEventArgs (TargetEventType.TargetStopped, (int) cevent.Argument, sse.current_frame);
-				return EventResult.SuspendOperation;
-			}
-
-			return base.ProcessEvent (cevent, out args);
-		}
-
-		protected void SetupCallback (long id)
-		{
-			Report.Debug (DebugFlags.SSE, "{0} interruptible operation setup callback: {1}", sse, id);
-			this.callback_id = id;
-		}
-
-		protected abstract EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args);
-	}
-#endregion
-	}
-
-	internal class ManagedCallbackData
-	{
-		public readonly ManagedCallbackFunction Func;
-		public readonly CommandResult Result;
-
-		public bool Running;
-		public bool Completed;
-
-		public ManagedCallbackData (ManagedCallbackFunction func, CommandResult result)
-		{
-			this.Func = func;
-			this.Result = result;
-		}
-	}
-
-	[Serializable]
-	internal enum CommandType {
-		TargetAccess,
-		CreateProcess
-	}
-
-	[Serializable]
-	internal class Command {
-		public SingleSteppingEngine Engine;
-		public readonly CommandType Type;
-		public object Data1, Data2;
-		public object Result;
-
-		public Command (SingleSteppingEngine sse, TargetAccessDelegate func, object data)
-		{
-			this.Type = CommandType.TargetAccess;
-			this.Engine = sse;
-			this.Data1 = func;
-			this.Data2 = data;
-		}
-
-		public Command (CommandType type, object data)
-		{
-			this.Type = type;
-			this.Data1 = data;
-		}
-
-		public override string ToString ()
-		{
-			return String.Format ("Command ({0}:{1}:{2}:{3})",
-					      Engine, Type, Data1, Data2);
-		}
-	}
-
-	[Serializable]
-	internal enum CallMethodType
-	{
-		LongLong,
-		LongLongLongString,
-		LongObject
-	}
-}
diff --git a/frontend/Command.cs b/frontend/Command.cs
index 4d8863c..9931e20 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -1247,12 +1247,17 @@ namespace Mono.Debugger.Frontend
 						"a thread (see `help thread_expression' for details).\n"; } }
 	}
 
-	public class BackgroundThreadCommand : ThreadCommand, IDocumentableCommand
+	public class BackgroundThreadCommand : SteppingCommand, IDocumentableCommand
 	{
-		protected override object DoExecute (ScriptingContext context)
+		protected override bool DoResolveBase (ScriptingContext context)
 		{
-			CurrentThread.Background ();
-			return null;
+			InBackground = true;
+			return base.DoResolveBase (context);
+		}
+
+		protected override CommandResult DoStep (Thread thread, ThreadingModel model, ScriptingContext context)
+		{
+			return thread.Step (model, StepMode.Run, null);
 		}
 
 		// IDocumentableCommand
@@ -1305,6 +1310,7 @@ namespace Mono.Debugger.Frontend
 	public abstract class SteppingCommand : ThreadCommand
 	{
 		ThreadingModel threading_model;
+		bool wait;
 
 		[Property ("in-background", "bg")]
 		public bool InBackground {
@@ -1314,7 +1320,8 @@ namespace Mono.Debugger.Frontend
 		[Obsolete]
 		[Property ("wait")]
 		public bool Wait {
-			get; set;
+			get { return wait; }
+			set { wait = value; }
 		}
 
 		[Property ("single-thread", "single")]
@@ -1332,7 +1339,7 @@ namespace Mono.Debugger.Frontend
 			threading_model = context.Interpreter.DebuggerConfiguration.ThreadingModel;
 			if (SingleThread && EntireProcess)
 				throw new ScriptingException ("Cannot use both `-single-thread' and `-entire-process'.");
-			if (Wait) {
+			if (wait) {
 				if (SingleThread || EntireProcess)
 					throw new ScriptingException ("Cannot use `-single-thread' or `-entire-process' together with `-wait'.");
 				threading_model &= ~ThreadingModel.ThreadingMode;

--------------1.5.6--



From 6d919ca600b5f0c6d4efd6a3bae11ed7b92e1006 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 15 Jul 2009 05:48:52 +0200
Subject: [PATCH] Fix session handling.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 frontend/Interpreter.cs |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="6d919ca600b5f0c6d4efd6a3bae11ed7b92e1006.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="6d919ca600b5f0c6d4efd6a3bae11ed7b92e1006.diff"

diff --git a/frontend/Interpreter.cs b/frontend/Interpreter.cs
index 3eedb79..c87230e 100644
--- a/frontend/Interpreter.cs
+++ b/frontend/Interpreter.cs
@@ -360,7 +360,9 @@ namespace Mono.Debugger.Frontend
 
 			try {
 				debugger = new Debugger (config);
+				parser = new ExpressionParser (this);
 				session = new DebuggerSession (config, stream, parser);
+				parser.Session = session;
 
 				new InterpreterEventSink (this, debugger);
 

--------------1.5.6--



From 541691d5ddcabb65743a4b137451af9fa3038674 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 15 Jul 2009 20:00:50 +0200
Subject: [PATCH] Let the OperationCommandResult handle suspending etc.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs       |   53 +++++++++++++++++++++++++++-----------
 backend/SingleSteppingEngine.cs |   52 +++++++++++++++++++++++++------------
 backend/ThreadServant.cs        |    2 +-
 backend/arch/CoreFile.cs        |    2 +-
 classes/Thread.cs               |   23 ++++++++++++++++-
 5 files changed, 96 insertions(+), 36 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="541691d5ddcabb65743a4b137451af9fa3038674.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="541691d5ddcabb65743a4b137451af9fa3038674.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 0e77cf5..0225314 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -208,8 +208,11 @@ namespace Mono.Debugger.Backend
 				get_thread_info (inferior, new_thread);
 			OnThreadCreatedEvent (new_thread);
 
-			if (resume_thread)
-				new_thread.StartThread ();
+			if (resume_thread) {
+				CommandResult result = current_operation != null ?
+					current_operation : new ThreadCommandResult (new_thread.Thread);
+				new_thread.StartThread (result);
+			}
 		}
 
 		internal void ChildForked (Inferior inferior, int pid)
@@ -237,7 +240,7 @@ namespace Mono.Debugger.Backend
 
 			if (current_state == ProcessState.Running) {
 				new_process.current_state = ProcessState.RunningAfterExec;
-				new_process.current_operation = new ProcessOperationResult (new_process);
+				new_process.current_operation = current_operation;
 				new_thread.StartForkedChild (new_process.current_operation);
 			} else {
 				new_process.current_state = ProcessState.SingleThreaded;
@@ -306,7 +309,7 @@ namespace Mono.Debugger.Backend
 
 			if (parent.current_state == ProcessState.Running) {
 				current_state = ProcessState.RunningAfterExec;
-				current_operation = new ProcessOperationResult (this);
+				current_operation = parent.current_operation;
 				new_thread.StartExecedChild (current_operation);
 			} else {
 				current_state = ProcessState.SingleThreaded;
@@ -337,7 +340,7 @@ namespace Mono.Debugger.Backend
 				return engine.StartApplication (new ThreadCommandResult (engine.Thread));
 			case ThreadingModel.Process:
 				current_state = ProcessState.Running;
-				current_operation = new ProcessOperationResult (this);
+				current_operation = new ProcessOperationResult (this, start.Session.Config.ThreadingModel);
 				return engine.StartApplication (current_operation);
 			default:
 				goto case ThreadingModel.Single;
@@ -707,9 +710,9 @@ namespace Mono.Debugger.Backend
 		protected ST.ManualResetEvent stopped_event;
 
 		ProcessState current_state = ProcessState.Unknown;
-		CommandResult current_operation = null;
+		OperationCommandResult current_operation = null;
 
-		internal void OperationCompleted (SingleSteppingEngine caller, TargetEventArgs result)
+		internal void OperationCompleted (SingleSteppingEngine caller, TargetEventArgs result, ThreadingModel model)
 		{
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
@@ -724,21 +727,20 @@ namespace Mono.Debugger.Backend
 				bool running_after_exec = current_state == ProcessState.RunningAfterExec;
 
 				current_state = ProcessState.Stopping;
-				SuspendUserThreads (ThreadingModel.Process, caller);
+				SuspendUserThreads (model, caller);
 				current_state = ProcessState.Stopped;
 				current_operation.Completed ();
 				current_operation = null;
 				stopped_event.Set ();
 
 				if (running_after_exec) {
-					parent.OperationCompleted (caller, result);
+					parent.OperationCompleted (caller, result, model);
 				} else {
 					if (result != null)
 						OnTargetEvent (caller, result);
 				}
-			} else if (current_state == ProcessState.SingleThreaded) {
-				if (result != null)
-					OnTargetEvent (caller, result);
+			} else {
+				throw new InternalError ("FUCK: {0} {1}", caller, current_state);
 			}
 		}
 
@@ -784,7 +786,13 @@ namespace Mono.Debugger.Backend
 				    ((model & ThreadingModel.StopDaemonThreads) == 0))
 					continue;
 
-				engine.ResumeUserThread ();
+				CommandResult result;
+				if (current_operation != null)
+					result = current_operation;
+				else
+					result = new ThreadCommandResult (engine.Thread);
+
+				engine.ResumeUserThread (result);
 			}
 
 			Report.Debug (DebugFlags.Threads,
@@ -819,7 +827,7 @@ namespace Mono.Debugger.Backend
 
 			stopped_event.Reset ();
 
-			current_operation = new ProcessOperationResult (this);
+			current_operation = new ProcessOperationResult (this, model);
 			ResumeUserThreads (model, caller);
 			return current_operation;
 		}
@@ -844,11 +852,16 @@ namespace Mono.Debugger.Backend
 			}, null);
 		}
 
-		internal class ProcessOperationResult : CommandResult
+		internal class ProcessOperationResult : OperationCommandResult
 		{
 			public readonly ProcessServant Process;
 
-			internal ProcessOperationResult (ProcessServant process)
+			public bool IsCompleted {
+				get; protected set;
+			}
+
+			internal ProcessOperationResult (ProcessServant process, ThreadingModel model)
+				: base (model)
 			{
 				this.Process = process;
 			}
@@ -860,6 +873,14 @@ namespace Mono.Debugger.Backend
 			internal override void Completed ()
 			{ }
 
+			internal override void Completed (SingleSteppingEngine sse, TargetEventArgs args)
+			{
+				if (!IsCompleted) {
+					IsCompleted = true;
+					Process.OperationCompleted (sse, args, ThreadingModel);
+				}
+			}
+
 			public override void Abort ()
 			{
 				Process.Stop ();
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 6d200bb..578899b 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -129,10 +129,10 @@ namespace Mono.Debugger.Backend
 			return result;
 		}
 
-		public CommandResult StartThread ()
+		public CommandResult StartThread (CommandResult result)
 		{
 			engine_stopped = false;
-			current_operation = new OperationStep (this, StepMode.Run, new ThreadCommandResult (thread));
+			current_operation = new OperationStep (this, StepMode.Run, result);
 			current_operation.Execute ();
 			return current_operation.Result;
 		}
@@ -543,6 +543,9 @@ namespace Mono.Debugger.Backend
 			if (abort_rti >= 0) {
 				DoAbortInvocation (abort_rti);
 			} else {
+				if (stop_requested)
+					OperationCompleted (null);
+				else
 				OperationCompleted (new TargetEventArgs (TargetEventType.TargetInterrupted, 0, current_frame));
 			}
 		}
@@ -578,7 +581,10 @@ namespace Mono.Debugger.Backend
 				stop_requested = false;
 				last_target_event = result;
 
-				process.OperationCompleted (this, result);
+				OperationCommandResult or = current_operation.Result as OperationCommandResult;
+				Console.WriteLine ("OC: {0} {1} {2} {3}", this, current_operation, or, result);
+				if (or != null)
+					or.Completed (this, result);
 
 				operation_completed_event.Set ();
 
@@ -592,7 +598,6 @@ namespace Mono.Debugger.Backend
 					current_operation.CompletedOperation (true);
 					current_operation = null;
 				} else {
-					if (current_operation != null) {
 						Report.Debug (DebugFlags.EventLoop, "{0} setting completed: {1} {2}",
 							      this, current_operation, current_operation.Result);
 						current_operation.CompletedOperation (false);
@@ -600,7 +605,6 @@ namespace Mono.Debugger.Backend
 					}
 				}
 			}
-		}
 
 		internal void OnManagedThreadCreated (TargetAddress end_stack_address)
 		{
@@ -647,7 +651,12 @@ namespace Mono.Debugger.Backend
 			else
 				result = new TargetEventArgs (TargetEventType.TargetExited, arg);
 			temp_breakpoint = null;
+			dead = true;
+
+			if (current_operation != null)
 			OperationCompleted (result);
+			else
+				process.OnTargetEvent (this, result);
 
 			process.OnThreadExitedEvent (this);
 			Dispose ();
@@ -956,7 +965,12 @@ namespace Mono.Debugger.Backend
 				inferior = null;
 			}
 
-			OperationCompleted (new TargetEventArgs (TargetEventType.TargetExited, 0));
+			TargetEventArgs result = new TargetEventArgs (TargetEventType.TargetExited, 0);
+			if (current_operation != null)
+				OperationCompleted (result);
+			else
+				process.OnTargetEvent (this, result);
+
 			process.OnThreadExitedEvent (this);
 			Dispose ();
 		}
@@ -1666,16 +1680,20 @@ namespace Mono.Debugger.Backend
 				OperationInterrupted ();
 			}
 
-			Report.Debug (DebugFlags.Threads,
-				      "{0} suspend user thread done: {1} {2}",
-				      this, stopped, stop_event);
-
 			if (stop_event != null)
 				thread_lock = new ThreadLockData (stopped, stop_event, false);
+
+			Report.Debug (DebugFlags.Threads,
+				      "{0} suspend user thread done: {1} {2} {3}",
+				      this, stopped, stop_event, current_operation);
+
 		}
 
-		internal override void ResumeUserThread ()
+		internal override void ResumeUserThread (CommandResult result)
 		{
+			Console.WriteLine ("RESUME USER THREAD: {0} {1} {2} {3}", this, result,
+					   engine_stopped, current_operation);
+
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
 
@@ -1683,8 +1701,6 @@ namespace Mono.Debugger.Backend
 				      "{0} resume user thread: {1} {2} {3}", this, engine_stopped,
 				      HasThreadLock, thread.ThreadFlags);
 
-			CommandResult result = new ThreadCommandResult (thread);
-
 			if (thread_lock != null) {
 				if (thread_lock.PushedRegisters || (thread_lock.StopEvent == null))
 					throw new InternalError ();
@@ -1933,7 +1949,8 @@ namespace Mono.Debugger.Backend
 					return null;
 				}
 
-				return StartOperation (new OperationReturn (this, bt, mode));
+				CommandResult result = new ThreadCommandResult (thread);
+				return StartOperation (new OperationReturn (this, bt, mode, result));
 			});
 		}
 
@@ -2007,7 +2024,8 @@ namespace Mono.Debugger.Backend
 			if (bt.Count < 2)
 				throw new TargetException (TargetError.NoStack);
 
-			PushOperation (new OperationReturn (this, bt, ReturnMode.Invocation));
+			CommandResult result = new ThreadCommandResult (thread);
+			PushOperation (new OperationReturn (this, bt, ReturnMode.Invocation, result));
 		}
 
 		public override Backtrace GetBacktrace (Backtrace.Mode mode, int max_frames)
@@ -4760,8 +4778,8 @@ namespace Mono.Debugger.Backend
 		OperationRuntimeInvoke aborted_rti;
 		int level = 0;
 
-		public OperationReturn (SingleSteppingEngine sse, Backtrace bt, ReturnMode mode)
-			: base (sse)
+		public OperationReturn (SingleSteppingEngine sse, Backtrace bt, ReturnMode mode, CommandResult result)
+			: base (sse, result)
 		{
 			this.Backtrace = bt;
 			this.Mode = mode;
diff --git a/backend/ThreadManager.cs b/backend/ThreadManager.cs
index 212bdee..52b710f 100644
diff --git a/backend/ThreadServant.cs b/backend/ThreadServant.cs
index 96ae9d4..d4da572 100644
--- a/backend/ThreadServant.cs
+++ b/backend/ThreadServant.cs
@@ -150,7 +150,7 @@ namespace Mono.Debugger.Backend
 
 		internal abstract void SuspendUserThread ();
 
-		internal abstract void ResumeUserThread ();
+		internal abstract void ResumeUserThread (CommandResult result);
 
 		internal abstract object Invoke (TargetAccessDelegate func, object data);
 
diff --git a/backend/arch/CoreFile.cs b/backend/arch/CoreFile.cs
index 97dcbcd..5dc81b1 100644
--- a/backend/arch/CoreFile.cs
+++ b/backend/arch/CoreFile.cs
@@ -537,7 +537,7 @@ namespace Mono.Debugger.Backend
 				throw new InvalidOperationException ();
 			}
 
-			internal override void ResumeUserThread ()
+			internal override void ResumeUserThread (CommandResult result)
 			{
 				throw new InvalidOperationException ();
 			}
diff --git a/classes/Thread.cs b/classes/Thread.cs
index de292ed..b5744d8 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -838,11 +838,26 @@ namespace Mono.Debugger
 		}
 	}
 
-	public class ThreadCommandResult : CommandResult
+	public abstract class OperationCommandResult : CommandResult
+	{
+		public ThreadingModel ThreadingModel {
+			get; private set;
+		}
+
+		protected OperationCommandResult (ThreadingModel model)
+		{
+			this.ThreadingModel = model;
+		}
+
+		internal abstract void Completed (SingleSteppingEngine sse, TargetEventArgs args);
+	}
+
+	public class ThreadCommandResult : OperationCommandResult
 	{
 		Thread thread;
 
 		internal ThreadCommandResult (Thread thread)
+			: base (ThreadingModel.Single)
 		{
 			this.thread = thread;
 		}
@@ -858,6 +873,12 @@ namespace Mono.Debugger
 		internal override void Completed ()
 		{ }
 
+		internal override void Completed (SingleSteppingEngine sse, TargetEventArgs args)
+		{
+			if (args != null)
+				sse.Process.OnTargetEvent (sse, args);
+		}
+
 		public override void Abort ()
 		{
 			thread.Stop ();

--------------1.5.6--



From 7ad60858b24cf4a08626ffa2d4e30ae758e1a1e6 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Fri, 17 Jul 2009 22:37:24 +0200
Subject: [PATCH] First implementation of ThreadingModel.Global.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/DebuggerServant.cs       |   91 +++++++++++++++++++++++++++++++++++
 backend/ProcessServant.cs        |   97 +++++++++++++++++++++++++++++---------
 backend/SingleSteppingEngine.cs  |    8 ++-
 classes/DebuggerConfiguration.cs |    3 +
 classes/Thread.cs                |    3 +-
 frontend/Command.cs              |    3 +
 test/testsuite/TestExec.cs       |   10 +++-
 7 files changed, 185 insertions(+), 30 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="7ad60858b24cf4a08626ffa2d4e30ae758e1a1e6.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="7ad60858b24cf4a08626ffa2d4e30ae758e1a1e6.diff"

diff --git a/backend/DebuggerServant.cs b/backend/DebuggerServant.cs
index 38f99df..4509f47 100644
--- a/backend/DebuggerServant.cs
+++ b/backend/DebuggerServant.cs
@@ -33,6 +33,7 @@ namespace Mono.Debugger.Backend
 			ObjectCache.Initialize ();
 			thread_manager = new ThreadManager (this);
 			process_hash = Hashtable.Synchronized (new Hashtable ());
+			stopped_event = new ManualResetEvent (false);
 		}
 
 		public Debugger Client {
@@ -200,6 +201,96 @@ namespace Mono.Debugger.Backend
 			Console.WriteLine ("ERROR: " + String.Format (message, args));
 		}
 
+#region Global Threading Model
+
+		ManualResetEvent stopped_event;
+		DebuggerOperationResult current_operation;
+
+		internal WaitHandle WaitHandle {
+			get { return stopped_event; }
+		}
+
+		internal CommandResult StartOperation (ThreadingModel model, SingleSteppingEngine caller)
+		{
+			if (!ThreadManager.InBackgroundThread)
+				throw new InternalError ();
+
+			if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Default) {
+				if (Inferior.HasThreadEvents)
+					model |= ThreadingModel.Single;
+				else
+					model |= ThreadingModel.Process;
+			}
+
+			if ((model & ThreadingModel.ThreadingMode) != ThreadingModel.Global)
+				return caller.Process.StartOperation (model, caller);
+
+			if (current_operation != null) {
+				Console.WriteLine ("NOT STOPPED: {0} {1}", model, caller);
+				throw new TargetException (TargetError.NotStopped);
+			}
+
+			Console.WriteLine ("START GLOBAL OPERATION: {0} {1} - {2}", model, caller, process_hash.Count);
+
+			lock (this) {
+				stopped_event.Reset ();
+				current_operation = new DebuggerOperationResult (this, model);
+			}
+
+			foreach (ProcessServant process in process_hash.Values) {
+				process.StartGlobalOperation (model, caller, current_operation);
+			}
+
+			Console.WriteLine ("START GLOBAL OPERATION DONE: {0} {1}", model, caller);
+
+			return current_operation;
+		}
+
+		internal void OperationCompleted (SingleSteppingEngine caller, TargetEventArgs result, ThreadingModel model)
+		{
+			if (!ThreadManager.InBackgroundThread)
+				throw new InternalError ();
+
+			Console.WriteLine ("DEBUGGER OPERATION COMPLETED: {0} {1} {2}", caller, result, model);
+
+			foreach (ProcessServant process in process_hash.Values) {
+				process.OperationCompleted (caller, result, model);
+			}
+
+			lock (this) {
+				current_operation = null;
+				stopped_event.Set ();
+			}
+		}
+
+		internal class DebuggerOperationResult : ProcessServant.ProcessOrDebuggerOperationResult
+		{
+			public readonly DebuggerServant Debugger;
+
+			internal DebuggerOperationResult (DebuggerServant debugger, ThreadingModel model)
+				: base (model, debugger.WaitHandle)
+			{
+				this.Debugger = debugger;
+			}
+
+			protected override void OperationCompleted (SingleSteppingEngine sse, TargetEventArgs args)
+			{
+				Debugger.OperationCompleted (sse, args, ThreadingModel);
+			}
+
+			protected override void SendResult (SingleSteppingEngine sse, TargetEventArgs args)
+			{
+				Debugger.SendTargetEvent (sse, args);
+			}
+
+			public override void Abort ()
+			{
+				// Process.Stop ();
+			}
+		}
+
+#endregion
+
 		//
 		// IDisposable
 		//
diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 0225314..e44ca20 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -239,7 +239,7 @@ namespace Mono.Debugger.Backend
 			new_process.OnThreadCreatedEvent (new_thread);
 
 			if (current_state == ProcessState.Running) {
-				new_process.current_state = ProcessState.RunningAfterExec;
+				new_process.current_state = ProcessState.Running;
 				new_process.current_operation = current_operation;
 				new_thread.StartForkedChild (new_process.current_operation);
 			} else {
@@ -308,7 +308,7 @@ namespace Mono.Debugger.Backend
 			initialized = is_forked = false;
 
 			if (parent.current_state == ProcessState.Running) {
-				current_state = ProcessState.RunningAfterExec;
+				current_state = ProcessState.Running;
 				current_operation = parent.current_operation;
 				new_thread.StartExecedChild (current_operation);
 			} else {
@@ -324,6 +324,7 @@ namespace Mono.Debugger.Backend
 			initialized = true;
 
 			this.main_thread = engine;
+			engine.Thread.ThreadFlags |= Thread.Flags.StopOnExit;
 
 			if (thread_hash.Contains (engine.PID))
 				thread_hash [engine.PID] = engine;
@@ -342,6 +343,10 @@ namespace Mono.Debugger.Backend
 				current_state = ProcessState.Running;
 				current_operation = new ProcessOperationResult (this, start.Session.Config.ThreadingModel);
 				return engine.StartApplication (current_operation);
+			case ThreadingModel.Global:
+				current_state = ProcessState.Running;
+				current_operation = new DebuggerServant.DebuggerOperationResult (Debugger, start.Session.Config.ThreadingModel);
+				return engine.StartApplication (current_operation);
 			default:
 				goto case ThreadingModel.Single;
 			}
@@ -701,7 +706,6 @@ namespace Mono.Debugger.Backend
 			Unknown,
 			SingleThreaded,
 			Running,
-			RunningAfterExec,
 			Stopping,
 			Stopped,
 			Exited
@@ -719,25 +723,19 @@ namespace Mono.Debugger.Backend
 
 			Report.Debug (DebugFlags.EventLoop, "{0} completed operation: {1} {2} {3}", caller, current_state, caller.State, result);
 
-			if ((current_state == ProcessState.Running) || (current_state == ProcessState.RunningAfterExec)) {
+			if (current_state == ProcessState.Running) {
 				if ((result != null) && (caller != main_thread) &&
 				    ((result.Type == TargetEventType.TargetExited) || (result.Type == TargetEventType.TargetSignaled)))
 					return;
 
-				bool running_after_exec = current_state == ProcessState.RunningAfterExec;
-
 				current_state = ProcessState.Stopping;
 				SuspendUserThreads (model, caller);
+
+				lock (this) {
 				current_state = ProcessState.Stopped;
 				current_operation.Completed ();
 				current_operation = null;
 				stopped_event.Set ();
-
-				if (running_after_exec) {
-					parent.OperationCompleted (caller, result, model);
-				} else {
-					if (result != null)
-						OnTargetEvent (caller, result);
 				}
 			} else {
 				throw new InternalError ("FUCK: {0} {1}", caller, current_state);
@@ -749,7 +747,6 @@ namespace Mono.Debugger.Backend
 			Report.Debug (DebugFlags.Threads,
 				      "Suspending user threads: {0} {1}", model, caller);
 
-			if ((model & ThreadingModel.Process) != 0) {
 				foreach (SingleSteppingEngine engine in thread_hash.Values) {
 					Report.Debug (DebugFlags.Threads, "  check user thread: {0} {1}",
 						      engine, engine.Thread.ThreadFlags);
@@ -763,7 +760,6 @@ namespace Mono.Debugger.Backend
 						continue;
 					engine.SuspendUserThread ();
 				}
-			}
 
 			Report.Debug (DebugFlags.Threads,
 				      "Done suspending user threads: {0} {1}", model, caller);
@@ -823,15 +819,34 @@ namespace Mono.Debugger.Backend
 				throw new ArgumentException ();
 			}
 
+			lock (this) {
 			current_state = ProcessState.Running;
-
 			stopped_event.Reset ();
-
 			current_operation = new ProcessOperationResult (this, model);
+			}
+
 			ResumeUserThreads (model, caller);
 			return current_operation;
 		}
 
+		internal void StartGlobalOperation (ThreadingModel model, SingleSteppingEngine caller, OperationCommandResult operation)
+		{
+			Console.WriteLine ("START GLOBAL OPERATION: {0} {1} {2}", client, model, caller);
+
+			if ((current_state != ProcessState.Stopped) && (current_state != ProcessState.SingleThreaded)) {
+				Console.WriteLine ("NOT STOPPED: {0} {1}", model, current_state);
+				throw new TargetException (TargetError.NotStopped);
+			}
+
+			lock (this) {
+				current_state = ProcessState.Running;
+				stopped_event.Reset ();
+				current_operation = operation;
+			}
+
+			ResumeUserThreads (model, caller);
+		}
+
 		internal void Stop ()
 		{
 			Console.WriteLine ("STOP PROCESS !");
@@ -852,22 +867,22 @@ namespace Mono.Debugger.Backend
 			}, null);
 		}
 
-		internal class ProcessOperationResult : OperationCommandResult
+		internal abstract class ProcessOrDebuggerOperationResult : OperationCommandResult
 		{
-			public readonly ProcessServant Process;
-
 			public bool IsCompleted {
-				get; protected set;
+				get; private set;
 			}
 
-			internal ProcessOperationResult (ProcessServant process, ThreadingModel model)
+			ST.WaitHandle wait_handle;
+
+			internal ProcessOrDebuggerOperationResult (ThreadingModel model, ST.WaitHandle wait_handle)
 				: base (model)
 			{
-				this.Process = process;
+				this.wait_handle = wait_handle;
 			}
 
 			public override ST.WaitHandle CompletedEvent {
-				get { return Process.WaitHandle; }
+				get { return wait_handle; }
 			}
 
 			internal override void Completed ()
@@ -875,10 +890,46 @@ namespace Mono.Debugger.Backend
 
 			internal override void Completed (SingleSteppingEngine sse, TargetEventArgs args)
 			{
+				Console.WriteLine ("OR COMPLETED: {0} {1} {2} - {3}", this, sse, args, IsCompleted);
+
+				if ((args != null) && ((args.Type == TargetEventType.TargetExited) || (args.Type == TargetEventType.TargetSignaled))) {
+					if ((sse.Thread.ThreadFlags & Thread.Flags.StopOnExit) == 0) {
+						SendResult (sse, args);
+						return;
+					}
+				}
+
 				if (!IsCompleted) {
 					IsCompleted = true;
+					OperationCompleted (sse, args);
+					if (args != null)
+						SendResult (sse, args);
+				}
+			}
+
+			protected abstract void OperationCompleted (SingleSteppingEngine sse, TargetEventArgs args);
+
+			protected abstract void SendResult (SingleSteppingEngine sse, TargetEventArgs args);
+		}
+
+		internal class ProcessOperationResult : ProcessOrDebuggerOperationResult
+		{
+			public readonly ProcessServant Process;
+
+			internal ProcessOperationResult (ProcessServant process, ThreadingModel model)
+				: base (model, process.WaitHandle)
+			{
+				this.Process = process;
+			}
+
+			protected override void OperationCompleted (SingleSteppingEngine sse, TargetEventArgs args)
+			{
 					Process.OperationCompleted (sse, args, ThreadingModel);
 				}
+
+			protected override void SendResult (SingleSteppingEngine sse, TargetEventArgs args)
+			{
+				Process.OnTargetEvent (sse, args);
 			}
 
 			public override void Abort ()
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 578899b..c87190f 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -185,7 +185,8 @@ namespace Mono.Debugger.Backend
 
 			if ((cevent.Type == Inferior.ChildEventType.CHILD_EXITED) ||
 			    (cevent.Type == Inferior.ChildEventType.CHILD_SIGNALED)) {
-				Report.Debug (DebugFlags.SSE, "{0} received {1}", this, cevent);
+				Report.Debug (DebugFlags.SSE, "{0} received {1} while running {2}",
+					      this, cevent, current_operation);
 				// we can't remove the breakpoint anymore after
 				// the target exited, but we need to clear this id.
 				temp_breakpoint = null;
@@ -1833,7 +1834,8 @@ namespace Mono.Debugger.Backend
 
 			return (CommandResult) SendCommand (delegate {
 				Report.Debug (DebugFlags.SSE, "{0} step: {1} {2} {3}", this, model, mode, frame);
-				CommandResult result = process.StartOperation (model, this);
+				CommandResult result = process.Debugger.StartOperation (model, this);
+				Console.WriteLine ("STEP: {0} {1} {2} {3}", this, model, result, mode);
 				return ProcessOperation (new OperationStep (this, mode, frame, result));
 			});
 		}
@@ -3230,7 +3232,7 @@ namespace Mono.Debugger.Backend
 
 		public override void Execute ()
 		{
-			Report.Debug (DebugFlags.SSE, "{0} start stepping operation: {1}", sse, this);
+			Report.Debug (DebugFlags.SSE, "{0} start stepping operation: {1} {2}", sse, this, Result);
 			base.Execute ();
 		}
 
diff --git a/classes/DebuggerConfiguration.cs b/classes/DebuggerConfiguration.cs
index 7105708..47391f7 100644
--- a/classes/DebuggerConfiguration.cs
+++ b/classes/DebuggerConfiguration.cs
@@ -424,6 +424,9 @@ namespace Mono.Debugger
 				case ThreadingModel.Process:
 					threading_mode = "process";
 					break;
+				case ThreadingModel.Global:
+					threading_mode = "global";
+					break;
 				default:
 					threading_mode = "default";
 					break;
diff --git a/classes/Thread.cs b/classes/Thread.cs
index b5744d8..cace778 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -43,7 +43,8 @@ namespace Mono.Debugger
 			Daemon		= 0x0001,
 			Immutable	= 0x0002,
 			Background	= 0x0004,
-			AutoRun		= 0x0008
+			AutoRun		= 0x0008,
+			StopOnExit	= 0x0010
 		}
 
 		internal Thread (ThreadServant servant, int id)
diff --git a/frontend/Command.cs b/frontend/Command.cs
index 9931e20..515fc65 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -3774,6 +3774,9 @@ namespace Mono.Debugger.Frontend
 					case "process":
 						config.ThreadingModel |= ThreadingModel.Process;
 						break;
+					case "global":
+						config.ThreadingModel |= ThreadingModel.Global;
+						break;
 					case "default":
 						break;
 					default:
diff --git a/test/testsuite/TestExec.cs b/test/testsuite/TestExec.cs
index 699a878..d1a4520 100644
--- a/test/testsuite/TestExec.cs
+++ b/test/testsuite/TestExec.cs
@@ -212,7 +212,7 @@ namespace Mono.Debugger.Tests
 
 			AssertExecute ("enable " + bpt_child);
 
-			Interpreter.DebuggerConfiguration.ThreadingModel = ThreadingModel.Process;
+			Interpreter.DebuggerConfiguration.ThreadingModel = ThreadingModel.Global;
 
 			Process process = Start ();
 			Assert.IsTrue (process.IsManaged);
@@ -264,14 +264,14 @@ namespace Mono.Debugger.Tests
 
 			AssertFrame (execd_child, "X.Main()", line_child);
 
-			AssertExecute ("continue -bg");
 			AssertExecute ("continue -thread " + thread.ID);
 
+			bool exited_event = false;
 			bool thread_exited = false;
 			bool child_exited = false;
 			bool reached_waitpid = false;
 
-			while (!child_exited || !thread_exited || !reached_waitpid) {
+			while (!child_exited || !thread_exited || !reached_waitpid || !exited_event) {
 				DebuggerEvent e = AssertEvent ();
 
 				Report.Debug (DebugFlags.NUnit, "EXEC EVENT: {0}", e);
@@ -295,6 +295,10 @@ namespace Mono.Debugger.Tests
 					    ((int) args.Data == bpt_main)) {
 						reached_waitpid = true;
 						continue;
+					} else if ((e_thread == execd_child) &&
+						   (args.Type == TargetEventType.TargetExited)) {
+						exited_event = true;
+						continue;
 					}
 				}
 

--------------1.5.6--



From 7d273427ced9332b7eefbd635492db4b8bd9f3bf Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Fri, 17 Jul 2009 22:45:08 +0200
Subject: [PATCH] Remove some Console.WriteLine()s.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |   29 ++++++++++++-----------------
 1 files changed, 12 insertions(+), 17 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="7d273427ced9332b7eefbd635492db4b8bd9f3bf.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="7d273427ced9332b7eefbd635492db4b8bd9f3bf.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index c87190f..7dd3f90 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -569,28 +569,29 @@ namespace Mono.Debugger.Backend
 			return rti;
 		}
 
-		void OperationCompleted (TargetEventArgs result)
+		void OperationCompleted (TargetEventArgs args)
 		{
-			OperationCompleted (result, false);
+			OperationCompleted (args, false);
 		}
 
-		void OperationCompleted (TargetEventArgs result, bool suspended)
+		void OperationCompleted (TargetEventArgs args, bool suspended)
 		{
 			lock (this) {
 				remove_temporary_breakpoint ();
 				engine_stopped = true;
 				stop_requested = false;
-				last_target_event = result;
+				last_target_event = args;
 
-				OperationCommandResult or = current_operation.Result as OperationCommandResult;
-				Console.WriteLine ("OC: {0} {1} {2} {3}", this, current_operation, or, result);
-				if (or != null)
-					or.Completed (this, result);
+				OperationCommandResult result = current_operation.Result as OperationCommandResult;
 
-				operation_completed_event.Set ();
+				Report.Debug (DebugFlags.EventLoop, "{0} {1} operation {2}: {3} {4}",
+					      this, suspended ? "suspending" : "terminating", current_operation,
+					      result != null, args);
 
-				Report.Debug (DebugFlags.EventLoop, "{0} {1} operation {2}: {3}",
-					      this, suspended ? "suspending" : "terminating", current_operation, result);
+				if (result != null)
+					result.Completed (this, args);
+
+				operation_completed_event.Set ();
 
 				if (suspended) {
 					process.OnEnterNestedBreakState (this);
@@ -599,8 +600,6 @@ namespace Mono.Debugger.Backend
 					current_operation.CompletedOperation (true);
 					current_operation = null;
 				} else {
-					Report.Debug (DebugFlags.EventLoop, "{0} setting completed: {1} {2}",
-						      this, current_operation, current_operation.Result);
 					current_operation.CompletedOperation (false);
 					current_operation = null;
 				}
@@ -1692,9 +1691,6 @@ namespace Mono.Debugger.Backend
 
 		internal override void ResumeUserThread (CommandResult result)
 		{
-			Console.WriteLine ("RESUME USER THREAD: {0} {1} {2} {3}", this, result,
-					   engine_stopped, current_operation);
-
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
 
@@ -1835,7 +1831,6 @@ namespace Mono.Debugger.Backend
 			return (CommandResult) SendCommand (delegate {
 				Report.Debug (DebugFlags.SSE, "{0} step: {1} {2} {3}", this, model, mode, frame);
 				CommandResult result = process.Debugger.StartOperation (model, this);
-				Console.WriteLine ("STEP: {0} {1} {2} {3}", this, model, result, mode);
 				return ProcessOperation (new OperationStep (this, mode, frame, result));
 			});
 		}

--------------1.5.6--



From f6ca6cd77797b0d6c230cf03f1898722aab05133 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Fri, 17 Jul 2009 23:12:58 +0200
Subject: [PATCH] API changes; introduce Operation.cs.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/DebuggerServant.cs      |   32 +++-------
 backend/ProcessServant.cs       |   79 ++++----------------------
 backend/SingleSteppingEngine.cs |    2 +-
 classes/Operation.cs            |  112 +++++++++++++++++++++++++++++++++++++
 classes/Thread.cs               |  118 +++++++++++----------------------------
 5 files changed, 166 insertions(+), 177 deletions(-)
 create mode 100644 classes/Operation.cs
--------------1.5.6
Content-Type: text/x-patch; name="f6ca6cd77797b0d6c230cf03f1898722aab05133.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="f6ca6cd77797b0d6c230cf03f1898722aab05133.diff"

diff --git a/backend/DebuggerServant.cs b/backend/DebuggerServant.cs
index 4509f47..e621094 100644
--- a/backend/DebuggerServant.cs
+++ b/backend/DebuggerServant.cs
@@ -16,7 +16,7 @@ using Mono.Debugger.Languages.Mono;
 
 namespace Mono.Debugger.Backend
 {
-	internal class DebuggerServant : DebuggerMarshalByRefObject, IDisposable
+	internal class DebuggerServant : DebuggerMarshalByRefObject, IOperationHost, IDisposable
 	{
 		Debugger client;
 		DebuggerConfiguration config;
@@ -204,7 +204,7 @@ namespace Mono.Debugger.Backend
 #region Global Threading Model
 
 		ManualResetEvent stopped_event;
-		DebuggerOperationResult current_operation;
+		OperationCommandResult current_operation;
 
 		internal WaitHandle WaitHandle {
 			get { return stopped_event; }
@@ -234,7 +234,7 @@ namespace Mono.Debugger.Backend
 
 			lock (this) {
 				stopped_event.Reset ();
-				current_operation = new DebuggerOperationResult (this, model);
+				current_operation = new OperationCommandResult (this, model);
 			}
 
 			foreach (ProcessServant process in process_hash.Values) {
@@ -246,7 +246,7 @@ namespace Mono.Debugger.Backend
 			return current_operation;
 		}
 
-		internal void OperationCompleted (SingleSteppingEngine caller, TargetEventArgs result, ThreadingModel model)
+		public void OperationCompleted (SingleSteppingEngine caller, TargetEventArgs result, ThreadingModel model)
 		{
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
@@ -263,30 +263,18 @@ namespace Mono.Debugger.Backend
 			}
 		}
 
-		internal class DebuggerOperationResult : ProcessServant.ProcessOrDebuggerOperationResult
-		{
-			public readonly DebuggerServant Debugger;
-
-			internal DebuggerOperationResult (DebuggerServant debugger, ThreadingModel model)
-				: base (model, debugger.WaitHandle)
-			{
-				this.Debugger = debugger;
-			}
-
-			protected override void OperationCompleted (SingleSteppingEngine sse, TargetEventArgs args)
-			{
-				Debugger.OperationCompleted (sse, args, ThreadingModel);
+		WaitHandle IOperationHost.WaitHandle {
+			get { return stopped_event; }
 			}
 
-			protected override void SendResult (SingleSteppingEngine sse, TargetEventArgs args)
+		void IOperationHost.SendResult (SingleSteppingEngine sse, TargetEventArgs args)
 			{
-				Debugger.SendTargetEvent (sse, args);
+			SendTargetEvent (sse, args);
 			}
 
-			public override void Abort ()
+		void IOperationHost.Abort ()
 			{
-				// Process.Stop ();
-			}
+			// Stop ();
 		}
 
 #endregion
diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index e44ca20..24fee31 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -15,7 +15,7 @@ using Mono.Debugger.Languages.Mono;
 
 namespace Mono.Debugger.Backend
 {
-	internal class ProcessServant : DebuggerMarshalByRefObject
+	internal class ProcessServant : DebuggerMarshalByRefObject, IOperationHost
 	{
 		Process client;
 		TargetInfo target_info;
@@ -341,11 +341,11 @@ namespace Mono.Debugger.Backend
 				return engine.StartApplication (new ThreadCommandResult (engine.Thread));
 			case ThreadingModel.Process:
 				current_state = ProcessState.Running;
-				current_operation = new ProcessOperationResult (this, start.Session.Config.ThreadingModel);
+				current_operation = new OperationCommandResult (this, start.Session.Config.ThreadingModel);
 				return engine.StartApplication (current_operation);
 			case ThreadingModel.Global:
 				current_state = ProcessState.Running;
-				current_operation = new DebuggerServant.DebuggerOperationResult (Debugger, start.Session.Config.ThreadingModel);
+				current_operation = new OperationCommandResult (Debugger, start.Session.Config.ThreadingModel);
 				return engine.StartApplication (current_operation);
 			default:
 				goto case ThreadingModel.Single;
@@ -716,7 +716,7 @@ namespace Mono.Debugger.Backend
 		ProcessState current_state = ProcessState.Unknown;
 		OperationCommandResult current_operation = null;
 
-		internal void OperationCompleted (SingleSteppingEngine caller, TargetEventArgs result, ThreadingModel model)
+		public void OperationCompleted (SingleSteppingEngine caller, TargetEventArgs result, ThreadingModel model)
 		{
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
@@ -822,7 +822,7 @@ namespace Mono.Debugger.Backend
 			lock (this) {
 				current_state = ProcessState.Running;
 				stopped_event.Reset ();
-				current_operation = new ProcessOperationResult (this, model);
+				current_operation = new OperationCommandResult (this, model);
 			}
 
 			ResumeUserThreads (model, caller);
@@ -867,75 +867,18 @@ namespace Mono.Debugger.Backend
 			}, null);
 		}
 
-		internal abstract class ProcessOrDebuggerOperationResult : OperationCommandResult
-		{
-			public bool IsCompleted {
-				get; private set;
-			}
-
-			ST.WaitHandle wait_handle;
-
-			internal ProcessOrDebuggerOperationResult (ThreadingModel model, ST.WaitHandle wait_handle)
-				: base (model)
-			{
-				this.wait_handle = wait_handle;
-			}
-
-			public override ST.WaitHandle CompletedEvent {
-				get { return wait_handle; }
-			}
-
-			internal override void Completed ()
-			{ }
-
-			internal override void Completed (SingleSteppingEngine sse, TargetEventArgs args)
-			{
-				Console.WriteLine ("OR COMPLETED: {0} {1} {2} - {3}", this, sse, args, IsCompleted);
-
-				if ((args != null) && ((args.Type == TargetEventType.TargetExited) || (args.Type == TargetEventType.TargetSignaled))) {
-					if ((sse.Thread.ThreadFlags & Thread.Flags.StopOnExit) == 0) {
-						SendResult (sse, args);
-						return;
-					}
-				}
-
-				if (!IsCompleted) {
-					IsCompleted = true;
-					OperationCompleted (sse, args);
-					if (args != null)
-						SendResult (sse, args);
-				}
-			}
-
-			protected abstract void OperationCompleted (SingleSteppingEngine sse, TargetEventArgs args);
-
-			protected abstract void SendResult (SingleSteppingEngine sse, TargetEventArgs args);
-		}
-
-		internal class ProcessOperationResult : ProcessOrDebuggerOperationResult
-		{
-			public readonly ProcessServant Process;
-
-			internal ProcessOperationResult (ProcessServant process, ThreadingModel model)
-				: base (model, process.WaitHandle)
-			{
-				this.Process = process;
-			}
-
-			protected override void OperationCompleted (SingleSteppingEngine sse, TargetEventArgs args)
-			{
-				Process.OperationCompleted (sse, args, ThreadingModel);
+		ST.WaitHandle IOperationHost.WaitHandle {
+			get { return stopped_event; }
 			}
 
-			protected override void SendResult (SingleSteppingEngine sse, TargetEventArgs args)
+		void IOperationHost.SendResult (SingleSteppingEngine sse, TargetEventArgs args)
 			{
-				Process.OnTargetEvent (sse, args);
+			OnTargetEvent (sse, args);
 			}
 
-			public override void Abort ()
+		void IOperationHost.Abort ()
 			{
-				Process.Stop ();
-			}
+			Stop ();
 		}
 
 #endregion
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 7dd3f90..6e5b395 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1819,7 +1819,7 @@ namespace Mono.Debugger.Backend
 
 		internal override ThreadCommandResult Old_Step (StepMode mode, StepFrame frame)
 		{
-			ThreadCommandResult result = new OldOperationCommandResult (thread);
+			ThreadCommandResult result = new ThreadCommandResult (thread);
 			StartOperation (new OperationStep (this, mode, frame, result));
 			return result;
 		}
diff --git a/classes/Operation.cs b/classes/Operation.cs
new file mode 100644
index 0000000..f2c1c0f
--- /dev/null
+++ b/classes/Operation.cs
@@ -0,0 +1,112 @@
+using System;
+using ST = System.Threading;
+
+using Mono.Debugger.Backend;
+using Mono.Debugger.Languages;
+
+namespace Mono.Debugger
+{
+	[Flags]
+	public enum ThreadingModel
+	{
+		Default			= 0,
+		Single			= 1,
+		Process			= 2,
+		Global			= 3,
+
+		ResumeThreads		= 0x0100,
+
+		StopDaemonThreads	= 0x0200,
+		StopImmutableThreads	= 0x0400,
+
+		ThreadingMode		= 0x00FF,
+		ThreadingFlags		= 0xFF00
+	}
+
+	public abstract class CommandResult : DebuggerMarshalByRefObject
+	{
+		public object Result;
+
+		public abstract ST.WaitHandle CompletedEvent {
+			get;
+		}
+
+		internal abstract void Completed ();
+
+		public abstract void Abort ();
+
+		public void Wait ()
+		{
+			CompletedEvent.WaitOne ();
+			if (Result is Exception)
+				throw (Exception) Result;
+		}
+	}
+
+	internal interface IOperationHost
+	{
+		ST.WaitHandle WaitHandle {
+			get;
+		}
+
+		void OperationCompleted (SingleSteppingEngine sse, TargetEventArgs args, ThreadingModel model);
+
+		void SendResult (SingleSteppingEngine sse, TargetEventArgs args);
+
+		void Abort ();
+	}
+
+	public class OperationCommandResult : CommandResult
+	{
+		public ThreadingModel ThreadingModel {
+			get; private set;
+		}
+
+		internal IOperationHost Host {
+			get; private set;
+		}
+
+		public bool IsCompleted {
+			get; private set;
+		}
+
+		internal OperationCommandResult (IOperationHost host, ThreadingModel model)
+		{
+			this.ThreadingModel = model;
+			this.Host = host;
+		}
+
+		public override ST.WaitHandle CompletedEvent {
+			get { return Host.WaitHandle; }
+		}
+
+		internal override void Completed ()
+		{
+			Console.WriteLine ("OR COMPLETED: {0}", this);
+		}
+
+		internal virtual void Completed (SingleSteppingEngine sse, TargetEventArgs args)
+		{
+			Console.WriteLine ("OR COMPLETED: {0} {1} {2} - {3}", this, sse, args, IsCompleted);
+
+			if ((args != null) && ((args.Type == TargetEventType.TargetExited) || (args.Type == TargetEventType.TargetSignaled))) {
+				if ((sse.Thread.ThreadFlags & Thread.Flags.StopOnExit) == 0) {
+					Host.SendResult (sse, args);
+					return;
+				}
+			}
+
+			if (!IsCompleted) {
+				IsCompleted = true;
+				Host.OperationCompleted (sse, args, ThreadingModel);
+				if (args != null)
+					Host.SendResult (sse, args);
+			}
+		}
+
+		public override void Abort ()
+		{
+			Host.Abort ();
+		}
+	}
+}
diff --git a/classes/Thread.cs b/classes/Thread.cs
index cace778..3206c19 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -18,24 +18,7 @@ namespace Mono.Debugger
 	[Serializable]
 	internal delegate object TargetAccessDelegate (Thread target, object user_data);
 
-	[Flags]
-	public enum ThreadingModel
-	{
-		Default			= 0,
-		Single			= 1,
-		Process			= 2,
-		Global			= 3,
-
-		ResumeThreads		= 0x0100,
-
-		StopDaemonThreads	= 0x0200,
-		StopImmutableThreads	= 0x0400,
-
-		ThreadingMode		= 0x00FF,
-		ThreadingFlags		= 0xFF00
-	}
-
-	public class Thread : DebuggerMarshalByRefObject
+	public class Thread : DebuggerMarshalByRefObject, IOperationHost
 	{
 		[Flags]
 		public enum Flags {
@@ -489,6 +472,23 @@ namespace Mono.Debugger
 			return servant.PrintType (style, type);
 		}
 
+#region User Threads
+
+		void IOperationHost.OperationCompleted (SingleSteppingEngine sse, TargetEventArgs args, ThreadingModel model)
+		{ }
+
+		void IOperationHost.SendResult (SingleSteppingEngine sse, TargetEventArgs args)
+		{
+			sse.Process.OnTargetEvent (sse, args);
+		}
+
+		void IOperationHost.Abort ()
+		{
+			Stop ();
+		}
+
+#endregion
+
 		//
 		// Disassembling.
 		//
@@ -819,78 +819,24 @@ namespace Mono.Debugger
 		}
 	}
 
-	public abstract class CommandResult : DebuggerMarshalByRefObject
-	{
-		public object Result;
-
-		public abstract ST.WaitHandle CompletedEvent {
-			get;
-		}
-
-		internal abstract void Completed ();
-
-		public abstract void Abort ();
-
-		public void Wait ()
-		{
-			CompletedEvent.WaitOne ();
-			if (Result is Exception)
-				throw (Exception) Result;
-		}
-	}
-
-	public abstract class OperationCommandResult : CommandResult
-	{
-		public ThreadingModel ThreadingModel {
-			get; private set;
-		}
-
-		protected OperationCommandResult (ThreadingModel model)
-		{
-			this.ThreadingModel = model;
-		}
-
-		internal abstract void Completed (SingleSteppingEngine sse, TargetEventArgs args);
-	}
-
 	public class ThreadCommandResult : OperationCommandResult
 	{
-		Thread thread;
-
-		internal ThreadCommandResult (Thread thread)
-			: base (ThreadingModel.Single)
-		{
-			this.thread = thread;
-		}
-
 		public Thread Thread {
-			get { return thread; }
-		}
-
-		public override ST.WaitHandle CompletedEvent {
-			get { return thread.WaitHandle; }
-		}
-
-		internal override void Completed ()
-		{ }
-
-		internal override void Completed (SingleSteppingEngine sse, TargetEventArgs args)
-		{
-			if (args != null)
-				sse.Process.OnTargetEvent (sse, args);
+			get; private set;
 		}
 
-		public override void Abort ()
+		internal ThreadCommandResult (Thread thread)
+			: base (thread, ThreadingModel.Single)
 		{
-			thread.Stop ();
+			this.Thread = thread;
 		}
 	}
 
-	public class OldOperationCommandResult : ThreadCommandResult
+	public class RuntimeInvokeResult : ThreadCommandResult
 	{
-		protected ST.ManualResetEvent completed_event = new ST.ManualResetEvent (false);
+		ST.ManualResetEvent completed_event = new ST.ManualResetEvent (false);
 
-		internal OldOperationCommandResult (Thread thread)
+		internal RuntimeInvokeResult (Thread thread)
 			: base (thread)
 		{ }
 
@@ -902,13 +848,6 @@ namespace Mono.Debugger
 		{
 			completed_event.Set ();
 		}
-	}
-
-	public class RuntimeInvokeResult : OldOperationCommandResult
-	{
-		internal RuntimeInvokeResult (Thread thread)
-			: base (thread)
-		{ }
 
 		public override void Abort ()
 		{
@@ -916,6 +855,13 @@ namespace Mono.Debugger
 			completed_event.WaitOne ();
 		}
 
+		internal override void Completed (SingleSteppingEngine sse, TargetEventArgs args)
+		{
+			Host.OperationCompleted (sse, args, ThreadingModel);
+			if (args != null)
+				Host.SendResult (sse, args);
+		}
+
 		public long ID;
 		public bool InvocationAborted;
 		public bool InvocationCompleted;

--------------1.5.6--



From 3917ee155f81b38c1f23913a5068f26dc1018fa5 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Fri, 17 Jul 2009 23:26:06 +0200
Subject: [PATCH] Add separate test for ThreadingModel.Process.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs  |    3 +
 classes/Operation.cs       |    6 +--
 test/testsuite/TestExec.cs |  114 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 118 insertions(+), 5 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="3917ee155f81b38c1f23913a5068f26dc1018fa5.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="3917ee155f81b38c1f23913a5068f26dc1018fa5.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 24fee31..fb2e5ee 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -309,7 +309,10 @@ namespace Mono.Debugger.Backend
 
 			if (parent.current_state == ProcessState.Running) {
 				current_state = ProcessState.Running;
+				if ((parent.current_operation.ThreadingModel & ThreadingModel.ThreadingMode) == ThreadingModel.Global)
 				current_operation = parent.current_operation;
+				else
+					current_operation = new OperationCommandResult (this, parent.current_operation.ThreadingModel);
 				new_thread.StartExecedChild (current_operation);
 			} else {
 				current_state = ProcessState.SingleThreaded;
diff --git a/classes/Operation.cs b/classes/Operation.cs
index f2c1c0f..d10c660 100644
--- a/classes/Operation.cs
+++ b/classes/Operation.cs
@@ -81,14 +81,10 @@ namespace Mono.Debugger
 		}
 
 		internal override void Completed ()
-		{
-			Console.WriteLine ("OR COMPLETED: {0}", this);
-		}
+		{ }
 
 		internal virtual void Completed (SingleSteppingEngine sse, TargetEventArgs args)
 		{
-			Console.WriteLine ("OR COMPLETED: {0} {1} {2} - {3}", this, sse, args, IsCompleted);
-
 			if ((args != null) && ((args.Type == TargetEventType.TargetExited) || (args.Type == TargetEventType.TargetSignaled))) {
 				if ((sse.Thread.ThreadFlags & Thread.Flags.StopOnExit) == 0) {
 					Host.SendResult (sse, args);
diff --git a/test/testsuite/TestExec.cs b/test/testsuite/TestExec.cs
index d1a4520..ea9cdd9 100644
--- a/test/testsuite/TestExec.cs
+++ b/test/testsuite/TestExec.cs
@@ -212,6 +212,120 @@ namespace Mono.Debugger.Tests
 
 			AssertExecute ("enable " + bpt_child);
 
+			Interpreter.DebuggerConfiguration.ThreadingModel = ThreadingModel.Process;
+
+			Process process = Start ();
+			Assert.IsTrue (process.IsManaged);
+			Assert.IsTrue (process.MainThread.IsStopped);
+			Thread thread = process.MainThread;
+
+			AssertStopped (thread, "X.Main(string[])", line_main);
+			AssertExecute ("continue -bg");
+
+			Thread child = AssertProcessCreated ();
+			Thread execd_child = null;
+
+			bool execd = false;
+			bool stopped = false;
+			bool thread_created = false;
+
+			while (!stopped || !execd || !thread_created) {
+				DebuggerEvent e = AssertEvent ();
+
+				Report.Debug (DebugFlags.NUnit, "EXEC EVENT: {0}", e);
+
+				if (e.Type == DebuggerEventType.ProcessExecd) {
+					if ((Process) e.Data == child.Process) {
+						execd = true;
+						continue;
+					}
+				} else if (e.Type == DebuggerEventType.ThreadCreated) {
+					execd_child = (Thread) e.Data;
+					thread_created = true;
+					continue;
+				} else if (e.Type == DebuggerEventType.TargetEvent) {
+					Thread e_thread = (Thread) e.Data;
+					TargetEventArgs args = (TargetEventArgs) e.Data2;
+
+					if ((e_thread == execd_child) &&
+					    (args.Type == TargetEventType.TargetHitBreakpoint) &&
+					    ((int) args.Data == bpt_child)) {
+						stopped = true;
+						continue;
+					}
+				}
+
+				Assert.Fail ("Received unexpected event {0}", e);
+			}
+
+			Assert.IsTrue (thread.IsRunning);
+			Assert.IsTrue (execd_child.IsStopped);
+			Assert.IsTrue (Interpreter.CurrentThread == execd_child);
+
+			AssertFrame (execd_child, "X.Main()", line_child);
+
+			AssertExecute ("continue -thread " + execd_child.ID);
+
+			bool exited_event = false;
+			bool thread_exited = false;
+			bool child_exited = false;
+			bool reached_waitpid = false;
+
+			while (!child_exited || !thread_exited || !reached_waitpid || !exited_event) {
+				DebuggerEvent e = AssertEvent ();
+
+				Report.Debug (DebugFlags.NUnit, "EXEC EVENT: {0}", e);
+
+				if (e.Type == DebuggerEventType.ProcessExited) {
+					if ((Process) e.Data == child.Process) {
+						child_exited = true;
+						continue;
+					}
+				} else if (e.Type == DebuggerEventType.ThreadExited) {
+					if ((Thread) e.Data == execd_child) {
+						thread_exited = true;
+						continue;
+					}
+				} else if (e.Type == DebuggerEventType.TargetEvent) {
+					Thread e_thread = (Thread) e.Data;
+					TargetEventArgs args = (TargetEventArgs) e.Data2;
+
+					if ((e_thread == thread) &&
+					    (args.Type == TargetEventType.TargetHitBreakpoint) &&
+					    ((int) args.Data == bpt_main)) {
+						reached_waitpid = true;
+						continue;
+					} else if ((e_thread == execd_child) &&
+						   (args.Type == TargetEventType.TargetExited)) {
+						exited_event = true;
+						continue;
+					}
+				}
+
+				Assert.Fail ("Received unexpected event {0}", e);
+			}
+
+			AssertTargetOutput ("Hello World");
+			AssertNoTargetOutput ();
+
+			AssertFrame (thread, "X.Main(string[])", line_main_3);
+			AssertPrint (thread, "process.ExitCode", "(int) 0");
+
+			AssertExecute ("continue");
+			AssertTargetExited (thread.Process);
+		}
+
+		[Test]
+		[Category("Fork")]
+		public void ThreadingModelGlobal ()
+		{
+			Interpreter.Options.File = Path.Combine (BuildDirectory, "TestExec.exe");
+			Interpreter.Options.InferiorArgs = new string [] {
+				MonoExecutable, Path.Combine (BuildDirectory, "TestChild.exe")
+			};
+
+			AssertExecute ("enable " + bpt_child);
+
 			Interpreter.DebuggerConfiguration.ThreadingModel = ThreadingModel.Global;
 
 			Process process = Start ();

--------------1.5.6--



From 9e14620f74d87f3bbb26d4c97025a79afb19fe4a Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Fri, 17 Jul 2009 23:26:34 +0200
Subject: [PATCH] Debugging ...
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 test/framework/DebuggerTestFixture.cs |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="9e14620f74d87f3bbb26d4c97025a79afb19fe4a.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="9e14620f74d87f3bbb26d4c97025a79afb19fe4a.diff"

diff --git a/test/framework/DebuggerTestFixture.cs b/test/framework/DebuggerTestFixture.cs
index fc9245f..2351d94 100644
--- a/test/framework/DebuggerTestFixture.cs
+++ b/test/framework/DebuggerTestFixture.cs
@@ -132,6 +132,7 @@ namespace Mono.Debugger.Test.Framework
 
 		internal void AddEvent (DebuggerEvent e)
 		{
+			Report.Debug (DebugFlags.NUnit, "ADD EVENT: {0}", e);
 			lock (queue.SyncRoot) {
 				queue.Enqueue (e);
 				wait_event.Set ();

--------------1.5.6--



From 67ef575b2970be9ff7c4dcdc94205b1b4b3c7832 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Fri, 17 Jul 2009 23:44:17 +0200
Subject: [PATCH] More API cleanups.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/DebuggerServant.cs      |   13 ++-----------
 backend/ProcessServant.cs       |   29 +++++------------------------
 backend/SingleSteppingEngine.cs |   13 +++++++++----
 3 files changed, 16 insertions(+), 39 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="67ef575b2970be9ff7c4dcdc94205b1b4b3c7832.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="67ef575b2970be9ff7c4dcdc94205b1b4b3c7832.diff"

diff --git a/backend/DebuggerServant.cs b/backend/DebuggerServant.cs
index e621094..e4f75d7 100644
--- a/backend/DebuggerServant.cs
+++ b/backend/DebuggerServant.cs
@@ -60,6 +60,7 @@ namespace Mono.Debugger.Backend
 
 		internal void OnMainProcessCreatedEvent (ProcessServant process)
 		{
+			process_hash.Add (process, process);
 			client.OnMainProcessCreatedEvent (process.Client);
 		}
 
@@ -150,7 +151,6 @@ namespace Mono.Debugger.Backend
 
 			ProcessStart start = new ProcessStart (session);
 			main_process = thread_manager.StartApplication (start, out result);
-			process_hash.Add (main_process, main_process);
 			return main_process.Client;
 		}
 
@@ -163,7 +163,6 @@ namespace Mono.Debugger.Backend
 
 			ProcessStart start = new ProcessStart (session, pid);
 			main_process = thread_manager.StartApplication (start, out result);
-			process_hash.Add (main_process, main_process);
 			return main_process.Client;
 		}
 
@@ -225,12 +224,8 @@ namespace Mono.Debugger.Backend
 			if ((model & ThreadingModel.ThreadingMode) != ThreadingModel.Global)
 				return caller.Process.StartOperation (model, caller);
 
-			if (current_operation != null) {
-				Console.WriteLine ("NOT STOPPED: {0} {1}", model, caller);
+			if (current_operation != null)
 				throw new TargetException (TargetError.NotStopped);
-			}
-
-			Console.WriteLine ("START GLOBAL OPERATION: {0} {1} - {2}", model, caller, process_hash.Count);
 
 			lock (this) {
 				stopped_event.Reset ();
@@ -241,8 +236,6 @@ namespace Mono.Debugger.Backend
 				process.StartGlobalOperation (model, caller, current_operation);
 			}
 
-			Console.WriteLine ("START GLOBAL OPERATION DONE: {0} {1}", model, caller);
-
 			return current_operation;
 		}
 
@@ -251,8 +244,6 @@ namespace Mono.Debugger.Backend
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
 
-			Console.WriteLine ("DEBUGGER OPERATION COMPLETED: {0} {1} {2}", caller, result, model);
-
 			foreach (ProcessServant process in process_hash.Values) {
 				process.OperationCompleted (caller, result, model);
 			}
diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index fb2e5ee..28b971a 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -338,21 +338,8 @@ namespace Mono.Debugger.Backend
 			session.OnMainProcessCreated (client);
 			manager.Debugger.OnMainProcessCreatedEvent (this);
 
-			switch (start.Session.Config.ThreadingModel & ThreadingModel.ThreadingMode) {
-			case ThreadingModel.Single:
-				current_state = ProcessState.SingleThreaded;
-				return engine.StartApplication (new ThreadCommandResult (engine.Thread));
-			case ThreadingModel.Process:
-				current_state = ProcessState.Running;
-				current_operation = new OperationCommandResult (this, start.Session.Config.ThreadingModel);
-				return engine.StartApplication (current_operation);
-			case ThreadingModel.Global:
-				current_state = ProcessState.Running;
-				current_operation = new OperationCommandResult (Debugger, start.Session.Config.ThreadingModel);
-				return engine.StartApplication (current_operation);
-			default:
-				goto case ThreadingModel.Single;
-			}
+			CommandResult result = Debugger.StartOperation (start.Session.Config.ThreadingModel, engine);
+			return engine.StartApplication (result);
 		}
 
 		internal void OnProcessExitedEvent ()
@@ -716,17 +703,14 @@ namespace Mono.Debugger.Backend
 
 		protected ST.ManualResetEvent stopped_event;
 
-		ProcessState current_state = ProcessState.Unknown;
+		ProcessState current_state = ProcessState.Stopped;
 		OperationCommandResult current_operation = null;
 
 		public void OperationCompleted (SingleSteppingEngine caller, TargetEventArgs result, ThreadingModel model)
 		{
-			if (!ThreadManager.InBackgroundThread)
+			if (!ThreadManager.InBackgroundThread || (current_state != ProcessState.Running))
 				throw new InternalError ();
 
-			Report.Debug (DebugFlags.EventLoop, "{0} completed operation: {1} {2} {3}", caller, current_state, caller.State, result);
-
-			if (current_state == ProcessState.Running) {
 				if ((result != null) && (caller != main_thread) &&
 				    ((result.Type == TargetEventType.TargetExited) || (result.Type == TargetEventType.TargetSignaled)))
 					return;
@@ -740,9 +724,6 @@ namespace Mono.Debugger.Backend
 					current_operation = null;
 					stopped_event.Set ();
 				}
-			} else {
-				throw new InternalError ("FUCK: {0} {1}", caller, current_state);
-			}
 		}
 
 		protected void SuspendUserThreads (ThreadingModel model, SingleSteppingEngine caller)
@@ -834,7 +815,7 @@ namespace Mono.Debugger.Backend
 
 		internal void StartGlobalOperation (ThreadingModel model, SingleSteppingEngine caller, OperationCommandResult operation)
 		{
-			Console.WriteLine ("START GLOBAL OPERATION: {0} {1} {2}", client, model, caller);
+			Console.WriteLine ("PROCESS START GLOBAL OPERATION: {0} {1} {2}", client, model, caller);
 
 			if ((current_state != ProcessState.Stopped) && (current_state != ProcessState.SingleThreaded)) {
 				Console.WriteLine ("NOT STOPPED: {0} {1}", model, current_state);
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 6e5b395..076faf1 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -195,7 +195,7 @@ namespace Mono.Debugger.Backend
 				string frame_text = "";
 				Inferior.StackFrame iframe = inferior.GetCurrentFrame (true);
 				if (iframe != null)
-					frame_text = "at " + iframe.Address.ToString ();
+					frame_text = " at " + iframe.Address.ToString ();
 
 				string running_text;
 				if (HasThreadLock)
@@ -209,7 +209,7 @@ namespace Mono.Debugger.Backend
 				else
 					event_text = "event " + cevent.ToString ();
 
-				Report.Debug (DebugFlags.EventLoop, "{0} received {1} {2} while {3}",
+				Report.Debug (DebugFlags.EventLoop, "{0} received {1}{2} while {3}",
 					      this, event_text, frame_text, running_text);
 
 				if (HasThreadLock) {
@@ -3553,8 +3553,13 @@ namespace Mono.Debugger.Backend
 		protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
 							       out TargetEventArgs args)
 		{
-			Report.Debug (DebugFlags.EventLoop, "{0} received {1} at {2} in {3}",
-				      sse, cevent, inferior.CurrentFrame, this);
+			string frame_text = "";
+			Inferior.StackFrame iframe = inferior.GetCurrentFrame (true);
+			if (iframe != null)
+				frame_text = " at " + iframe.Address.ToString ();
+
+			Report.Debug (DebugFlags.EventLoop, "{0} received {1}{2} in {3}",
+				      sse, cevent, frame_text, this);
 
 			if ((StepMode == StepMode.Run) &&
 			    ((cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) ||

--------------1.5.6--



From 4c3c12cc9260f5404feead4a0e7586b0e8282f90 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Fri, 17 Jul 2009 23:51:47 +0200
Subject: [PATCH] More API cleanups.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs |   59 +++++++++++++++++++++-----------------------
 1 files changed, 28 insertions(+), 31 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="4c3c12cc9260f5404feead4a0e7586b0e8282f90.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="4c3c12cc9260f5404feead4a0e7586b0e8282f90.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 28b971a..c63c280 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -238,14 +238,8 @@ namespace Mono.Debugger.Backend
 			manager.Debugger.OnProcessCreatedEvent (new_process);
 			new_process.OnThreadCreatedEvent (new_thread);
 
-			if (current_state == ProcessState.Running) {
-				new_process.current_state = ProcessState.Running;
-				new_process.current_operation = current_operation;
-				new_thread.StartForkedChild (new_process.current_operation);
-			} else {
-				new_process.current_state = ProcessState.SingleThreaded;
-				new_thread.StartForkedChild (new ThreadCommandResult (new_thread.Thread));
-			}
+			CommandResult result = new_process.CloneParentOperation (new_thread);
+			new_thread.StartForkedChild (result);
 		}
 
 		internal void ChildExecd (Inferior inferior)
@@ -307,17 +301,8 @@ namespace Mono.Debugger.Backend
 			manager.Debugger.OnThreadCreatedEvent (new_thread.Thread);
 			initialized = is_forked = false;
 
-			if (parent.current_state == ProcessState.Running) {
-				current_state = ProcessState.Running;
-				if ((parent.current_operation.ThreadingModel & ThreadingModel.ThreadingMode) == ThreadingModel.Global)
-					current_operation = parent.current_operation;
-				else
-					current_operation = new OperationCommandResult (this, parent.current_operation.ThreadingModel);
-				new_thread.StartExecedChild (current_operation);
-			} else {
-				current_state = ProcessState.SingleThreaded;
-				new_thread.StartExecedChild (new ThreadCommandResult (new_thread.Thread));
-			}
+			CommandResult result = CloneParentOperation (new_thread);
+			new_thread.StartExecedChild (result);
 		}
 
 		internal CommandResult StartApplication ()
@@ -693,7 +678,6 @@ namespace Mono.Debugger.Backend
 
 		internal enum ProcessState
 		{
-			Unknown,
 			SingleThreaded,
 			Running,
 			Stopping,
@@ -784,13 +768,6 @@ namespace Mono.Debugger.Backend
 			if (!ThreadManager.InBackgroundThread)
 				throw new InternalError ();
 
-			if ((model & ThreadingModel.ThreadingMode) == ThreadingModel.Default) {
-				if (Inferior.HasThreadEvents)
-					model |= ThreadingModel.Single;
-				else
-					model |= ThreadingModel.Process;
-			}
-
 			if ((current_state != ProcessState.Stopped) && (current_state != ProcessState.SingleThreaded))
 				throw new TargetException (TargetError.NotStopped);
 
@@ -815,12 +792,11 @@ namespace Mono.Debugger.Backend
 
 		internal void StartGlobalOperation (ThreadingModel model, SingleSteppingEngine caller, OperationCommandResult operation)
 		{
-			Console.WriteLine ("PROCESS START GLOBAL OPERATION: {0} {1} {2}", client, model, caller);
+			if (!ThreadManager.InBackgroundThread)
+				throw new InternalError ();
 
-			if ((current_state != ProcessState.Stopped) && (current_state != ProcessState.SingleThreaded)) {
-				Console.WriteLine ("NOT STOPPED: {0} {1}", model, current_state);
+			if ((current_state != ProcessState.Stopped) && (current_state != ProcessState.SingleThreaded))
 				throw new TargetException (TargetError.NotStopped);
-			}
 
 			lock (this) {
 				current_state = ProcessState.Running;
@@ -831,6 +807,27 @@ namespace Mono.Debugger.Backend
 			ResumeUserThreads (model, caller);
 		}
 
+		protected CommandResult CloneParentOperation (SingleSteppingEngine new_thread)
+		{
+			if (parent.current_state == ProcessState.SingleThreaded) {
+				current_state = ProcessState.SingleThreaded;
+				return new ThreadCommandResult (new_thread.Thread);
+			}
+
+			if (parent.current_state != ProcessState.Running)
+				throw new InternalError ();
+
+			current_state = ProcessState.Running;
+			if ((parent.current_operation.ThreadingModel & ThreadingModel.ThreadingMode) == ThreadingModel.Global)
+				current_operation = parent.current_operation;
+			else if ((parent.current_operation.ThreadingModel & ThreadingModel.ThreadingMode) == ThreadingModel.Process)
+				current_operation = new OperationCommandResult (this, parent.current_operation.ThreadingModel);
+			else
+				throw new InternalError ();
+
+			return current_operation;
+		}
+
 		internal void Stop ()
 		{
 			Console.WriteLine ("STOP PROCESS !");

--------------1.5.6--



From 311ffa7640d9fd1b1f6797963266edcb78643cc8 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Sat, 18 Jul 2009 00:00:19 +0200
Subject: [PATCH] Fix config.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 classes/DebuggerConfiguration.cs |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="311ffa7640d9fd1b1f6797963266edcb78643cc8.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="311ffa7640d9fd1b1f6797963266edcb78643cc8.diff"

diff --git a/classes/DebuggerConfiguration.cs b/classes/DebuggerConfiguration.cs
index 47391f7..5485098 100644
--- a/classes/DebuggerConfiguration.cs
+++ b/classes/DebuggerConfiguration.cs
@@ -139,6 +139,9 @@ namespace Mono.Debugger
 					case "process":
 						threading_model |= ThreadingModel.Process;
 						break;
+					case "global":
+						threading_model |= ThreadingModel.Global;
+						break;
 					case "default":
 						break;
 					default:
@@ -215,6 +218,9 @@ namespace Mono.Debugger
 				case ThreadingModel.Process:
 					threading_model_e.InnerText = "process";
 					break;
+				case ThreadingModel.Global:
+					threading_model_e.InnerText = "global";
+					break;
 				default:
 					threading_model_e.InnerText = "default";
 					break;

--------------1.5.6--



From c2926de2ceb14cf958841070a4eac639c3984695 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Sat, 18 Jul 2009 00:00:36 +0200
Subject: [PATCH] Fix stopping.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/DebuggerServant.cs |    4 +++-
 backend/ProcessServant.cs  |   11 ++++++-----
 2 files changed, 9 insertions(+), 6 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="c2926de2ceb14cf958841070a4eac639c3984695.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="c2926de2ceb14cf958841070a4eac639c3984695.diff"

diff --git a/backend/DebuggerServant.cs b/backend/DebuggerServant.cs
index e4f75d7..6c539c0 100644
--- a/backend/DebuggerServant.cs
+++ b/backend/DebuggerServant.cs
@@ -265,7 +265,9 @@ namespace Mono.Debugger.Backend
 
 		void IOperationHost.Abort ()
 		{
-			// Stop ();
+			foreach (ProcessServant process in process_hash.Values) {
+				process.Stop ();
+			}
 		}
 
 #endregion
diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index c63c280..cf6b4fd 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -692,7 +692,12 @@ namespace Mono.Debugger.Backend
 
 		public void OperationCompleted (SingleSteppingEngine caller, TargetEventArgs result, ThreadingModel model)
 		{
-			if (!ThreadManager.InBackgroundThread || (current_state != ProcessState.Running))
+			if (!ThreadManager.InBackgroundThread)
+				throw new InternalError ();
+
+			if (current_state == ProcessState.Stopping)
+				return;
+			else if (current_state != ProcessState.Running)
 				throw new InternalError ();
 
 			if ((result != null) && (caller != main_thread) &&
@@ -830,12 +835,9 @@ namespace Mono.Debugger.Backend
 
 		internal void Stop ()
 		{
-			Console.WriteLine ("STOP PROCESS !");
-
 			main_thread.Invoke (delegate {
 				current_state = ProcessState.Stopping;
 
-				Console.WriteLine ("STOP PROCESS #!");
 				SuspendUserThreads (ThreadingModel.Process, null);
 				current_state = ProcessState.Stopped;
 				if (current_operation != null) {
@@ -843,7 +845,6 @@ namespace Mono.Debugger.Backend
 					current_operation = null;
 				}
 				stopped_event.Set ();
-				Console.WriteLine ("STOP PROCESS #2");
 				return null;
 			}, null);
 		}

--------------1.5.6--



From c938378293b7aa097df103d1b55bbbfff5bd3825 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Sat, 18 Jul 2009 00:04:36 +0200
Subject: [PATCH] Small fix.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessServant.cs |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="c938378293b7aa097df103d1b55bbbfff5bd3825.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="c938378293b7aa097df103d1b55bbbfff5bd3825.diff"

diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index cf6b4fd..e776c2e 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -300,6 +300,7 @@ namespace Mono.Debugger.Backend
 			manager.Debugger.OnProcessExecdEvent (this);
 			manager.Debugger.OnThreadCreatedEvent (new_thread.Thread);
 			initialized = is_forked = false;
+			main_thread = new_thread;
 
 			CommandResult result = CloneParentOperation (new_thread);
 			new_thread.StartExecedChild (result);

--------------1.5.6--


