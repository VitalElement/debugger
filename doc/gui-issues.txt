There are some important threading issues to consider when writing a
GUI for the debugger.  This especially applies to making the debugger
an out-of-proc component.

The biggest challenge is finding the correct place to put the process
boundary.

At the moment, the debugger consists of two parts: a frontend and a
backend which both live in two different application domains.

The Backend:
------------

The backend is basically everything in the Mono.Debugger.Backends
namespace - its most important classes are

	ThreadManager
	DebuggerServant
	ThreadServant
	SingleSteppingEngine (derives from ThreadServant)

it is in a separate application domain so we can easily unload
assemblies and symbol tables.

One important thing to keep in mind when embedding the debugger in
another application is that your are not allowed to use any of fork()
or wait() in the same process where the backend lives.

Regarding stability, the backend is the only "critical" part of the
debugger.

The Frontend:
-------------

The frontend is basically everything in the Mono.Debugger and the
Mono.Debugger.Frontend namespaces - its most important classes are

	Interpreter
	Debugger
	Thread

The main job of the frontend is basically communicating with the
backend and providing a high-level user interfaces.

The frontend contains code which blocks on events from the backend,
but there is nothing which could potentially crash a bigger
application like MonoDevelop and there are also no constraints
regarding fork() and wait().

So in theory, it should be safe to have the frontend in the same
process than MonoDevelop.

Commands in the `Thread' class:
-------------------------------

Most of the functions in the frontend are async - for instance,
stepping operations look like this:

	// <summary>
	//   Step one source line.
	// </summary>
	public CommandResult StepLine ()
	{
		lock (this) {
			check_servant ();
			operation_completed_event.Reset ();
			CommandResult result = new StepCommandResult (this);
			servant.StepLine (result);
			return result;
		}
	}

Here, `servant.StepLine (result)' just starts the operation (or throws
an exception if something goes wrong, for instance no target), but
does not block.  These commands return a `CommandResult' which you can
Wait() on.

When doing this out-of-proc, the only thing we probably need to keep
in mind is that the `servant' might be dead, not responding etc. - but
in general, this should be ok.

Some commands return a result:

	public override AssemblerLine DisassembleInstruction (Method method, TargetAddress address)
	{
		check_servant ();
		return servant.DisassembleInstruction (method, address);
	}

These need to go through the debugger's main loop, but they should
never block.  Going through the debugger's main loop is, however, an
expensive operation, so it might be unacceptable to use them directly
from a GUI thread - we have to check.

When out-of-proc, the `servant' could also be dead, not responding or
crash during that call, so remoting should detect that somehow.

Some commands block on the target:

	public TargetObject RuntimeInvoke (TargetFunctionType function,
					   TargetClassObject object_argument,
					   TargetObject[] param_objects,
					   bool is_virtual, out string exc_message)
	{
		CommandResult result;

		lock (this) {
			check_servant ();
			result = servant.RuntimeInvoke (
				function, object_argument, param_objects, is_virtual, false);
		}

		result.Wait ();

		RuntimeInvokeResult res = (RuntimeInvokeResult) result.Result;
		if (res == null) {
			exc_message = null;
			return null;
		}
		exc_message = res.ExceptionMessage;
		return res.ReturnObject;
	}

This command may take a very long time to complete ....

Callbacks from the backend:
---------------------------

Sometimes, the backend must send some event to the frontend.  This may
cause some problems when out-of-proc.

At the moment, it basically works like this.

On the sending side in the backend - in `DebuggerServant':

	internal void SendTargetEvent (SingleSteppingEngine sse, TargetEventArgs args)
	{
		try {
			if (sse.Thread.IsDaemon &&
			    ((args.Type == TargetEventType.TargetExited) ||
			     (args.Type == TargetEventType.TargetSignaled)))
				return;
			client.OnTargetEvent (sse.Thread, args);
		} catch (Exception ex) {
			Error ("{0} caught exception while sending {1}:\n{2}",
			       sse, args, ex);
		}
	}

Here, 'client' is an instance of `Debugger' and `sse.Thread' an
instance of `Thread'.

On the receiving side in the frontend - in `Debugger':

	internal void OnTargetEvent (Thread thread, TargetEventArgs args)
	{
		if (TargetEvent != null)
			TargetEvent (thread, args);
	}

The `TargetEventArgs args' is serializable - no problem with that.

Note that there is a big problem if the frontend uses the `thread'
argument to call back into the backend and we're out-of-proc:

At the moment, we're just in another appdomain, so the call stays in
the same thread and we can easily call back.

However, when out-of-proc, remoting would process such a call in
another thread - and when in another thread, we need to go through the
debugger's main loop and dead-lock forever.

In detail - it works like this:

* the debugger's main loop - which is running in the engine thread -
  calls DebuggerServant.SendTargetEvent().
* that function launches a remote call to Debugger.OnTargetEvent() -
  which is in another process and waits for its completion.
* when the other process calls back into the SingleSteppingEngine,
  remoting processes the request in another thread.
* the SingleSteppingEngine can only handle the request from inside the
  engine thread, so it has to go through the main loop.
* the main loop is currently blocking on Debugger.OnTargetEvent() to
  return, so the request would fail.

Making the event async is not really an option - the event handler
normally needs to call a lot of stuff on the `thread' - ie. get stack
traces, disassemble code, get locals etc.

Going through the main-loop each time would be very slow - so I think
what we need to do is using some kind of a serializable delegate which
runs inside the backend's process and gathers all the required
information before passing them to the frontend's process.

So we need to make some API changes here.


Last changed June 13th, 2006
Martin Baulig <martin@ximian.com>
