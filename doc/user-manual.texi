\input texinfo    @c -*-texinfo-*-

@setfilename user-manual.info

@ifnottex
@node Top, Expressions, (dir), (dir)
@top User Manual
@end ifnottex

@menu
* Expressions::                 
* Commands::                    
@end menu

@node Expressions, Commands, Top, Top
@chapter Expressions

The Mono Debugger has a built-in expression parser to parse
expressions in a C#-like language.  C#-like means that it is almost
C#, but not everything is supported and some things are different due
to the nature of being used in a debugger.

However, the semantic is different based on the language of the method
you're currently debugging.  This means, that for instance while
debugging unmanaged code, the debugger will behave more like C than
like C#.

@menu
* Simple Expressions::          
* Source Locations::            
@end menu

@node Simple Expressions, Source Locations, Expressions, Expressions
@section Simple Expressions

You can specify variable, type and method names just like in C#.
However, at the moment (as of April 19th, 2004), name lookup only
happens in the programming language of the current frame.

This means that while debugging managed code, you can't insert
breakpoints and things like that in unmanaged functions.

Examples for unmanaged code:

@example
break main
break mono_class_init
@end example

Examples for managed code:

@example
break Main
break X.Main
@end example

@node Source Locations,  , Simple Expressions, Expressions
@section Source Locations

This is an expression which specifies the location for inserting a
breakpoint or viewing the source code.  The @code{break}
(@xref{break}) and @code{list} (@xref{list}) commands both use the
same syntax.

There are several ways to specify a source location

@itemize @bullet
@item You can just use a line number to specify that line in the
current source file.

@example
break 128
@end example

This inserts a breakpoint on line 128 in the current file.

@item You can use a file name and line number:

@example
break TestManagedTypes.cs:128
@end example

This inserts a breakpoint on line 128 in @file{TestManagedTypes.cs}.

@item Use a method name

If it's not a line number or a file and line number, the debugger
assumes that it's actually an expression and parses it.  This allows
you to insert breakpoints on methods.

Method lookup is done in a similar way than in C#, but no namespace
lookup takes place.  Members are, however, looked up in the current
class.

Let's have a look at the following example:

@example
public class X
@{
        public static void Test ()
        @{ @}

        public void Foo ()
        @{ @}

        public static void Bar (X x)
        @{
                // You are here.
        @}
@end example

Now, you can insert a breakpoint on the static method @code{X.Test} by
just saying

@example
break Test
@end example

or

@example
break X.Test
@end example

However, since you're in static code, you cannot say

@example
break Foo
@end example

to insert a breakpoint on the instance method @code{Foo}.  In C#, it
would be an error to invoke the method by just saying @code{Foo ()},
so the debugger doesn't allow it either (internally, the debugger is
parsing your expression as if it was an invocation).

The correct command is (@code{x} is an instance of @code{X} in the
current context).

@example
break x.Foo
@end example

@item Overload Resolution

Sometimes, just using the function name would be ambigous since there
are several overloaded versions of that method.  In this case,
overload resolution is done just like in C#.  Note that you need to
use types, not actual arguments when inserting breakpoints:

@example
break System.Console.WriteLine(System.Int32)
@end example

@item Method Lookup History

If you just specify a method name and it's ambiguous, the debugger
presents you with a list from which you can choose:

@example
(mdb) break System.Console.WriteLine
More than one method matches your query:
   1  System.Console.WriteLine()
   2  System.Console.WriteLine(System.Boolean)
   3  System.Console.WriteLine(System.Char)
   4  System.Console.WriteLine(System.Char[])
   5  System.Console.WriteLine(System.Decimal)
   6  System.Console.WriteLine(System.Double)
   7  System.Console.WriteLine(System.Int32)
   8  System.Console.WriteLine(System.Int64)
   9  System.Console.WriteLine(System.Object)
  10  System.Console.WriteLine(System.Single)
  11  System.Console.WriteLine(System.String)
  12  System.Console.WriteLine(System.UInt32)
  13  System.Console.WriteLine(System.UInt64)
  14  System.Console.WriteLine(System.String,System.Object)
  15  System.Console.WriteLine(System.String,System.Object[])
  16  System.Console.WriteLine(System.Char[],System.Int32,System.Int32)
  17  System.Console.WriteLine(System.String,System.Object,System.Object)
  18  System.Console.WriteLine(System.String,System.Object,System.Object,System.Object)
  19  System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)

(mdb) break -id 7
Inserted breakpoint 2 at System.Console.WriteLine(System.Int32)
@end example

@end itemize

       
@node Commands,  , Expressions, Top
@chapter Commands

@menu
* break::                       
* list::                        
@end menu

@node break, list, Commands, Commands
@section break

@node list,  , break, Commands
@section list

