From 0c1737789419d6d36dd74bf9e7375c3c6c9bde37 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Mon, 7 Sep 2009 12:02:06 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/Makefile.am                   |    2 +-
 backend/ProcessServant.cs             |    1 +
 backend/SingleSteppingEngine.cs       |    1 +
 backend/arch/CoreFile.cs              |    2 +-
 backend/mono/.gitignore               |    2 +
 backend/mono/Makefile.am              |    1 +
 backend/mono/MonoRuntime.cs           |  700 +++++++++++++++++++++++++++++++++
 backend/mono/MonoThreadManager.cs     |  639 ++++++++++++++++++++++++++++++
 build/Makefile.am                     |    1 +
 configure.in                          |    1 +
 languages/mono/MonoClassInfo.cs       |    1 +
 languages/mono/MonoLanguageBackend.cs |    1 +
 12 files changed, 1350 insertions(+), 2 deletions(-)
 create mode 100644 backend/mono/.gitignore
 create mode 100644 backend/mono/Makefile.am
 create mode 100644 backend/mono/MonoRuntime.cs
 create mode 100644 backend/mono/MonoThreadManager.cs
--------------1.5.6
Content-Type: text/x-patch; name="0c1737789419d6d36dd74bf9e7375c3c6c9bde37.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="0c1737789419d6d36dd74bf9e7375c3c6c9bde37.diff"

diff --git a/backend/Makefile.am b/backend/Makefile.am
index c430e8b..6a86764 100644
--- a/backend/Makefile.am
+++ b/backend/Makefile.am
@@ -1,3 +1,3 @@
-SUBDIRS = arch os server
+SUBDIRS = arch os mono server
 
 EXTRA_DIST = $(srcdir)/*.cs
diff --git a/backend/ProcessServant.cs b/backend/ProcessServant.cs
index 4764743..9261e74 100644
--- a/backend/ProcessServant.cs
+++ b/backend/ProcessServant.cs
@@ -8,6 +8,7 @@ using System.Runtime.Serialization;
 using System.Runtime.Serialization.Formatters.Binary;
 
 using Mono.Debugger.Backend;
+using Mono.Debugger.Backend.Mono;
 using Mono.Debugger.Architectures;
 using Mono.Debugger.Languages;
 using Mono.Debugger.Languages.Native;
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index d8958ee..661bf8b 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -16,6 +16,7 @@ using System.Runtime.Remoting.Messaging;
 using Mono.Debugger.Languages;
 using Mono.Debugger.Languages.Mono;
 using Mono.Debugger.Architectures;
+using Mono.Debugger.Backend.Mono;
 
 namespace Mono.Debugger.Backend
 {
diff --git a/backend/arch/CoreFile.cs b/backend/arch/CoreFile.cs
index 5dc81b1..12a9ad0 100644
--- a/backend/arch/CoreFile.cs
+++ b/backend/arch/CoreFile.cs
@@ -3,8 +3,8 @@ using System.IO;
 using System.Collections;
 using ST = System.Threading;
 using System.Runtime.InteropServices;
+using Mono.Debugger.Backend.Mono;
 using Mono.Debugger.Languages;
-using Mono.Debugger.Languages.Mono;
 
 namespace Mono.Debugger.Backend
 {
diff --git a/backend/mono/.gitignore b/backend/mono/.gitignore
new file mode 100644
index 0000000..9ee6454
--- /dev/null
+++ b/backend/mono/.gitignore
@@ -0,0 +1,2 @@
+/Makefile.in
+/Makefile
diff --git a/backend/mono/Makefile.am b/backend/mono/Makefile.am
new file mode 100644
index 0000000..bd74aad
--- /dev/null
+++ b/backend/mono/Makefile.am
@@ -0,0 +1 @@
+EXTRA_DIST = $(srcdir)/*.cs
diff --git a/backend/mono/MonoRuntime.cs b/backend/mono/MonoRuntime.cs
new file mode 100644
index 0000000..d2f6add
--- /dev/null
+++ b/backend/mono/MonoRuntime.cs
@@ -0,0 +1,700 @@
+using System;
+
+using Mono.Debugger.Languages;
+using Mono.Debugger.Languages.Mono;
+
+namespace Mono.Debugger.Backend.Mono
+{
+	internal enum MonoTypeEnum
+	{
+		MONO_TYPE_END        = 0x00,       /* End of List */
+		MONO_TYPE_VOID       = 0x01,
+		MONO_TYPE_BOOLEAN    = 0x02,
+		MONO_TYPE_CHAR       = 0x03,
+		MONO_TYPE_I1         = 0x04,
+		MONO_TYPE_U1         = 0x05,
+		MONO_TYPE_I2         = 0x06,
+		MONO_TYPE_U2         = 0x07,
+		MONO_TYPE_I4         = 0x08,
+		MONO_TYPE_U4         = 0x09,
+		MONO_TYPE_I8         = 0x0a,
+		MONO_TYPE_U8         = 0x0b,
+		MONO_TYPE_R4         = 0x0c,
+		MONO_TYPE_R8         = 0x0d,
+		MONO_TYPE_STRING     = 0x0e,
+		MONO_TYPE_PTR        = 0x0f,       /* arg: <type> token */
+		MONO_TYPE_BYREF      = 0x10,       /* arg: <type> token */
+		MONO_TYPE_VALUETYPE  = 0x11,       /* arg: <type> token */
+		MONO_TYPE_CLASS      = 0x12,       /* arg: <type> token */
+		MONO_TYPE_VAR	     = 0x13,	   /* number */
+		MONO_TYPE_ARRAY      = 0x14,       /* type, rank, boundsCount, bound1, loCount, lo1 */
+		MONO_TYPE_GENERICINST= 0x15,	   /* <type> <type-arg-count> <type-1> \x{2026} <type-n> */
+		MONO_TYPE_TYPEDBYREF = 0x16,
+		MONO_TYPE_I          = 0x18,
+		MONO_TYPE_U          = 0x19,
+		MONO_TYPE_FNPTR      = 0x1b,	      /* arg: full method signature */
+		MONO_TYPE_OBJECT     = 0x1c,
+		MONO_TYPE_SZARRAY    = 0x1d,       /* 0-based one-dim-array */
+		MONO_TYPE_MVAR	     = 0x1e,       /* number */
+		MONO_TYPE_CMOD_REQD  = 0x1f,       /* arg: typedef or typeref token */
+		MONO_TYPE_CMOD_OPT   = 0x20,       /* optional arg: typedef or typref token */
+		MONO_TYPE_INTERNAL   = 0x21,       /* CLR internal type */
+
+		MONO_TYPE_MODIFIER   = 0x40,       /* Or with the following types */
+		MONO_TYPE_SENTINEL   = 0x41,       /* Sentinel for varargs method signature */
+		MONO_TYPE_PINNED     = 0x45,       /* Local var that points to pinned object */
+
+		MONO_TYPE_ENUM       = 0x55        /* an enumeration */
+	}
+
+	internal class MonoRuntime : DebuggerMarshalByRefObject
+	{
+		protected readonly MonoDebuggerInfo MonoDebuggerInfo;
+		protected readonly MetadataInfo MonoMetadataInfo;
+
+		protected MonoRuntime (MonoDebuggerInfo info, MetadataInfo metadata)
+		{
+			this.MonoDebuggerInfo = info;
+			this.MonoMetadataInfo = metadata;
+		}
+
+		public static MonoRuntime Create (TargetMemoryAccess memory, MonoDebuggerInfo info)
+		{
+			MetadataInfo metadata = new MetadataInfo (memory, info.MonoMetadataInfo);
+			return new MonoRuntime (info, metadata);
+		}
+
+		//
+		// MonoClass
+		//
+
+		public TargetAddress MonoClassGetMonoImage (TargetMemoryAccess memory,
+							    TargetAddress klass)
+		{
+			return memory.ReadAddress (klass + MonoMetadataInfo.KlassImageOffset);
+		}
+
+		public int MonoClassGetToken (TargetMemoryAccess memory,
+					      TargetAddress klass)
+		{
+			return memory.ReadInteger (klass + MonoMetadataInfo.KlassTokenOffset);
+		}
+
+		public int MonoClassGetInstanceSize (TargetMemoryAccess memory,
+						     TargetAddress klass)
+		{
+			int flags = memory.ReadInteger (klass + 4 * memory.TargetAddressSize);
+
+			bool size_inited = (flags & 4) != 0;
+			bool valuetype = (flags & 8) != 0;
+
+			if (!size_inited)
+				throw new TargetException (TargetError.ClassNotInitialized);
+
+			int size = memory.ReadInteger (klass + 4 + 3 * memory.TargetAddressSize);
+			if (valuetype)
+				size -= 2 * memory.TargetAddressSize;
+
+			return size;
+		}
+
+		public TargetAddress MonoClassGetParent (TargetMemoryAccess memory,
+							 TargetAddress klass)
+		{
+			return memory.ReadAddress (klass + MonoMetadataInfo.KlassParentOffset);
+		}
+
+		public TargetAddress MonoClassGetGenericClass (TargetMemoryAccess memory,
+							       TargetAddress klass)
+		{
+			return memory.ReadAddress (klass + MonoMetadataInfo.KlassGenericClassOffset);
+		}
+
+		public TargetAddress MonoClassGetGenericContainer (TargetMemoryAccess memory,
+								   TargetAddress klass)
+		{
+			return memory.ReadAddress (klass + MonoMetadataInfo.KlassGenericContainerOffset);
+		}
+
+		public TargetAddress MonoClassGetByValType (TargetMemoryAccess memory,
+							    TargetAddress klass)
+		{
+			return klass + MonoMetadataInfo.KlassByValArgOffset;
+		}
+
+		public bool MonoClassHasFields (TargetMemoryAccess memory, TargetAddress klass)
+		{
+			TargetAddress fields = memory.ReadAddress (
+				klass + MonoMetadataInfo.KlassFieldOffset);
+			return !fields.IsNull;
+		}
+
+		public int MonoClassGetFieldCount (TargetMemoryAccess memory, TargetAddress klass)
+		{
+			return memory.ReadInteger (klass + MonoMetadataInfo.KlassFieldCountOffset);
+		}
+
+		public TargetAddress MonoClassGetFieldType (TargetMemoryAccess memory, TargetAddress klass,
+							    int index)
+		{
+			int offset = index * MonoMetadataInfo.FieldInfoSize +
+				MonoMetadataInfo.FieldInfoTypeOffset;
+
+			TargetAddress fields = memory.ReadAddress (
+				klass + MonoMetadataInfo.KlassFieldOffset);
+			if (fields.IsNull)
+				throw new TargetException (TargetError.ClassNotInitialized);
+
+			return memory.ReadAddress (fields + offset);
+		}
+
+		public int MonoClassGetFieldOffset (TargetMemoryAccess memory, TargetAddress klass,
+						    int index)
+		{
+			int offset = index * MonoMetadataInfo.FieldInfoSize +
+				MonoMetadataInfo.FieldInfoOffsetOffset;
+
+			TargetAddress fields = memory.ReadAddress (
+				klass + MonoMetadataInfo.KlassFieldOffset);
+			if (fields.IsNull)
+				throw new TargetException (TargetError.ClassNotInitialized);
+
+			return memory.ReadInteger (fields + offset);
+		}
+
+		public bool MonoClassHasMethods (TargetMemoryAccess memory, TargetAddress klass)
+		{
+			TargetAddress methods = memory.ReadAddress (
+				klass + MonoMetadataInfo.KlassMethodsOffset);
+			return !methods.IsNull;
+		}
+
+		public int MonoClassGetMethodCount (TargetMemoryAccess memory, TargetAddress klass)
+		{
+			return memory.ReadInteger (klass + MonoMetadataInfo.KlassMethodCountOffset);
+		}
+
+		public TargetAddress MonoClassGetMethod (TargetMemoryAccess memory, TargetAddress klass,
+							 int index)
+		{
+			TargetAddress methods = memory.ReadAddress (
+				klass + MonoMetadataInfo.KlassMethodsOffset);
+
+			if (methods.IsNull)
+				throw new TargetException (TargetError.ClassNotInitialized);
+
+			methods += index * memory.TargetAddressSize;
+			return memory.ReadAddress (methods);
+		}
+
+		//
+		// MonoMethod
+		//
+
+		public int MonoMethodGetToken (TargetMemoryAccess memory, TargetAddress method)
+		{
+			return memory.ReadInteger (method + MonoMetadataInfo.MonoMethodTokenOffset);
+		}
+
+		public TargetAddress MonoMethodGetClass (TargetMemoryAccess memory, TargetAddress method)
+		{
+			return memory.ReadAddress (method + MonoMetadataInfo.MonoMethodKlassOffset);
+		}
+
+		//
+		// MonoType
+		//
+
+		public MonoTypeEnum MonoTypeGetType (TargetMemoryAccess memory, TargetAddress type)
+		{
+			uint flags = (uint) memory.ReadInteger (
+				type + memory.TargetMemoryInfo.TargetAddressSize);
+
+			return (MonoTypeEnum) ((flags & 0x00ff0000) >> 16);
+		}
+
+		public bool MonoTypeGetIsByRef (TargetMemoryAccess memory, TargetAddress type)
+		{
+			uint flags = (uint) memory.ReadInteger (
+				type + memory.TargetMemoryInfo.TargetAddressSize);
+			return (int) ((flags & 0x40000000) >> 30) != 0;
+		}
+
+		public TargetAddress MonoTypeGetData (TargetMemoryAccess memory, TargetAddress type)
+		{
+			return memory.ReadAddress (type);
+		}
+
+		public TargetAddress MonoArrayTypeGetClass (TargetMemoryAccess memory,
+							    TargetAddress atype)
+		{
+			return memory.ReadAddress (atype);
+		}
+
+		public int MonoArrayTypeGetRank (TargetMemoryAccess memory,
+						 TargetAddress atype)
+		{
+			return memory.ReadByte (atype + memory.TargetAddressSize);
+		}
+
+		public int MonoArrayTypeGetNumSizes (TargetMemoryAccess memory,
+						     TargetAddress atype)
+		{
+			return memory.ReadByte (atype + memory.TargetAddressSize + 1);
+		}
+
+		public int MonoArrayTypeGetNumLoBounds (TargetMemoryAccess memory,
+							TargetAddress atype)
+		{
+			return memory.ReadByte (atype + memory.TargetAddressSize + 2);
+		}
+
+		internal void MonoArrayTypeGetBounds (TargetMemoryAccess memory,
+						      TargetAddress data)
+		{
+			//
+			// FIXME: Only check whether the low bounds are all zero
+			//
+			int num_sizes = memory.ReadByte (data + memory.TargetAddressSize + 1);
+			if (num_sizes != 0)
+				throw new InternalError ();
+
+			int num_lobounds = memory.ReadByte (data + memory.TargetAddressSize + 2);
+			if (num_lobounds == 0)
+				return;
+
+			TargetAddress array = memory.ReadAddress (data + 3 * memory.TargetAddressSize);
+			TargetBinaryReader bounds = memory.ReadMemory (array, num_lobounds * 4).GetReader ();
+			for (int i = 0; i < num_lobounds; i++) {
+				int bound = bounds.ReadInt32 ();
+				if (bound != 0)
+					throw new InternalError ();
+			}
+		}
+
+		//
+		// Fundamental types
+		//
+
+		public TargetAddress GetBooleanClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsBooleanOffset);
+		}
+
+		public TargetAddress GetCharClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsCharOffset);
+		}
+
+		public TargetAddress GetSByteClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsSByteOffset);
+		}
+
+		public TargetAddress GetByteClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsByteOffset);
+		}
+
+		public TargetAddress GetInt16Class (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsInt16Offset);
+		}
+
+		public TargetAddress GetUInt16Class (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsUInt16Offset);
+		}
+
+		public TargetAddress GetInt32Class (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsInt32Offset);
+		}
+
+		public TargetAddress GetUInt32Class (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsUInt32Offset);
+		}
+
+		public TargetAddress GetInt64Class (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsInt64Offset);
+		}
+
+		public TargetAddress GetUInt64Class (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsUInt64Offset);
+		}
+
+		public TargetAddress GetSingleClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsSingleOffset);
+		}
+
+		public TargetAddress GetDoubleClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsDoubleOffset);
+		}
+
+		public TargetAddress GetIntPtrClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsIntOffset);
+		}
+
+		public TargetAddress GetUIntPtrClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsUIntOffset);
+		}
+
+		public TargetAddress GetVoidClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsVoidOffset);
+		}
+
+		public TargetAddress GetStringClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsStringOffset);
+		}
+
+		public TargetAddress GetObjectClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsObjectOffset);
+		}
+
+		public TargetAddress GetArrayClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsArrayOffset);
+		}
+
+		public TargetAddress GetDelegateClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsDelegateOffset);
+		}
+
+		public TargetAddress GetExceptionClass (TargetMemoryAccess memory)
+		{
+			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
+						   MonoMetadataInfo.MonoDefaultsExceptionOffset);
+		}
+
+		public MonoMethodSignature GetMethodSignature (MonoLanguageBackend mono,
+							       TargetMemoryAccess memory,
+							       TargetAddress signature)
+		{
+			int count = memory.ReadInteger (signature + 4) & 0x0000ffff;
+
+			int offset = memory.TargetAddressSize == 8 ? 16 : 12;
+			TargetAddress ret = memory.ReadAddress (signature + offset);
+
+			TargetType ret_type = mono.ReadType (memory, ret);
+			if (count == 0)
+				return new MonoMethodSignature (ret_type, new TargetType [0]);
+
+			offset += memory.TargetAddressSize;
+			TargetReader reader = new TargetReader (
+				memory.ReadMemory (signature + offset, count * memory.TargetAddressSize));
+
+			TargetType[] param_types = new TargetType [count];
+			for (int i = 0; i < count; i++)
+				param_types [i] = mono.ReadType (memory, reader.ReadAddress ());
+
+			return new MonoMethodSignature (ret_type, param_types);
+		}
+
+		protected class MetadataInfo
+		{
+			public readonly int MonoDefaultsSize;
+			public readonly TargetAddress MonoDefaultsAddress;
+			public readonly int TypeSize;
+			public readonly int ArrayTypeSize;
+			public readonly int KlassSize;
+			public readonly int ThreadSize;
+
+			public readonly int ThreadTidOffset;
+			public readonly int ThreadStackPtrOffset;
+			public readonly int ThreadEndStackOffset;
+
+			public readonly int KlassImageOffset;
+			public readonly int KlassInstanceSizeOffset;
+			public readonly int KlassParentOffset;
+			public readonly int KlassTokenOffset;
+			public readonly int KlassFieldOffset;
+			public readonly int KlassFieldCountOffset;
+			public readonly int KlassMethodsOffset;
+			public readonly int KlassMethodCountOffset;
+			public readonly int KlassThisArgOffset;
+			public readonly int KlassByValArgOffset;
+			public readonly int KlassGenericClassOffset;
+			public readonly int KlassGenericContainerOffset;
+			public readonly int KlassVTableOffset;
+			public readonly int FieldInfoSize;
+			public readonly int FieldInfoTypeOffset;
+			public readonly int FieldInfoOffsetOffset;
+
+			public readonly int MonoDefaultsCorlibOffset;
+			public readonly int MonoDefaultsObjectOffset;
+			public readonly int MonoDefaultsByteOffset;
+			public readonly int MonoDefaultsVoidOffset;
+			public readonly int MonoDefaultsBooleanOffset;
+			public readonly int MonoDefaultsSByteOffset;
+			public readonly int MonoDefaultsInt16Offset;
+			public readonly int MonoDefaultsUInt16Offset;
+			public readonly int MonoDefaultsInt32Offset;
+			public readonly int MonoDefaultsUInt32Offset;
+			public readonly int MonoDefaultsIntOffset;
+			public readonly int MonoDefaultsUIntOffset;
+			public readonly int MonoDefaultsInt64Offset;
+			public readonly int MonoDefaultsUInt64Offset;
+			public readonly int MonoDefaultsSingleOffset;
+			public readonly int MonoDefaultsDoubleOffset;
+			public readonly int MonoDefaultsCharOffset;
+			public readonly int MonoDefaultsStringOffset;
+			public readonly int MonoDefaultsEnumOffset;
+			public readonly int MonoDefaultsArrayOffset;
+			public readonly int MonoDefaultsDelegateOffset;
+			public readonly int MonoDefaultsExceptionOffset;
+
+			public readonly int MonoMethodKlassOffset;
+			public readonly int MonoMethodTokenOffset;
+			public readonly int MonoMethodFlagsOffset;
+			public readonly int MonoMethodInflatedOffset;
+
+			public readonly int MonoVTableKlassOffset;
+			public readonly int MonoVTableVTableOffset;
+
+			public MetadataInfo (TargetMemoryAccess memory, TargetAddress address)
+			{
+				int size = memory.ReadInteger (address);
+				TargetBinaryReader reader = memory.ReadMemory (address, size).GetReader ();
+				reader.ReadInt32 ();
+
+				MonoDefaultsSize = reader.ReadInt32 ();
+				MonoDefaultsAddress = new TargetAddress (
+					memory.AddressDomain, reader.ReadAddress ());
+
+				TypeSize = reader.ReadInt32 ();
+				ArrayTypeSize = reader.ReadInt32 ();
+				KlassSize = reader.ReadInt32 ();
+				ThreadSize = reader.ReadInt32 ();
+
+				ThreadTidOffset = reader.ReadInt32 ();
+				ThreadStackPtrOffset = reader.ReadInt32 ();
+				ThreadEndStackOffset = reader.ReadInt32 ();
+
+				KlassImageOffset = reader.ReadInt32 ();
+				KlassInstanceSizeOffset = reader.ReadInt32 ();
+				KlassParentOffset = reader.ReadInt32 ();
+				KlassTokenOffset = reader.ReadInt32 ();
+				KlassFieldOffset = reader.ReadInt32 ();
+				KlassMethodsOffset = reader.ReadInt32 ();
+				KlassMethodCountOffset = reader.ReadInt32 ();
+				KlassThisArgOffset = reader.ReadInt32 ();
+				KlassByValArgOffset = reader.ReadInt32 ();
+				KlassGenericClassOffset = reader.ReadInt32 ();
+				KlassGenericContainerOffset = reader.ReadInt32 ();
+				KlassVTableOffset = reader.ReadInt32 ();
+
+				FieldInfoSize = reader.ReadInt32 ();
+				FieldInfoTypeOffset = reader.ReadInt32 ();
+				FieldInfoOffsetOffset = reader.ReadInt32 ();
+
+				KlassFieldCountOffset = KlassMethodCountOffset - 8;
+
+				MonoDefaultsCorlibOffset = reader.ReadInt32 ();
+				MonoDefaultsObjectOffset = reader.ReadInt32 ();
+				MonoDefaultsByteOffset = reader.ReadInt32 ();
+				MonoDefaultsVoidOffset = reader.ReadInt32 ();
+				MonoDefaultsBooleanOffset = reader.ReadInt32 ();
+				MonoDefaultsSByteOffset = reader.ReadInt32 ();
+				MonoDefaultsInt16Offset = reader.ReadInt32 ();
+				MonoDefaultsUInt16Offset = reader.ReadInt32 ();
+				MonoDefaultsInt32Offset = reader.ReadInt32 ();
+				MonoDefaultsUInt32Offset = reader.ReadInt32 ();
+				MonoDefaultsIntOffset = reader.ReadInt32 ();
+				MonoDefaultsUIntOffset = reader.ReadInt32 ();
+				MonoDefaultsInt64Offset = reader.ReadInt32 ();
+				MonoDefaultsUInt64Offset = reader.ReadInt32 ();
+				MonoDefaultsSingleOffset = reader.ReadInt32 ();
+				MonoDefaultsDoubleOffset = reader.ReadInt32 ();
+				MonoDefaultsCharOffset = reader.ReadInt32 ();
+				MonoDefaultsStringOffset = reader.ReadInt32 ();
+				MonoDefaultsEnumOffset = reader.ReadInt32 ();
+				MonoDefaultsArrayOffset = reader.ReadInt32 ();
+				MonoDefaultsDelegateOffset = reader.ReadInt32 ();
+				MonoDefaultsExceptionOffset = reader.ReadInt32 ();
+
+				MonoMethodKlassOffset = reader.ReadInt32 ();
+				MonoMethodTokenOffset = reader.ReadInt32 ();
+				MonoMethodFlagsOffset = reader.ReadInt32 ();
+				MonoMethodInflatedOffset = reader.ReadInt32 ();
+
+				MonoVTableKlassOffset = reader.ReadInt32 ();
+				MonoVTableVTableOffset = reader.ReadInt32 ();
+			}
+		}
+
+		//
+		// The following API is new in `terrania'.
+		//
+
+		public GenericClassInfo GetGenericClass (TargetMemoryAccess memory,
+							 TargetAddress address)
+		{
+			int addr_size = memory.TargetMemoryInfo.TargetAddressSize;
+
+			TargetReader reader = new TargetReader (memory.ReadMemory (address, 5 * addr_size));
+			TargetAddress container = reader.ReadAddress ();
+			TargetAddress class_inst = reader.ReadAddress ();
+			reader.ReadAddress (); /* method_inst */
+			reader.ReadAddress ();
+			TargetAddress cached_class = reader.ReadAddress ();
+
+			int inst_id = memory.ReadInteger (class_inst);
+			int inst_data = memory.ReadInteger (class_inst + 4);
+
+			TargetAddress inst_argv;
+			if (MonoDebuggerInfo.MajorVersion == 80)
+				inst_argv = memory.ReadAddress (class_inst + 8);
+			else
+				inst_argv = class_inst + 8;
+
+			int type_argc = inst_data & 0x3fffff;
+
+			TargetReader argv_reader = new TargetReader (
+				memory.ReadMemory (inst_argv, type_argc * addr_size));
+
+			TargetAddress[] type_args = new TargetAddress [type_argc];
+			for (int i = 0; i < type_argc; i++)
+				type_args [i] = argv_reader.ReadAddress ();
+
+			TargetAddress cached_class_ptr = address + 4 * addr_size;
+
+			return new GenericClassInfo (container, type_args, cached_class_ptr,
+						     cached_class);
+		}
+
+		public class GenericClassInfo
+		{
+			/* `MonoClass *' of the container class. */
+			public readonly TargetAddress ContainerClass;
+
+			/* `MonoType *' array of the instantiation. */
+			public readonly TargetAddress[] TypeArguments;
+
+			/* `MonoClass *' of this instantiation, if present. */
+			public readonly TargetAddress KlassPtr;
+			public readonly TargetAddress Klass;
+
+			public GenericClassInfo (TargetAddress container, TargetAddress[] type_args,
+						 TargetAddress klass_ptr, TargetAddress klass)
+			{
+				this.ContainerClass = container;
+				this.TypeArguments = type_args;
+				this.KlassPtr = klass_ptr;
+				this.Klass = klass;
+			}
+		}
+
+		public GenericParamInfo GetGenericParameter (TargetMemoryAccess memory,
+							     TargetAddress address)
+		{
+			int addr_size = memory.TargetMemoryInfo.TargetAddressSize;
+
+			TargetReader reader = new TargetReader (
+				memory.ReadMemory (address, 4 * addr_size + 4));
+			TargetAddress container = reader.ReadAddress ();
+			TargetAddress klass = reader.ReadAddress ();
+			TargetAddress name_addr = reader.ReadAddress ();
+			reader.BinaryReader.ReadInt16 (); /* flags */
+			int pos = reader.BinaryReader.ReadInt16 ();
+
+			string name;
+			if (!name_addr.IsNull)
+				name = memory.ReadString (name_addr);
+			else
+				name = String.Format ("!{0}", pos);
+
+			return new GenericParamInfo (container, klass, name, pos);
+		}
+
+		public class GenericParamInfo
+		{
+			public readonly TargetAddress Container;
+			public readonly TargetAddress Klass;
+			public readonly string Name;
+			public readonly int Position;
+
+			public GenericParamInfo (TargetAddress container, TargetAddress klass,
+						 string name, int pos)
+			{
+				this.Container = container;
+				this.Klass = klass;
+				this.Name = name;
+				this.Position = pos;
+			}
+		}
+
+		public AppDomainInfo GetAppDomainInfo (MonoLanguageBackend mono, TargetMemoryAccess memory,
+						       TargetAddress address)
+		{
+			int addr_size = memory.TargetMemoryInfo.TargetAddressSize;
+			TargetReader reader = new TargetReader (memory.ReadMemory (address, 12 * addr_size));
+
+			return new AppDomainInfo (mono, memory, reader);
+		}
+
+		public class AppDomainInfo
+		{
+			public readonly string ApplicationBase;
+			public readonly string ApplicationName;
+			public readonly string CachePath;
+			public readonly string ConfigFile;
+			public readonly string DynamicBase;
+			public readonly string ShadowCopyDirectories;
+			public readonly bool ShadowCopyFiles;
+
+			public string ShadowCopyPath;
+
+			public AppDomainInfo (MonoLanguageBackend mono, TargetMemoryAccess memory, TargetReader reader)
+			{
+				int addr_size = memory.TargetMemoryInfo.TargetAddressSize;
+
+				reader.Offset = 2 * addr_size;
+				ApplicationBase = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
+				ApplicationName = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
+				CachePath = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
+				ConfigFile = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
+				DynamicBase = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
+				reader.Offset += 3 * addr_size;
+				ShadowCopyDirectories = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
+				ShadowCopyFiles = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ()) == "true";
+			}
+
+			public override string ToString ()
+			{
+				return String.Format ("AppDomainInfo ({0}:{1}:{2}:{3}:{4}:{5}:{6})",
+						      ApplicationBase, ApplicationName, CachePath, ConfigFile,
+						      DynamicBase, ShadowCopyDirectories, ShadowCopyFiles);
+			}
+		}
+	}
+}
diff --git a/backend/mono/MonoThreadManager.cs b/backend/mono/MonoThreadManager.cs
new file mode 100644
index 0000000..88138df
--- /dev/null
+++ b/backend/mono/MonoThreadManager.cs
@@ -0,0 +1,639 @@
+using System;
+using System.IO;
+using System.Text;
+using System.Threading;
+using System.Configuration;
+using System.Globalization;
+using System.Reflection;
+using System.Diagnostics;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.Specialized;
+using System.Runtime.InteropServices;
+
+using Mono.Debugger;
+using Mono.Debugger.Languages;
+using Mono.Debugger.Languages.Mono;
+
+
+namespace Mono.Debugger.Backend.Mono
+{
+
+// <summary>
+// MonoThreadManager is a special case handler for thread events when
+// we know we're running a managed app.
+// </summary>
+
+	internal enum NotificationType {
+		InitializeManagedCode	= 1,
+		InitializeCorlib,
+		JitBreakpoint,
+		InitializeThreadManager,
+		AcquireGlobalThreadLock,
+		ReleaseGlobalThreadLock,
+		WrapperMain,
+		MainExited,
+		UnhandledException,
+		ThrowException,
+		HandleException,
+		ThreadCreated,
+		ThreadCleanup,
+		GcThreadCreated,
+		GcThreadExited,
+		ReachedMain,
+		FinalizeManagedCode,
+		LoadModule,
+		UnloadModule,
+		DomainCreate,
+		DomainUnload,
+		ClassInitialized,
+		InterruptionRequest,
+		CreateAppDomain,
+		UnloadAppDomain,
+
+		Trampoline	= 256
+	}
+
+	internal enum ThreadFlags {
+		None = 0,
+		Internal = 1,
+		ThreadPool = 2
+	};
+
+	internal delegate bool ManagedCallbackFunction (SingleSteppingEngine engine);
+
+	internal class MonoThreadManager
+	{
+		ProcessServant process;
+		MonoDebuggerInfo debugger_info;
+
+		protected MonoThreadManager (ProcessServant process, Inferior inferior,
+					     MonoDebuggerInfo debugger_info)
+		{
+			this.process = process;
+			this.debugger_info = debugger_info;
+
+			inferior.WriteInteger (debugger_info.UsingMonoDebugger, 1);
+
+			notification_bpt = new InitializeBreakpoint (this, debugger_info.Initialize);
+			notification_bpt.Insert (inferior);
+		}
+
+		public static MonoThreadManager Initialize (ProcessServant process, Inferior inferior,
+							    TargetAddress info, bool attach)
+		{
+			MonoDebuggerInfo debugger_info = MonoDebuggerInfo.Create (inferior, info);
+			if (debugger_info == null)
+				return null;
+
+			if (attach) {
+				if (!debugger_info.CheckRuntimeVersion (81, 2)) {
+					Report.Error ("The Mono runtime of the target application is too old to support attaching,\n" +
+						      "attaching as a native application.");
+					return null;
+				}
+
+				if ((debugger_info.RuntimeFlags & 1) != 1) {
+					Report.Error ("The Mono runtime of the target application does not support attaching,\n" +
+						      "attaching as a native application.");
+					return null;
+				}
+			}
+
+			return new MonoThreadManager (process, inferior, debugger_info);
+		}
+
+		AddressBreakpoint notification_bpt;
+		IntPtr mono_runtime_info;
+		int debugger_version;
+
+		internal bool HasCodeBuffer {
+			get;
+			private set;
+		}
+
+		[DllImport("monodebuggerserver")]
+		static extern IntPtr mono_debugger_server_initialize_mono_runtime (
+			int address_size, long notification_address,
+			long executable_code_buffer, int executable_code_buffer_size,
+			long breakpoint_info, long breakpoint_info_index,
+			int breakpoint_table_size);
+
+		[DllImport("monodebuggerserver")]
+		static extern void mono_debugger_server_finalize_mono_runtime (IntPtr handle);
+
+		[DllImport("monodebuggerserver")]
+		static extern void mono_debugger_server_initialize_code_buffer (
+			IntPtr runtime, long executable_code_buffer,
+			int executable_code_buffer_size);
+
+		protected void initialize_notifications (Inferior inferior)
+		{
+			TargetAddress executable_code_buffer = inferior.ReadAddress (
+				debugger_info.ExecutableCodeBuffer);
+			HasCodeBuffer = !executable_code_buffer.IsNull;
+
+			mono_runtime_info = mono_debugger_server_initialize_mono_runtime (
+				inferior.TargetAddressSize,
+				debugger_info.NotificationAddress.Address,
+				executable_code_buffer.Address,
+				debugger_info.ExecutableCodeBufferSize,
+				debugger_info.BreakpointInfo.Address,
+				debugger_info.BreakpointInfoIndex.Address,
+				debugger_info.BreakpointArraySize);
+			inferior.SetRuntimeInfo (mono_runtime_info);
+
+			debugger_version = inferior.ReadInteger (debugger_info.DebuggerVersion);
+
+			if (notification_bpt != null) {
+				notification_bpt.Remove (inferior);
+				notification_bpt = null;
+			}
+		}
+
+		internal void InitCodeBuffer (Inferior inferior, TargetAddress code_buffer)
+		{
+			HasCodeBuffer = true;
+			mono_debugger_server_initialize_code_buffer (
+				mono_runtime_info, code_buffer.Address,
+				debugger_info.ExecutableCodeBufferSize);
+		}
+
+		protected class InitializeBreakpoint : AddressBreakpoint
+		{
+			protected readonly MonoThreadManager manager;
+
+			public InitializeBreakpoint (MonoThreadManager manager, TargetAddress address)
+				: base ("initialize", ThreadGroup.System, address)
+			{
+				this.manager = manager;
+			}
+
+			public override bool CheckBreakpointHit (Thread target, TargetAddress address)
+			{
+				return true;
+			}
+
+			internal override bool BreakpointHandler (Inferior inferior,
+								  out bool remain_stopped)
+			{
+				manager.initialize_notifications (inferior);
+				remain_stopped = false;
+				return true;
+			}
+		}
+
+		internal bool InitializeAfterAttach (Inferior inferior)
+		{
+			initialize_notifications (inferior);
+
+			inferior.WriteAddress (debugger_info.ThreadVTablePtr,
+					       debugger_info.ThreadVTable);
+			inferior.WriteAddress (debugger_info.EventHandlerPtr,
+					       debugger_info.EventHandler);
+			inferior.WriteInteger (debugger_info.UsingMonoDebugger, 1);
+
+			csharp_language = inferior.Process.CreateMonoLanguage (debugger_info);
+			csharp_language.InitializeAttach (inferior);
+
+			return true;
+		}
+
+		internal void Detach (Inferior inferior)
+		{
+			inferior.WriteAddress (debugger_info.ThreadVTablePtr, TargetAddress.Null);
+			inferior.WriteAddress (debugger_info.EventHandler, TargetAddress.Null);
+			inferior.WriteInteger (debugger_info.UsingMonoDebugger, 0);
+		}
+
+		internal void AddManagedCallback (Inferior inferior, ManagedCallbackData data)
+		{
+			inferior.WriteInteger (MonoDebuggerInfo.InterruptionRequest, 1);
+			managed_callbacks.Enqueue (data);
+		}
+
+		internal Queue<ManagedCallbackData> ClearManagedCallbacks (Inferior inferior)
+		{
+			inferior.WriteInteger (MonoDebuggerInfo.InterruptionRequest, 0);
+			Queue<ManagedCallbackData> retval = managed_callbacks;
+			managed_callbacks = new Queue<ManagedCallbackData> ();
+			return retval;
+		}
+
+		TargetAddress main_function;
+		TargetAddress main_thread;
+		MonoLanguageBackend csharp_language;
+		Queue<ManagedCallbackData> managed_callbacks = new Queue<ManagedCallbackData> ();
+
+		internal bool CanExecuteCode {
+			get { return mono_runtime_info != IntPtr.Zero; }
+		}
+
+		internal MonoDebuggerInfo MonoDebuggerInfo {
+			get { return debugger_info; }
+		}
+
+		int index;
+		internal void ThreadCreated (SingleSteppingEngine sse)
+		{
+			sse.Inferior.SetRuntimeInfo (mono_runtime_info);
+			if (!MonoDebuggerInfo.CheckRuntimeVersion (81, 3) && !process.IsAttached) {
+				if (++index < 3)
+					sse.Thread.ThreadFlags |= Thread.Flags.Daemon | Thread.Flags.Immutable;
+			} else {
+				sse.Thread.ThreadFlags |= Thread.Flags.Daemon | Thread.Flags.Immutable;
+			}
+		}
+
+		void check_thread_flags (SingleSteppingEngine engine, ThreadFlags flags)
+		{
+			if ((flags & (ThreadFlags.Internal | ThreadFlags.ThreadPool)) != ThreadFlags.Internal) {
+				engine.Thread.ThreadFlags &= ~(Thread.Flags.Daemon | Thread.Flags.Immutable);
+				if (engine != process.MainThread)
+					process.Debugger.Client.OnManagedThreadCreatedEvent (engine.Thread);
+			} else if ((flags & ThreadFlags.ThreadPool) != 0) {
+				engine.Thread.ThreadFlags &= ~Thread.Flags.Immutable;
+			}
+		}
+
+		internal void InitializeThreads (Inferior inferior)
+		{
+			TargetAddress ptr = inferior.ReadAddress (MonoDebuggerInfo.ThreadTable);
+			while (!ptr.IsNull) {
+				int size;
+				if (MonoDebuggerInfo.CheckRuntimeVersion (81, 3))
+					size = 60 + inferior.TargetMemoryInfo.TargetAddressSize;
+				else
+					size = 32 + inferior.TargetMemoryInfo.TargetAddressSize;
+				TargetReader reader = new TargetReader (inferior.ReadMemory (ptr, size));
+
+				long tid = reader.ReadLongInteger ();
+				TargetAddress lmf_addr = reader.ReadAddress ();
+				TargetAddress end_stack = reader.ReadAddress ();
+
+				TargetAddress extended_notifications_addr = ptr + 24;
+
+				if (inferior.TargetMemoryInfo.TargetAddressSize == 4)
+					tid &= 0x00000000ffffffffL;
+
+				reader.Offset += 8;
+				ptr = reader.ReadAddress ();
+
+				ThreadFlags flags = ThreadFlags.None;
+				if (MonoDebuggerInfo.CheckRuntimeVersion (81, 3)) {
+					reader.Offset = 56 + inferior.TargetAddressSize;
+					flags = (ThreadFlags) reader.ReadInteger ();
+				}
+
+				bool found = false;
+				foreach (SingleSteppingEngine engine in process.Engines) {
+					if (engine.TID != tid)
+						continue;
+
+					engine.SetManagedThreadData (lmf_addr, extended_notifications_addr);
+					engine.OnManagedThreadCreated (end_stack);
+					check_thread_flags (engine, flags);
+					found = true;
+					break;
+				}
+
+				if (!found)
+					Report.Error ("Cannot find thread {0:x} in {1}",
+						      tid, process.ProcessStart.CommandLine);
+			}
+		}
+
+		internal bool HandleChildEvent (SingleSteppingEngine engine, Inferior inferior,
+						ref Inferior.ChildEvent cevent, out bool resume_target)
+		{
+			if (cevent.Type == Inferior.ChildEventType.CHILD_NOTIFICATION) {
+				NotificationType type = (NotificationType) cevent.Argument;
+
+				Report.Debug (DebugFlags.EventLoop,
+					      "{0} received notification {1}: {2}",
+					      engine, type, cevent);
+
+				switch (type) {
+				case NotificationType.AcquireGlobalThreadLock:
+					Report.Debug (DebugFlags.Threads,
+						      "{0} received notification {1}", engine, type);
+					engine.ProcessServant.AcquireGlobalThreadLock (engine);
+					break;
+
+				case NotificationType.ReleaseGlobalThreadLock:
+					Report.Debug (DebugFlags.Threads,
+						      "{0} received notification {1}", engine, type);
+					engine.ProcessServant.ReleaseGlobalThreadLock (engine);
+					break;
+
+				case NotificationType.ThreadCreated: {
+					TargetAddress data = new TargetAddress (
+						inferior.AddressDomain, cevent.Data2);
+
+					TargetAddress lmf = inferior.ReadAddress (data + 8);
+					engine.SetManagedThreadData (lmf, data + 24);
+
+					if (MonoDebuggerInfo.CheckRuntimeVersion (81, 3)) {
+						int flags_offset = 56 + inferior.TargetAddressSize;
+						ThreadFlags flags = (ThreadFlags) inferior.ReadInteger (data + flags_offset);
+						check_thread_flags (engine, flags);
+					}
+
+					Report.Debug (DebugFlags.Threads,
+						      "{0} managed thread created: {1:x} {2} {3} - {4}",
+						      engine, cevent.Data1, data, lmf, engine.LMFAddress);
+					break;
+				}
+
+				case NotificationType.ThreadCleanup: {
+					TargetAddress data = new TargetAddress (
+						inferior.AddressDomain, cevent.Data1);
+
+					Report.Debug (DebugFlags.Threads,
+						      "{0} managed thread cleanup: {1:x} {2}",
+						      engine, cevent.Data2, data);
+					break;
+				}
+
+				case NotificationType.GcThreadCreated: {
+					TargetAddress data = new TargetAddress (
+						inferior.AddressDomain, cevent.Data1);
+					long tid = cevent.Data2;
+
+					Report.Debug (DebugFlags.Threads,
+						      "{0} created gc thread: {1:x} {2}",
+						      engine, tid, data);
+
+					engine = engine.ProcessServant.GetEngineByTID (inferior, tid);
+					if (engine == null)
+						throw new InternalError ();
+
+					engine.OnManagedThreadCreated (data);
+					break;
+				}
+
+				case NotificationType.GcThreadExited:
+					Report.Debug (DebugFlags.Threads, "{0} gc thread exited", engine);
+					engine.OnManagedThreadExited ();
+					try {
+						inferior.Continue ();
+					} catch {
+						// Ignore errors; for some reason, the thread may have died
+						// already by the time get this notification.
+					}
+					resume_target = false;
+					return true;
+
+				case NotificationType.InitializeThreadManager:
+					csharp_language = inferior.Process.CreateMonoLanguage (
+						debugger_info);
+					if (engine.ProcessServant.IsAttached)
+						csharp_language.InitializeAttach (inferior);
+					else
+						csharp_language.Initialize (inferior);
+
+					break;
+
+				case NotificationType.ReachedMain: {
+					Inferior.StackFrame iframe = inferior.GetCurrentFrame (false);
+					engine.SetMainReturnAddress (iframe.StackPointer);
+					engine.ProcessServant.OnProcessReachedMainEvent ();
+					resume_target = !engine.InitializeBreakpoints ();
+					return true;
+				}
+
+				case NotificationType.WrapperMain:
+					break;
+				case NotificationType.MainExited:
+					engine.SetMainReturnAddress (TargetAddress.Null);
+					break;
+
+				case NotificationType.UnhandledException:
+					cevent = new Inferior.ChildEvent (
+						Inferior.ChildEventType.UNHANDLED_EXCEPTION,
+						0, cevent.Data1, cevent.Data2);
+					resume_target = false;
+					return false;
+
+				case NotificationType.HandleException:
+					cevent = new Inferior.ChildEvent (
+						Inferior.ChildEventType.HANDLE_EXCEPTION,
+						0, cevent.Data1, cevent.Data2);
+					resume_target = false;
+					return false;
+
+				case NotificationType.ThrowException:
+					cevent = new Inferior.ChildEvent (
+						Inferior.ChildEventType.THROW_EXCEPTION,
+						0, cevent.Data1, cevent.Data2);
+					resume_target = false;
+					return false;
+
+				case NotificationType.FinalizeManagedCode:
+					mono_debugger_server_finalize_mono_runtime (mono_runtime_info);
+					mono_runtime_info = IntPtr.Zero;
+					csharp_language = null;
+					break;
+
+				case NotificationType.Trampoline:
+					resume_target = false;
+					return false;
+
+				case NotificationType.ClassInitialized:
+					break;
+
+				case NotificationType.InterruptionRequest:
+					inferior.WriteInteger (MonoDebuggerInfo.InterruptionRequest, 0);
+					var callbacks = managed_callbacks;
+					managed_callbacks = new Queue<ManagedCallbackData> ();
+					resume_target = !engine.OnManagedCallback (callbacks);
+					return true;
+
+				default: {
+					TargetAddress data = new TargetAddress (
+						inferior.AddressDomain, cevent.Data1);
+
+					resume_target = csharp_language.Notification (
+						engine, inferior, type, data, cevent.Data2);
+					return true;
+				}
+				}
+
+				resume_target = true;
+				return true;
+			}
+
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
+			    (cevent.Argument == inferior.MonoThreadAbortSignal)) {
+				resume_target = true;
+				return true;
+			}
+
+			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) && (cevent.Argument != 0) && !
+			    engine.Process.Session.Config.StopOnManagedSignals) {
+				if (inferior.IsManagedSignal ((int) cevent.Argument)) {
+					resume_target = true;
+					return true;
+				}
+			}
+
+			resume_target = false;
+			return false;
+		}
+	}
+
+	// <summary>
+	//   This class is the managed representation of the MONO_DEBUGGER__debugger_info struct.
+	//   as defined in mono/mini/debug-debugger.h
+	// </summary>
+	internal class MonoDebuggerInfo
+	{
+		// These constants must match up with those in mono/mono/metadata/mono-debug.h
+		public const int  MinDynamicVersion = 80;
+		public const int  MaxDynamicVersion = 81;
+		public const long DynamicMagic      = 0x7aff65af4253d427;
+
+		public readonly int MajorVersion;
+		public readonly int MinorVersion;
+
+		public readonly int RuntimeFlags;
+
+		public readonly int MonoTrampolineNum;
+		public readonly TargetAddress MonoTrampolineCode;
+		public readonly TargetAddress NotificationAddress;
+		public readonly TargetAddress SymbolTable;
+		public readonly int SymbolTableSize;
+		public readonly TargetAddress MonoMetadataInfo;
+		public readonly TargetAddress DebuggerVersion;
+		public readonly TargetAddress CompileMethod;
+		public readonly TargetAddress GetVirtualMethod;
+		public readonly TargetAddress GetBoxedObjectMethod;
+		public readonly TargetAddress RuntimeInvoke;
+		public readonly TargetAddress CreateString;
+		public readonly TargetAddress ClassGetStaticFieldData;
+		public readonly TargetAddress LookupClass;
+		public readonly TargetAddress RunFinally;
+		public readonly TargetAddress InsertMethodBreakpoint;
+		public readonly TargetAddress InsertSourceBreakpoint;
+		public readonly TargetAddress RemoveBreakpoint;
+		public readonly TargetAddress RegisterClassInitCallback;
+		public readonly TargetAddress RemoveClassInitCallback;
+		public readonly TargetAddress Initialize;
+		public readonly TargetAddress ThreadTable;
+		public readonly TargetAddress ExecutableCodeBuffer;
+		public readonly TargetAddress BreakpointInfo;
+		public readonly TargetAddress BreakpointInfoIndex;
+		public readonly int ExecutableCodeBufferSize;
+		public readonly int BreakpointArraySize;
+		public readonly TargetAddress GetMethodSignature;
+		public readonly TargetAddress InitCodeBuffer;
+
+		public readonly TargetAddress ThreadVTablePtr;
+		public readonly TargetAddress ThreadVTable;
+		public readonly TargetAddress EventHandlerPtr;
+		public readonly TargetAddress EventHandler;
+
+		public readonly TargetAddress UsingMonoDebugger;
+		public readonly TargetAddress InterruptionRequest;
+
+		public static MonoDebuggerInfo Create (TargetMemoryAccess memory, TargetAddress info)
+		{
+			TargetBinaryReader header = memory.ReadMemory (info, 24).GetReader ();
+			long magic = header.ReadInt64 ();
+			if (magic != DynamicMagic) {
+				Report.Error ("`MONO_DEBUGGER__debugger_info' at {0} has unknown magic {1:x}.", info, magic);
+				return null;
+			}
+
+			int version = header.ReadInt32 ();
+			if (version < MinDynamicVersion) {
+				Report.Error ("`MONO_DEBUGGER__debugger_info' has version {0}, " +
+					      "but expected at least {1}.", version,
+					      MonoDebuggerInfo.MinDynamicVersion);
+				return null;
+			}
+			if (version > MaxDynamicVersion) {
+				Report.Error ("`MONO_DEBUGGER__debugger_info' has version {0}, " +
+					      "but expected at most {1}.", version,
+					      MonoDebuggerInfo.MaxDynamicVersion);
+				return null;
+			}
+
+			header.ReadInt32 (); // minor version
+			header.ReadInt32 ();
+
+			int size = header.ReadInt32 ();
+
+			TargetReader reader = new TargetReader (memory.ReadMemory (info, size));
+			return new MonoDebuggerInfo (memory, reader);
+		}
+
+		public bool CheckRuntimeVersion (int major, int minor)
+		{
+			if (MajorVersion < major)
+				return false;
+			if (MajorVersion > major)
+				return true;
+			return MinorVersion >= minor;
+		}
+
+		protected MonoDebuggerInfo (TargetMemoryAccess memory, TargetReader reader)
+		{
+			reader.Offset = 8;
+			MajorVersion              = reader.ReadInteger ();
+			MinorVersion              = reader.ReadInteger ();
+
+			RuntimeFlags              = reader.ReadInteger ();
+
+			reader.Offset = 24;
+
+			SymbolTableSize           = reader.ReadInteger ();
+			MonoTrampolineNum         = reader.ReadInteger ();
+			MonoTrampolineCode        = reader.ReadAddress ();
+			NotificationAddress       = reader.ReadAddress ();
+			SymbolTable               = reader.ReadAddress ();
+			MonoMetadataInfo          = reader.ReadAddress ();
+			DebuggerVersion           = reader.ReadAddress ();
+
+			CompileMethod             = reader.ReadAddress ();
+			GetVirtualMethod          = reader.ReadAddress ();
+			GetBoxedObjectMethod      = reader.ReadAddress ();
+			RuntimeInvoke             = reader.ReadAddress ();
+			ClassGetStaticFieldData   = reader.ReadAddress ();
+			RunFinally                = reader.ReadAddress ();
+			Initialize                = reader.ReadAddress ();
+
+			CreateString              = reader.ReadAddress ();
+			LookupClass               = reader.ReadAddress ();
+
+			InsertMethodBreakpoint    = reader.ReadAddress ();
+			InsertSourceBreakpoint    = reader.ReadAddress ();
+			RemoveBreakpoint          = reader.ReadAddress ();
+
+			RegisterClassInitCallback = reader.ReadAddress ();
+			RemoveClassInitCallback   = reader.ReadAddress ();
+
+			ThreadTable               = reader.ReadAddress ();
+
+			ExecutableCodeBuffer      = reader.ReadAddress ();
+			BreakpointInfo            = reader.ReadAddress ();
+			BreakpointInfoIndex       = reader.ReadAddress ();
+
+			ExecutableCodeBufferSize  = reader.ReadInteger ();
+			BreakpointArraySize       = reader.ReadInteger ();
+
+			GetMethodSignature        = reader.ReadAddress ();
+			InitCodeBuffer            = reader.ReadAddress ();
+
+			ThreadVTablePtr           = reader.ReadAddress ();
+			ThreadVTable              = reader.ReadAddress ();
+			EventHandlerPtr           = reader.ReadAddress ();
+			EventHandler              = reader.ReadAddress ();
+
+			UsingMonoDebugger         = reader.ReadAddress ();
+			InterruptionRequest       = reader.ReadAddress ();
+
+			Report.Debug (DebugFlags.JitSymtab, this);
+		}
+	}
+}
diff --git a/build/Makefile.am b/build/Makefile.am
index 5af084a..ba6090f 100644
--- a/build/Makefile.am
+++ b/build/Makefile.am
@@ -65,6 +65,7 @@ DEBUGGER_SRCLIST = \
 	$(top_srcdir)/interface/*.cs			\
 	$(top_srcdir)/backend/arch/*.cs			\
 	$(top_srcdir)/backend/os/*.cs			\
+	$(top_srcdir)/backend/mono/*.cs			\
 	$(top_srcdir)/backend/*.cs			\
 	$(top_srcdir)/languages/*.cs			\
 	$(top_srcdir)/languages/mono/*.cs		\
diff --git a/configure.in b/configure.in
index 2d87a81..8a6899f 100644
--- a/configure.in
+++ b/configure.in
@@ -359,6 +359,7 @@ build/Mono.Debugger.dll.config
 backend/Makefile
 backend/server/Makefile
 backend/arch/Makefile
+backend/mono/Makefile
 backend/os/Makefile
 backend/os/bfd/libiberty/Makefile
 backend/os/bfd/opcodes/Makefile
diff --git a/languages/mono/MonoClassInfo.cs b/languages/mono/MonoClassInfo.cs
index 16f747c..f2407d7 100644
--- a/languages/mono/MonoClassInfo.cs
+++ b/languages/mono/MonoClassInfo.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using Mono.Debugger.Backend;
+using Mono.Debugger.Backend.Mono;
 
 namespace Mono.Debugger.Languages.Mono
 {
diff --git a/languages/mono/MonoLanguageBackend.cs b/languages/mono/MonoLanguageBackend.cs
index 679261b..e855226 100644
--- a/languages/mono/MonoLanguageBackend.cs
+++ b/languages/mono/MonoLanguageBackend.cs
@@ -9,6 +9,7 @@ using System.Threading;
 using C = Mono.CompilerServices.SymbolWriter;
 
 using Mono.Debugger.Backend;
+using Mono.Debugger.Backend.Mono;
 
 namespace Mono.Debugger.Languages.Mono
 {

--------------1.5.6--



From 4d4e17955280ca902fecfb5db1692d5686bd9ea9 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Mon, 7 Sep 2009 12:07:23 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/MonoThreadManager.cs                       |  639 ------------------
 {languages => backend}/mono/MonoLanguageBackend.cs |    0 
 languages/mono/MonoRuntime.cs                      |  699 --------------------
 3 files changed, 0 insertions(+), 1338 deletions(-)
 delete mode 100644 backend/MonoThreadManager.cs
 rename {languages => backend}/mono/MonoLanguageBackend.cs (100%)
 delete mode 100644 languages/mono/MonoRuntime.cs
--------------1.5.6
Content-Type: text/x-patch; name="4d4e17955280ca902fecfb5db1692d5686bd9ea9.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="4d4e17955280ca902fecfb5db1692d5686bd9ea9.diff"

diff --git a/backend/MonoThreadManager.cs b/backend/MonoThreadManager.cs
deleted file mode 100644
index 998147c..0000000
--- a/backend/MonoThreadManager.cs
+++ /dev/null
@@ -1,639 +0,0 @@
-using System;
-using System.IO;
-using System.Text;
-using System.Threading;
-using System.Configuration;
-using System.Globalization;
-using System.Reflection;
-using System.Diagnostics;
-using System.Collections;
-using System.Collections.Generic;
-using System.Collections.Specialized;
-using System.Runtime.InteropServices;
-
-using Mono.Debugger;
-using Mono.Debugger.Languages;
-using Mono.Debugger.Languages.Mono;
-
-
-namespace Mono.Debugger.Backend
-{
-
-// <summary>
-// MonoThreadManager is a special case handler for thread events when
-// we know we're running a managed app.
-// </summary>
-
-	internal enum NotificationType {
-		InitializeManagedCode	= 1,
-		InitializeCorlib,
-		JitBreakpoint,
-		InitializeThreadManager,
-		AcquireGlobalThreadLock,
-		ReleaseGlobalThreadLock,
-		WrapperMain,
-		MainExited,
-		UnhandledException,
-		ThrowException,
-		HandleException,
-		ThreadCreated,
-		ThreadCleanup,
-		GcThreadCreated,
-		GcThreadExited,
-		ReachedMain,
-		FinalizeManagedCode,
-		LoadModule,
-		UnloadModule,
-		DomainCreate,
-		DomainUnload,
-		ClassInitialized,
-		InterruptionRequest,
-		CreateAppDomain,
-		UnloadAppDomain,
-
-		Trampoline	= 256
-	}
-
-	internal enum ThreadFlags {
-		None = 0,
-		Internal = 1,
-		ThreadPool = 2
-	};
-
-	internal delegate bool ManagedCallbackFunction (SingleSteppingEngine engine);
-
-	internal class MonoThreadManager
-	{
-		ProcessServant process;
-		MonoDebuggerInfo debugger_info;
-
-		protected MonoThreadManager (ProcessServant process, Inferior inferior,
-					     MonoDebuggerInfo debugger_info)
-		{
-			this.process = process;
-			this.debugger_info = debugger_info;
-
-			inferior.WriteInteger (debugger_info.UsingMonoDebugger, 1);
-
-			notification_bpt = new InitializeBreakpoint (this, debugger_info.Initialize);
-			notification_bpt.Insert (inferior);
-		}
-
-		public static MonoThreadManager Initialize (ProcessServant process, Inferior inferior,
-							    TargetAddress info, bool attach)
-		{
-			MonoDebuggerInfo debugger_info = MonoDebuggerInfo.Create (inferior, info);
-			if (debugger_info == null)
-				return null;
-
-			if (attach) {
-				if (!debugger_info.CheckRuntimeVersion (81, 2)) {
-					Report.Error ("The Mono runtime of the target application is too old to support attaching,\n" +
-						      "attaching as a native application.");
-					return null;
-				}
-
-				if ((debugger_info.RuntimeFlags & 1) != 1) {
-					Report.Error ("The Mono runtime of the target application does not support attaching,\n" +
-						      "attaching as a native application.");
-					return null;
-				}
-			}
-
-			return new MonoThreadManager (process, inferior, debugger_info);
-		}
-
-		AddressBreakpoint notification_bpt;
-		IntPtr mono_runtime_info;
-		int debugger_version;
-
-		internal bool HasCodeBuffer {
-			get;
-			private set;
-		}
-
-		[DllImport("monodebuggerserver")]
-		static extern IntPtr mono_debugger_server_initialize_mono_runtime (
-			int address_size, long notification_address,
-			long executable_code_buffer, int executable_code_buffer_size,
-			long breakpoint_info, long breakpoint_info_index,
-			int breakpoint_table_size);
-
-		[DllImport("monodebuggerserver")]
-		static extern void mono_debugger_server_finalize_mono_runtime (IntPtr handle);
-
-		[DllImport("monodebuggerserver")]
-		static extern void mono_debugger_server_initialize_code_buffer (
-			IntPtr runtime, long executable_code_buffer,
-			int executable_code_buffer_size);
-
-		protected void initialize_notifications (Inferior inferior)
-		{
-			TargetAddress executable_code_buffer = inferior.ReadAddress (
-				debugger_info.ExecutableCodeBuffer);
-			HasCodeBuffer = !executable_code_buffer.IsNull;
-
-			mono_runtime_info = mono_debugger_server_initialize_mono_runtime (
-				inferior.TargetAddressSize,
-				debugger_info.NotificationAddress.Address,
-				executable_code_buffer.Address,
-				debugger_info.ExecutableCodeBufferSize,
-				debugger_info.BreakpointInfo.Address,
-				debugger_info.BreakpointInfoIndex.Address,
-				debugger_info.BreakpointArraySize);
-			inferior.SetRuntimeInfo (mono_runtime_info);
-
-			debugger_version = inferior.ReadInteger (debugger_info.DebuggerVersion);
-
-			if (notification_bpt != null) {
-				notification_bpt.Remove (inferior);
-				notification_bpt = null;
-			}
-		}
-
-		internal void InitCodeBuffer (Inferior inferior, TargetAddress code_buffer)
-		{
-			HasCodeBuffer = true;
-			mono_debugger_server_initialize_code_buffer (
-				mono_runtime_info, code_buffer.Address,
-				debugger_info.ExecutableCodeBufferSize);
-		}
-
-		protected class InitializeBreakpoint : AddressBreakpoint
-		{
-			protected readonly MonoThreadManager manager;
-
-			public InitializeBreakpoint (MonoThreadManager manager, TargetAddress address)
-				: base ("initialize", ThreadGroup.System, address)
-			{
-				this.manager = manager;
-			}
-
-			public override bool CheckBreakpointHit (Thread target, TargetAddress address)
-			{
-				return true;
-			}
-
-			internal override bool BreakpointHandler (Inferior inferior,
-								  out bool remain_stopped)
-			{
-				manager.initialize_notifications (inferior);
-				remain_stopped = false;
-				return true;
-			}
-		}
-
-		internal bool InitializeAfterAttach (Inferior inferior)
-		{
-			initialize_notifications (inferior);
-
-			inferior.WriteAddress (debugger_info.ThreadVTablePtr,
-					       debugger_info.ThreadVTable);
-			inferior.WriteAddress (debugger_info.EventHandlerPtr,
-					       debugger_info.EventHandler);
-			inferior.WriteInteger (debugger_info.UsingMonoDebugger, 1);
-
-			csharp_language = inferior.Process.CreateMonoLanguage (debugger_info);
-			csharp_language.InitializeAttach (inferior);
-
-			return true;
-		}
-
-		internal void Detach (Inferior inferior)
-		{
-			inferior.WriteAddress (debugger_info.ThreadVTablePtr, TargetAddress.Null);
-			inferior.WriteAddress (debugger_info.EventHandler, TargetAddress.Null);
-			inferior.WriteInteger (debugger_info.UsingMonoDebugger, 0);
-		}
-
-		internal void AddManagedCallback (Inferior inferior, ManagedCallbackData data)
-		{
-			inferior.WriteInteger (MonoDebuggerInfo.InterruptionRequest, 1);
-			managed_callbacks.Enqueue (data);
-		}
-
-		internal Queue<ManagedCallbackData> ClearManagedCallbacks (Inferior inferior)
-		{
-			inferior.WriteInteger (MonoDebuggerInfo.InterruptionRequest, 0);
-			Queue<ManagedCallbackData> retval = managed_callbacks;
-			managed_callbacks = new Queue<ManagedCallbackData> ();
-			return retval;
-		}
-
-		TargetAddress main_function;
-		TargetAddress main_thread;
-		MonoLanguageBackend csharp_language;
-		Queue<ManagedCallbackData> managed_callbacks = new Queue<ManagedCallbackData> ();
-
-		internal bool CanExecuteCode {
-			get { return mono_runtime_info != IntPtr.Zero; }
-		}
-
-		internal MonoDebuggerInfo MonoDebuggerInfo {
-			get { return debugger_info; }
-		}
-
-		int index;
-		internal void ThreadCreated (SingleSteppingEngine sse)
-		{
-			sse.Inferior.SetRuntimeInfo (mono_runtime_info);
-			if (!MonoDebuggerInfo.CheckRuntimeVersion (81, 3) && !process.IsAttached) {
-				if (++index < 3)
-					sse.Thread.ThreadFlags |= Thread.Flags.Daemon | Thread.Flags.Immutable;
-			} else {
-				sse.Thread.ThreadFlags |= Thread.Flags.Daemon | Thread.Flags.Immutable;
-			}
-		}
-
-		void check_thread_flags (SingleSteppingEngine engine, ThreadFlags flags)
-		{
-			if ((flags & (ThreadFlags.Internal | ThreadFlags.ThreadPool)) != ThreadFlags.Internal) {
-				engine.Thread.ThreadFlags &= ~(Thread.Flags.Daemon | Thread.Flags.Immutable);
-				if (engine != process.MainThread)
-					process.Debugger.Client.OnManagedThreadCreatedEvent (engine.Thread);
-			} else if ((flags & ThreadFlags.ThreadPool) != 0) {
-				engine.Thread.ThreadFlags &= ~Thread.Flags.Immutable;
-			}
-		}
-
-		internal void InitializeThreads (Inferior inferior)
-		{
-			TargetAddress ptr = inferior.ReadAddress (MonoDebuggerInfo.ThreadTable);
-			while (!ptr.IsNull) {
-				int size;
-				if (MonoDebuggerInfo.CheckRuntimeVersion (81, 3))
-					size = 60 + inferior.TargetMemoryInfo.TargetAddressSize;
-				else
-					size = 32 + inferior.TargetMemoryInfo.TargetAddressSize;
-				TargetReader reader = new TargetReader (inferior.ReadMemory (ptr, size));
-
-				long tid = reader.ReadLongInteger ();
-				TargetAddress lmf_addr = reader.ReadAddress ();
-				TargetAddress end_stack = reader.ReadAddress ();
-
-				TargetAddress extended_notifications_addr = ptr + 24;
-
-				if (inferior.TargetMemoryInfo.TargetAddressSize == 4)
-					tid &= 0x00000000ffffffffL;
-
-				reader.Offset += 8;
-				ptr = reader.ReadAddress ();
-
-				ThreadFlags flags = ThreadFlags.None;
-				if (MonoDebuggerInfo.CheckRuntimeVersion (81, 3)) {
-					reader.Offset = 56 + inferior.TargetAddressSize;
-					flags = (ThreadFlags) reader.ReadInteger ();
-				}
-
-				bool found = false;
-				foreach (SingleSteppingEngine engine in process.Engines) {
-					if (engine.TID != tid)
-						continue;
-
-					engine.SetManagedThreadData (lmf_addr, extended_notifications_addr);
-					engine.OnManagedThreadCreated (end_stack);
-					check_thread_flags (engine, flags);
-					found = true;
-					break;
-				}
-
-				if (!found)
-					Report.Error ("Cannot find thread {0:x} in {1}",
-						      tid, process.ProcessStart.CommandLine);
-			}
-		}
-
-		internal bool HandleChildEvent (SingleSteppingEngine engine, Inferior inferior,
-						ref Inferior.ChildEvent cevent, out bool resume_target)
-		{
-			if (cevent.Type == Inferior.ChildEventType.CHILD_NOTIFICATION) {
-				NotificationType type = (NotificationType) cevent.Argument;
-
-				Report.Debug (DebugFlags.EventLoop,
-					      "{0} received notification {1}: {2}",
-					      engine, type, cevent);
-
-				switch (type) {
-				case NotificationType.AcquireGlobalThreadLock:
-					Report.Debug (DebugFlags.Threads,
-						      "{0} received notification {1}", engine, type);
-					engine.ProcessServant.AcquireGlobalThreadLock (engine);
-					break;
-
-				case NotificationType.ReleaseGlobalThreadLock:
-					Report.Debug (DebugFlags.Threads,
-						      "{0} received notification {1}", engine, type);
-					engine.ProcessServant.ReleaseGlobalThreadLock (engine);
-					break;
-
-				case NotificationType.ThreadCreated: {
-					TargetAddress data = new TargetAddress (
-						inferior.AddressDomain, cevent.Data2);
-
-					TargetAddress lmf = inferior.ReadAddress (data + 8);
-					engine.SetManagedThreadData (lmf, data + 24);
-
-					if (MonoDebuggerInfo.CheckRuntimeVersion (81, 3)) {
-						int flags_offset = 56 + inferior.TargetAddressSize;
-						ThreadFlags flags = (ThreadFlags) inferior.ReadInteger (data + flags_offset);
-						check_thread_flags (engine, flags);
-					}
-
-					Report.Debug (DebugFlags.Threads,
-						      "{0} managed thread created: {1:x} {2} {3} - {4}",
-						      engine, cevent.Data1, data, lmf, engine.LMFAddress);
-					break;
-				}
-
-				case NotificationType.ThreadCleanup: {
-					TargetAddress data = new TargetAddress (
-						inferior.AddressDomain, cevent.Data1);
-
-					Report.Debug (DebugFlags.Threads,
-						      "{0} managed thread cleanup: {1:x} {2}",
-						      engine, cevent.Data2, data);
-					break;
-				}
-
-				case NotificationType.GcThreadCreated: {
-					TargetAddress data = new TargetAddress (
-						inferior.AddressDomain, cevent.Data1);
-					long tid = cevent.Data2;
-
-					Report.Debug (DebugFlags.Threads,
-						      "{0} created gc thread: {1:x} {2}",
-						      engine, tid, data);
-
-					engine = engine.ProcessServant.GetEngineByTID (inferior, tid);
-					if (engine == null)
-						throw new InternalError ();
-
-					engine.OnManagedThreadCreated (data);
-					break;
-				}
-
-				case NotificationType.GcThreadExited:
-					Report.Debug (DebugFlags.Threads, "{0} gc thread exited", engine);
-					engine.OnManagedThreadExited ();
-					try {
-						inferior.Continue ();
-					} catch {
-						// Ignore errors; for some reason, the thread may have died
-						// already by the time get this notification.
-					}
-					resume_target = false;
-					return true;
-
-				case NotificationType.InitializeThreadManager:
-					csharp_language = inferior.Process.CreateMonoLanguage (
-						debugger_info);
-					if (engine.ProcessServant.IsAttached)
-						csharp_language.InitializeAttach (inferior);
-					else
-						csharp_language.Initialize (inferior);
-
-					break;
-
-				case NotificationType.ReachedMain: {
-					Inferior.StackFrame iframe = inferior.GetCurrentFrame (false);
-					engine.SetMainReturnAddress (iframe.StackPointer);
-					engine.ProcessServant.OnProcessReachedMainEvent ();
-					resume_target = !engine.InitializeBreakpoints ();
-					return true;
-				}
-
-				case NotificationType.WrapperMain:
-					break;
-				case NotificationType.MainExited:
-					engine.SetMainReturnAddress (TargetAddress.Null);
-					break;
-
-				case NotificationType.UnhandledException:
-					cevent = new Inferior.ChildEvent (
-						Inferior.ChildEventType.UNHANDLED_EXCEPTION,
-						0, cevent.Data1, cevent.Data2);
-					resume_target = false;
-					return false;
-
-				case NotificationType.HandleException:
-					cevent = new Inferior.ChildEvent (
-						Inferior.ChildEventType.HANDLE_EXCEPTION,
-						0, cevent.Data1, cevent.Data2);
-					resume_target = false;
-					return false;
-
-				case NotificationType.ThrowException:
-					cevent = new Inferior.ChildEvent (
-						Inferior.ChildEventType.THROW_EXCEPTION,
-						0, cevent.Data1, cevent.Data2);
-					resume_target = false;
-					return false;
-
-				case NotificationType.FinalizeManagedCode:
-					mono_debugger_server_finalize_mono_runtime (mono_runtime_info);
-					mono_runtime_info = IntPtr.Zero;
-					csharp_language = null;
-					break;
-
-				case NotificationType.Trampoline:
-					resume_target = false;
-					return false;
-
-				case NotificationType.ClassInitialized:
-					break;
-
-				case NotificationType.InterruptionRequest:
-					inferior.WriteInteger (MonoDebuggerInfo.InterruptionRequest, 0);
-					var callbacks = managed_callbacks;
-					managed_callbacks = new Queue<ManagedCallbackData> ();
-					resume_target = !engine.OnManagedCallback (callbacks);
-					return true;
-
-				default: {
-					TargetAddress data = new TargetAddress (
-						inferior.AddressDomain, cevent.Data1);
-
-					resume_target = csharp_language.Notification (
-						engine, inferior, type, data, cevent.Data2);
-					return true;
-				}
-				}
-
-				resume_target = true;
-				return true;
-			}
-
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
-			    (cevent.Argument == inferior.MonoThreadAbortSignal)) {
-				resume_target = true;
-				return true;
-			}
-
-			if ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) && (cevent.Argument != 0) && !
-			    engine.Process.Session.Config.StopOnManagedSignals) {
-				if (inferior.IsManagedSignal ((int) cevent.Argument)) {
-					resume_target = true;
-					return true;
-				}
-			}
-
-			resume_target = false;
-			return false;
-		}
-	}
-
-	// <summary>
-	//   This class is the managed representation of the MONO_DEBUGGER__debugger_info struct.
-	//   as defined in mono/mini/debug-debugger.h
-	// </summary>
-	internal class MonoDebuggerInfo
-	{
-		// These constants must match up with those in mono/mono/metadata/mono-debug.h
-		public const int  MinDynamicVersion = 80;
-		public const int  MaxDynamicVersion = 81;
-		public const long DynamicMagic      = 0x7aff65af4253d427;
-
-		public readonly int MajorVersion;
-		public readonly int MinorVersion;
-
-		public readonly int RuntimeFlags;
-
-		public readonly int MonoTrampolineNum;
-		public readonly TargetAddress MonoTrampolineCode;
-		public readonly TargetAddress NotificationAddress;
-		public readonly TargetAddress SymbolTable;
-		public readonly int SymbolTableSize;
-		public readonly TargetAddress MonoMetadataInfo;
-		public readonly TargetAddress DebuggerVersion;
-		public readonly TargetAddress CompileMethod;
-		public readonly TargetAddress GetVirtualMethod;
-		public readonly TargetAddress GetBoxedObjectMethod;
-		public readonly TargetAddress RuntimeInvoke;
-		public readonly TargetAddress CreateString;
-		public readonly TargetAddress ClassGetStaticFieldData;
-		public readonly TargetAddress LookupClass;
-		public readonly TargetAddress RunFinally;
-		public readonly TargetAddress InsertMethodBreakpoint;
-		public readonly TargetAddress InsertSourceBreakpoint;
-		public readonly TargetAddress RemoveBreakpoint;
-		public readonly TargetAddress RegisterClassInitCallback;
-		public readonly TargetAddress RemoveClassInitCallback;
-		public readonly TargetAddress Initialize;
-		public readonly TargetAddress ThreadTable;
-		public readonly TargetAddress ExecutableCodeBuffer;
-		public readonly TargetAddress BreakpointInfo;
-		public readonly TargetAddress BreakpointInfoIndex;
-		public readonly int ExecutableCodeBufferSize;
-		public readonly int BreakpointArraySize;
-		public readonly TargetAddress GetMethodSignature;
-		public readonly TargetAddress InitCodeBuffer;
-
-		public readonly TargetAddress ThreadVTablePtr;
-		public readonly TargetAddress ThreadVTable;
-		public readonly TargetAddress EventHandlerPtr;
-		public readonly TargetAddress EventHandler;
-
-		public readonly TargetAddress UsingMonoDebugger;
-		public readonly TargetAddress InterruptionRequest;
-
-		public static MonoDebuggerInfo Create (TargetMemoryAccess memory, TargetAddress info)
-		{
-			TargetBinaryReader header = memory.ReadMemory (info, 24).GetReader ();
-			long magic = header.ReadInt64 ();
-			if (magic != DynamicMagic) {
-				Report.Error ("`MONO_DEBUGGER__debugger_info' at {0} has unknown magic {1:x}.", info, magic);
-				return null;
-			}
-
-			int version = header.ReadInt32 ();
-			if (version < MinDynamicVersion) {
-				Report.Error ("`MONO_DEBUGGER__debugger_info' has version {0}, " +
-					      "but expected at least {1}.", version,
-					      MonoDebuggerInfo.MinDynamicVersion);
-				return null;
-			}
-			if (version > MaxDynamicVersion) {
-				Report.Error ("`MONO_DEBUGGER__debugger_info' has version {0}, " +
-					      "but expected at most {1}.", version,
-					      MonoDebuggerInfo.MaxDynamicVersion);
-				return null;
-			}
-
-			header.ReadInt32 (); // minor version
-			header.ReadInt32 ();
-
-			int size = header.ReadInt32 ();
-
-			TargetReader reader = new TargetReader (memory.ReadMemory (info, size));
-			return new MonoDebuggerInfo (memory, reader);
-		}
-
-		public bool CheckRuntimeVersion (int major, int minor)
-		{
-			if (MajorVersion < major)
-				return false;
-			if (MajorVersion > major)
-				return true;
-			return MinorVersion >= minor;
-		}
-
-		protected MonoDebuggerInfo (TargetMemoryAccess memory, TargetReader reader)
-		{
-			reader.Offset = 8;
-			MajorVersion              = reader.ReadInteger ();
-			MinorVersion              = reader.ReadInteger ();
-
-			RuntimeFlags              = reader.ReadInteger ();
-
-			reader.Offset = 24;
-
-			SymbolTableSize           = reader.ReadInteger ();
-			MonoTrampolineNum         = reader.ReadInteger ();
-			MonoTrampolineCode        = reader.ReadAddress ();
-			NotificationAddress       = reader.ReadAddress ();
-			SymbolTable               = reader.ReadAddress ();
-			MonoMetadataInfo          = reader.ReadAddress ();
-			DebuggerVersion           = reader.ReadAddress ();
-
-			CompileMethod             = reader.ReadAddress ();
-			GetVirtualMethod          = reader.ReadAddress ();
-			GetBoxedObjectMethod      = reader.ReadAddress ();
-			RuntimeInvoke             = reader.ReadAddress ();
-			ClassGetStaticFieldData   = reader.ReadAddress ();
-			RunFinally                = reader.ReadAddress ();
-			Initialize                = reader.ReadAddress ();
-
-			CreateString              = reader.ReadAddress ();
-			LookupClass               = reader.ReadAddress ();
-
-			InsertMethodBreakpoint    = reader.ReadAddress ();
-			InsertSourceBreakpoint    = reader.ReadAddress ();
-			RemoveBreakpoint          = reader.ReadAddress ();
-
-			RegisterClassInitCallback = reader.ReadAddress ();
-			RemoveClassInitCallback   = reader.ReadAddress ();
-
-			ThreadTable               = reader.ReadAddress ();
-
-			ExecutableCodeBuffer      = reader.ReadAddress ();
-			BreakpointInfo            = reader.ReadAddress ();
-			BreakpointInfoIndex       = reader.ReadAddress ();
-
-			ExecutableCodeBufferSize  = reader.ReadInteger ();
-			BreakpointArraySize       = reader.ReadInteger ();
-
-			GetMethodSignature        = reader.ReadAddress ();
-			InitCodeBuffer            = reader.ReadAddress ();
-
-			ThreadVTablePtr           = reader.ReadAddress ();
-			ThreadVTable              = reader.ReadAddress ();
-			EventHandlerPtr           = reader.ReadAddress ();
-			EventHandler              = reader.ReadAddress ();
-
-			UsingMonoDebugger         = reader.ReadAddress ();
-			InterruptionRequest       = reader.ReadAddress ();
-
-			Report.Debug (DebugFlags.JitSymtab, this);
-		}
-	}
-}
diff --git a/languages/mono/MonoLanguageBackend.cs b/backend/mono/MonoLanguageBackend.cs
similarity index 100%
rename from languages/mono/MonoLanguageBackend.cs
rename to backend/mono/MonoLanguageBackend.cs
diff --git a/languages/mono/MonoRuntime.cs b/languages/mono/MonoRuntime.cs
deleted file mode 100644
index cc8a0f4..0000000
--- a/languages/mono/MonoRuntime.cs
+++ /dev/null
@@ -1,699 +0,0 @@
-using System;
-
-using Mono.Debugger.Backend;
-
-namespace Mono.Debugger.Languages.Mono
-{
-	internal enum MonoTypeEnum
-	{
-		MONO_TYPE_END        = 0x00,       /* End of List */
-		MONO_TYPE_VOID       = 0x01,
-		MONO_TYPE_BOOLEAN    = 0x02,
-		MONO_TYPE_CHAR       = 0x03,
-		MONO_TYPE_I1         = 0x04,
-		MONO_TYPE_U1         = 0x05,
-		MONO_TYPE_I2         = 0x06,
-		MONO_TYPE_U2         = 0x07,
-		MONO_TYPE_I4         = 0x08,
-		MONO_TYPE_U4         = 0x09,
-		MONO_TYPE_I8         = 0x0a,
-		MONO_TYPE_U8         = 0x0b,
-		MONO_TYPE_R4         = 0x0c,
-		MONO_TYPE_R8         = 0x0d,
-		MONO_TYPE_STRING     = 0x0e,
-		MONO_TYPE_PTR        = 0x0f,       /* arg: <type> token */
-		MONO_TYPE_BYREF      = 0x10,       /* arg: <type> token */
-		MONO_TYPE_VALUETYPE  = 0x11,       /* arg: <type> token */
-		MONO_TYPE_CLASS      = 0x12,       /* arg: <type> token */
-		MONO_TYPE_VAR	     = 0x13,	   /* number */
-		MONO_TYPE_ARRAY      = 0x14,       /* type, rank, boundsCount, bound1, loCount, lo1 */
-		MONO_TYPE_GENERICINST= 0x15,	   /* <type> <type-arg-count> <type-1> \x{2026} <type-n> */
-		MONO_TYPE_TYPEDBYREF = 0x16,
-		MONO_TYPE_I          = 0x18,
-		MONO_TYPE_U          = 0x19,
-		MONO_TYPE_FNPTR      = 0x1b,	      /* arg: full method signature */
-		MONO_TYPE_OBJECT     = 0x1c,
-		MONO_TYPE_SZARRAY    = 0x1d,       /* 0-based one-dim-array */
-		MONO_TYPE_MVAR	     = 0x1e,       /* number */
-		MONO_TYPE_CMOD_REQD  = 0x1f,       /* arg: typedef or typeref token */
-		MONO_TYPE_CMOD_OPT   = 0x20,       /* optional arg: typedef or typref token */
-		MONO_TYPE_INTERNAL   = 0x21,       /* CLR internal type */
-
-		MONO_TYPE_MODIFIER   = 0x40,       /* Or with the following types */
-		MONO_TYPE_SENTINEL   = 0x41,       /* Sentinel for varargs method signature */
-		MONO_TYPE_PINNED     = 0x45,       /* Local var that points to pinned object */
-
-		MONO_TYPE_ENUM       = 0x55        /* an enumeration */
-	}
-
-	internal class MonoRuntime : DebuggerMarshalByRefObject
-	{
-		protected readonly MonoDebuggerInfo MonoDebuggerInfo;
-		protected readonly MetadataInfo MonoMetadataInfo;
-
-		protected MonoRuntime (MonoDebuggerInfo info, MetadataInfo metadata)
-		{
-			this.MonoDebuggerInfo = info;
-			this.MonoMetadataInfo = metadata;
-		}
-
-		public static MonoRuntime Create (TargetMemoryAccess memory, MonoDebuggerInfo info)
-		{
-			MetadataInfo metadata = new MetadataInfo (memory, info.MonoMetadataInfo);
-			return new MonoRuntime (info, metadata);
-		}
-
-		//
-		// MonoClass
-		//
-
-		public TargetAddress MonoClassGetMonoImage (TargetMemoryAccess memory,
-							    TargetAddress klass)
-		{
-			return memory.ReadAddress (klass + MonoMetadataInfo.KlassImageOffset);
-		}
-
-		public int MonoClassGetToken (TargetMemoryAccess memory,
-					      TargetAddress klass)
-		{
-			return memory.ReadInteger (klass + MonoMetadataInfo.KlassTokenOffset);
-		}
-
-		public int MonoClassGetInstanceSize (TargetMemoryAccess memory,
-						     TargetAddress klass)
-		{
-			int flags = memory.ReadInteger (klass + 4 * memory.TargetAddressSize);
-
-			bool size_inited = (flags & 4) != 0;
-			bool valuetype = (flags & 8) != 0;
-
-			if (!size_inited)
-				throw new TargetException (TargetError.ClassNotInitialized);
-
-			int size = memory.ReadInteger (klass + 4 + 3 * memory.TargetAddressSize);
-			if (valuetype)
-				size -= 2 * memory.TargetAddressSize;
-
-			return size;
-		}
-
-		public TargetAddress MonoClassGetParent (TargetMemoryAccess memory,
-							 TargetAddress klass)
-		{
-			return memory.ReadAddress (klass + MonoMetadataInfo.KlassParentOffset);
-		}
-
-		public TargetAddress MonoClassGetGenericClass (TargetMemoryAccess memory,
-							       TargetAddress klass)
-		{
-			return memory.ReadAddress (klass + MonoMetadataInfo.KlassGenericClassOffset);
-		}
-
-		public TargetAddress MonoClassGetGenericContainer (TargetMemoryAccess memory,
-								   TargetAddress klass)
-		{
-			return memory.ReadAddress (klass + MonoMetadataInfo.KlassGenericContainerOffset);
-		}
-
-		public TargetAddress MonoClassGetByValType (TargetMemoryAccess memory,
-							    TargetAddress klass)
-		{
-			return klass + MonoMetadataInfo.KlassByValArgOffset;
-		}
-
-		public bool MonoClassHasFields (TargetMemoryAccess memory, TargetAddress klass)
-		{
-			TargetAddress fields = memory.ReadAddress (
-				klass + MonoMetadataInfo.KlassFieldOffset);
-			return !fields.IsNull;
-		}
-
-		public int MonoClassGetFieldCount (TargetMemoryAccess memory, TargetAddress klass)
-		{
-			return memory.ReadInteger (klass + MonoMetadataInfo.KlassFieldCountOffset);
-		}
-
-		public TargetAddress MonoClassGetFieldType (TargetMemoryAccess memory, TargetAddress klass,
-							    int index)
-		{
-			int offset = index * MonoMetadataInfo.FieldInfoSize +
-				MonoMetadataInfo.FieldInfoTypeOffset;
-
-			TargetAddress fields = memory.ReadAddress (
-				klass + MonoMetadataInfo.KlassFieldOffset);
-			if (fields.IsNull)
-				throw new TargetException (TargetError.ClassNotInitialized);
-
-			return memory.ReadAddress (fields + offset);
-		}
-
-		public int MonoClassGetFieldOffset (TargetMemoryAccess memory, TargetAddress klass,
-						    int index)
-		{
-			int offset = index * MonoMetadataInfo.FieldInfoSize +
-				MonoMetadataInfo.FieldInfoOffsetOffset;
-
-			TargetAddress fields = memory.ReadAddress (
-				klass + MonoMetadataInfo.KlassFieldOffset);
-			if (fields.IsNull)
-				throw new TargetException (TargetError.ClassNotInitialized);
-
-			return memory.ReadInteger (fields + offset);
-		}
-
-		public bool MonoClassHasMethods (TargetMemoryAccess memory, TargetAddress klass)
-		{
-			TargetAddress methods = memory.ReadAddress (
-				klass + MonoMetadataInfo.KlassMethodsOffset);
-			return !methods.IsNull;
-		}
-
-		public int MonoClassGetMethodCount (TargetMemoryAccess memory, TargetAddress klass)
-		{
-			return memory.ReadInteger (klass + MonoMetadataInfo.KlassMethodCountOffset);
-		}
-
-		public TargetAddress MonoClassGetMethod (TargetMemoryAccess memory, TargetAddress klass,
-							 int index)
-		{
-			TargetAddress methods = memory.ReadAddress (
-				klass + MonoMetadataInfo.KlassMethodsOffset);
-
-			if (methods.IsNull)
-				throw new TargetException (TargetError.ClassNotInitialized);
-
-			methods += index * memory.TargetAddressSize;
-			return memory.ReadAddress (methods);
-		}
-
-		//
-		// MonoMethod
-		//
-
-		public int MonoMethodGetToken (TargetMemoryAccess memory, TargetAddress method)
-		{
-			return memory.ReadInteger (method + MonoMetadataInfo.MonoMethodTokenOffset);
-		}
-
-		public TargetAddress MonoMethodGetClass (TargetMemoryAccess memory, TargetAddress method)
-		{
-			return memory.ReadAddress (method + MonoMetadataInfo.MonoMethodKlassOffset);
-		}
-
-		//
-		// MonoType
-		//
-
-		public MonoTypeEnum MonoTypeGetType (TargetMemoryAccess memory, TargetAddress type)
-		{
-			uint flags = (uint) memory.ReadInteger (
-				type + memory.TargetMemoryInfo.TargetAddressSize);
-
-			return (MonoTypeEnum) ((flags & 0x00ff0000) >> 16);
-		}
-
-		public bool MonoTypeGetIsByRef (TargetMemoryAccess memory, TargetAddress type)
-		{
-			uint flags = (uint) memory.ReadInteger (
-				type + memory.TargetMemoryInfo.TargetAddressSize);
-			return (int) ((flags & 0x40000000) >> 30) != 0;
-		}
-
-		public TargetAddress MonoTypeGetData (TargetMemoryAccess memory, TargetAddress type)
-		{
-			return memory.ReadAddress (type);
-		}
-
-		public TargetAddress MonoArrayTypeGetClass (TargetMemoryAccess memory,
-							    TargetAddress atype)
-		{
-			return memory.ReadAddress (atype);
-		}
-
-		public int MonoArrayTypeGetRank (TargetMemoryAccess memory,
-						 TargetAddress atype)
-		{
-			return memory.ReadByte (atype + memory.TargetAddressSize);
-		}
-
-		public int MonoArrayTypeGetNumSizes (TargetMemoryAccess memory,
-						     TargetAddress atype)
-		{
-			return memory.ReadByte (atype + memory.TargetAddressSize + 1);
-		}
-
-		public int MonoArrayTypeGetNumLoBounds (TargetMemoryAccess memory,
-							TargetAddress atype)
-		{
-			return memory.ReadByte (atype + memory.TargetAddressSize + 2);
-		}
-
-		internal void MonoArrayTypeGetBounds (TargetMemoryAccess memory,
-						      TargetAddress data)
-		{
-			//
-			// FIXME: Only check whether the low bounds are all zero
-			//
-			int num_sizes = memory.ReadByte (data + memory.TargetAddressSize + 1);
-			if (num_sizes != 0)
-				throw new InternalError ();
-
-			int num_lobounds = memory.ReadByte (data + memory.TargetAddressSize + 2);
-			if (num_lobounds == 0)
-				return;
-
-			TargetAddress array = memory.ReadAddress (data + 3 * memory.TargetAddressSize);
-			TargetBinaryReader bounds = memory.ReadMemory (array, num_lobounds * 4).GetReader ();
-			for (int i = 0; i < num_lobounds; i++) {
-				int bound = bounds.ReadInt32 ();
-				if (bound != 0)
-					throw new InternalError ();
-			}
-		}
-
-		//
-		// Fundamental types
-		//
-
-		public TargetAddress GetBooleanClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsBooleanOffset);
-		}
-
-		public TargetAddress GetCharClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsCharOffset);
-		}
-
-		public TargetAddress GetSByteClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsSByteOffset);
-		}
-
-		public TargetAddress GetByteClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsByteOffset);
-		}
-
-		public TargetAddress GetInt16Class (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsInt16Offset);
-		}
-
-		public TargetAddress GetUInt16Class (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsUInt16Offset);
-		}
-
-		public TargetAddress GetInt32Class (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsInt32Offset);
-		}
-
-		public TargetAddress GetUInt32Class (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsUInt32Offset);
-		}
-
-		public TargetAddress GetInt64Class (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsInt64Offset);
-		}
-
-		public TargetAddress GetUInt64Class (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsUInt64Offset);
-		}
-
-		public TargetAddress GetSingleClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsSingleOffset);
-		}
-
-		public TargetAddress GetDoubleClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsDoubleOffset);
-		}
-
-		public TargetAddress GetIntPtrClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsIntOffset);
-		}
-
-		public TargetAddress GetUIntPtrClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsUIntOffset);
-		}
-
-		public TargetAddress GetVoidClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsVoidOffset);
-		}
-
-		public TargetAddress GetStringClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsStringOffset);
-		}
-
-		public TargetAddress GetObjectClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsObjectOffset);
-		}
-
-		public TargetAddress GetArrayClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsArrayOffset);
-		}
-
-		public TargetAddress GetDelegateClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsDelegateOffset);
-		}
-
-		public TargetAddress GetExceptionClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsExceptionOffset);
-		}
-
-		public MonoMethodSignature GetMethodSignature (MonoLanguageBackend mono,
-							       TargetMemoryAccess memory,
-							       TargetAddress signature)
-		{
-			int count = memory.ReadInteger (signature + 4) & 0x0000ffff;
-
-			int offset = memory.TargetAddressSize == 8 ? 16 : 12;
-			TargetAddress ret = memory.ReadAddress (signature + offset);
-
-			TargetType ret_type = mono.ReadType (memory, ret);
-			if (count == 0)
-				return new MonoMethodSignature (ret_type, new TargetType [0]);
-
-			offset += memory.TargetAddressSize;
-			TargetReader reader = new TargetReader (
-				memory.ReadMemory (signature + offset, count * memory.TargetAddressSize));
-
-			TargetType[] param_types = new TargetType [count];
-			for (int i = 0; i < count; i++)
-				param_types [i] = mono.ReadType (memory, reader.ReadAddress ());
-
-			return new MonoMethodSignature (ret_type, param_types);
-		}
-
-		protected class MetadataInfo
-		{
-			public readonly int MonoDefaultsSize;
-			public readonly TargetAddress MonoDefaultsAddress;
-			public readonly int TypeSize;
-			public readonly int ArrayTypeSize;
-			public readonly int KlassSize;
-			public readonly int ThreadSize;
-
-			public readonly int ThreadTidOffset;
-			public readonly int ThreadStackPtrOffset;
-			public readonly int ThreadEndStackOffset;
-
-			public readonly int KlassImageOffset;
-			public readonly int KlassInstanceSizeOffset;
-			public readonly int KlassParentOffset;
-			public readonly int KlassTokenOffset;
-			public readonly int KlassFieldOffset;
-			public readonly int KlassFieldCountOffset;
-			public readonly int KlassMethodsOffset;
-			public readonly int KlassMethodCountOffset;
-			public readonly int KlassThisArgOffset;
-			public readonly int KlassByValArgOffset;
-			public readonly int KlassGenericClassOffset;
-			public readonly int KlassGenericContainerOffset;
-			public readonly int KlassVTableOffset;
-			public readonly int FieldInfoSize;
-			public readonly int FieldInfoTypeOffset;
-			public readonly int FieldInfoOffsetOffset;
-
-			public readonly int MonoDefaultsCorlibOffset;
-			public readonly int MonoDefaultsObjectOffset;
-			public readonly int MonoDefaultsByteOffset;
-			public readonly int MonoDefaultsVoidOffset;
-			public readonly int MonoDefaultsBooleanOffset;
-			public readonly int MonoDefaultsSByteOffset;
-			public readonly int MonoDefaultsInt16Offset;
-			public readonly int MonoDefaultsUInt16Offset;
-			public readonly int MonoDefaultsInt32Offset;
-			public readonly int MonoDefaultsUInt32Offset;
-			public readonly int MonoDefaultsIntOffset;
-			public readonly int MonoDefaultsUIntOffset;
-			public readonly int MonoDefaultsInt64Offset;
-			public readonly int MonoDefaultsUInt64Offset;
-			public readonly int MonoDefaultsSingleOffset;
-			public readonly int MonoDefaultsDoubleOffset;
-			public readonly int MonoDefaultsCharOffset;
-			public readonly int MonoDefaultsStringOffset;
-			public readonly int MonoDefaultsEnumOffset;
-			public readonly int MonoDefaultsArrayOffset;
-			public readonly int MonoDefaultsDelegateOffset;
-			public readonly int MonoDefaultsExceptionOffset;
-
-			public readonly int MonoMethodKlassOffset;
-			public readonly int MonoMethodTokenOffset;
-			public readonly int MonoMethodFlagsOffset;
-			public readonly int MonoMethodInflatedOffset;
-
-			public readonly int MonoVTableKlassOffset;
-			public readonly int MonoVTableVTableOffset;
-
-			public MetadataInfo (TargetMemoryAccess memory, TargetAddress address)
-			{
-				int size = memory.ReadInteger (address);
-				TargetBinaryReader reader = memory.ReadMemory (address, size).GetReader ();
-				reader.ReadInt32 ();
-
-				MonoDefaultsSize = reader.ReadInt32 ();
-				MonoDefaultsAddress = new TargetAddress (
-					memory.AddressDomain, reader.ReadAddress ());
-
-				TypeSize = reader.ReadInt32 ();
-				ArrayTypeSize = reader.ReadInt32 ();
-				KlassSize = reader.ReadInt32 ();
-				ThreadSize = reader.ReadInt32 ();
-
-				ThreadTidOffset = reader.ReadInt32 ();
-				ThreadStackPtrOffset = reader.ReadInt32 ();
-				ThreadEndStackOffset = reader.ReadInt32 ();
-
-				KlassImageOffset = reader.ReadInt32 ();
-				KlassInstanceSizeOffset = reader.ReadInt32 ();
-				KlassParentOffset = reader.ReadInt32 ();
-				KlassTokenOffset = reader.ReadInt32 ();
-				KlassFieldOffset = reader.ReadInt32 ();
-				KlassMethodsOffset = reader.ReadInt32 ();
-				KlassMethodCountOffset = reader.ReadInt32 ();
-				KlassThisArgOffset = reader.ReadInt32 ();
-				KlassByValArgOffset = reader.ReadInt32 ();
-				KlassGenericClassOffset = reader.ReadInt32 ();
-				KlassGenericContainerOffset = reader.ReadInt32 ();
-				KlassVTableOffset = reader.ReadInt32 ();
-
-				FieldInfoSize = reader.ReadInt32 ();
-				FieldInfoTypeOffset = reader.ReadInt32 ();
-				FieldInfoOffsetOffset = reader.ReadInt32 ();
-
-				KlassFieldCountOffset = KlassMethodCountOffset - 8;
-
-				MonoDefaultsCorlibOffset = reader.ReadInt32 ();
-				MonoDefaultsObjectOffset = reader.ReadInt32 ();
-				MonoDefaultsByteOffset = reader.ReadInt32 ();
-				MonoDefaultsVoidOffset = reader.ReadInt32 ();
-				MonoDefaultsBooleanOffset = reader.ReadInt32 ();
-				MonoDefaultsSByteOffset = reader.ReadInt32 ();
-				MonoDefaultsInt16Offset = reader.ReadInt32 ();
-				MonoDefaultsUInt16Offset = reader.ReadInt32 ();
-				MonoDefaultsInt32Offset = reader.ReadInt32 ();
-				MonoDefaultsUInt32Offset = reader.ReadInt32 ();
-				MonoDefaultsIntOffset = reader.ReadInt32 ();
-				MonoDefaultsUIntOffset = reader.ReadInt32 ();
-				MonoDefaultsInt64Offset = reader.ReadInt32 ();
-				MonoDefaultsUInt64Offset = reader.ReadInt32 ();
-				MonoDefaultsSingleOffset = reader.ReadInt32 ();
-				MonoDefaultsDoubleOffset = reader.ReadInt32 ();
-				MonoDefaultsCharOffset = reader.ReadInt32 ();
-				MonoDefaultsStringOffset = reader.ReadInt32 ();
-				MonoDefaultsEnumOffset = reader.ReadInt32 ();
-				MonoDefaultsArrayOffset = reader.ReadInt32 ();
-				MonoDefaultsDelegateOffset = reader.ReadInt32 ();
-				MonoDefaultsExceptionOffset = reader.ReadInt32 ();
-
-				MonoMethodKlassOffset = reader.ReadInt32 ();
-				MonoMethodTokenOffset = reader.ReadInt32 ();
-				MonoMethodFlagsOffset = reader.ReadInt32 ();
-				MonoMethodInflatedOffset = reader.ReadInt32 ();
-
-				MonoVTableKlassOffset = reader.ReadInt32 ();
-				MonoVTableVTableOffset = reader.ReadInt32 ();
-			}
-		}
-
-		//
-		// The following API is new in `terrania'.
-		//
-
-		public GenericClassInfo GetGenericClass (TargetMemoryAccess memory,
-							 TargetAddress address)
-		{
-			int addr_size = memory.TargetMemoryInfo.TargetAddressSize;
-
-			TargetReader reader = new TargetReader (memory.ReadMemory (address, 5 * addr_size));
-			TargetAddress container = reader.ReadAddress ();
-			TargetAddress class_inst = reader.ReadAddress ();
-			reader.ReadAddress (); /* method_inst */
-			reader.ReadAddress ();
-			TargetAddress cached_class = reader.ReadAddress ();
-
-			int inst_id = memory.ReadInteger (class_inst);
-			int inst_data = memory.ReadInteger (class_inst + 4);
-
-			TargetAddress inst_argv;
-			if (MonoDebuggerInfo.MajorVersion == 80)
-				inst_argv = memory.ReadAddress (class_inst + 8);
-			else
-				inst_argv = class_inst + 8;
-
-			int type_argc = inst_data & 0x3fffff;
-
-			TargetReader argv_reader = new TargetReader (
-				memory.ReadMemory (inst_argv, type_argc * addr_size));
-
-			TargetAddress[] type_args = new TargetAddress [type_argc];
-			for (int i = 0; i < type_argc; i++)
-				type_args [i] = argv_reader.ReadAddress ();
-
-			TargetAddress cached_class_ptr = address + 4 * addr_size;
-
-			return new GenericClassInfo (container, type_args, cached_class_ptr,
-						     cached_class);
-		}
-
-		public class GenericClassInfo
-		{
-			/* `MonoClass *' of the container class. */
-			public readonly TargetAddress ContainerClass;
-
-			/* `MonoType *' array of the instantiation. */
-			public readonly TargetAddress[] TypeArguments;
-
-			/* `MonoClass *' of this instantiation, if present. */
-			public readonly TargetAddress KlassPtr;
-			public readonly TargetAddress Klass;
-
-			public GenericClassInfo (TargetAddress container, TargetAddress[] type_args,
-						 TargetAddress klass_ptr, TargetAddress klass)
-			{
-				this.ContainerClass = container;
-				this.TypeArguments = type_args;
-				this.KlassPtr = klass_ptr;
-				this.Klass = klass;
-			}
-		}
-
-		public GenericParamInfo GetGenericParameter (TargetMemoryAccess memory,
-							     TargetAddress address)
-		{
-			int addr_size = memory.TargetMemoryInfo.TargetAddressSize;
-
-			TargetReader reader = new TargetReader (
-				memory.ReadMemory (address, 4 * addr_size + 4));
-			TargetAddress container = reader.ReadAddress ();
-			TargetAddress klass = reader.ReadAddress ();
-			TargetAddress name_addr = reader.ReadAddress ();
-			reader.BinaryReader.ReadInt16 (); /* flags */
-			int pos = reader.BinaryReader.ReadInt16 ();
-
-			string name;
-			if (!name_addr.IsNull)
-				name = memory.ReadString (name_addr);
-			else
-				name = String.Format ("!{0}", pos);
-
-			return new GenericParamInfo (container, klass, name, pos);
-		}
-
-		public class GenericParamInfo
-		{
-			public readonly TargetAddress Container;
-			public readonly TargetAddress Klass;
-			public readonly string Name;
-			public readonly int Position;
-
-			public GenericParamInfo (TargetAddress container, TargetAddress klass,
-						 string name, int pos)
-			{
-				this.Container = container;
-				this.Klass = klass;
-				this.Name = name;
-				this.Position = pos;
-			}
-		}
-
-		public AppDomainInfo GetAppDomainInfo (MonoLanguageBackend mono, TargetMemoryAccess memory,
-						       TargetAddress address)
-		{
-			int addr_size = memory.TargetMemoryInfo.TargetAddressSize;
-			TargetReader reader = new TargetReader (memory.ReadMemory (address, 12 * addr_size));
-
-			return new AppDomainInfo (mono, memory, reader);
-		}
-
-		public class AppDomainInfo
-		{
-			public readonly string ApplicationBase;
-			public readonly string ApplicationName;
-			public readonly string CachePath;
-			public readonly string ConfigFile;
-			public readonly string DynamicBase;
-			public readonly string ShadowCopyDirectories;
-			public readonly bool ShadowCopyFiles;
-
-			public string ShadowCopyPath;
-
-			public AppDomainInfo (MonoLanguageBackend mono, TargetMemoryAccess memory, TargetReader reader)
-			{
-				int addr_size = memory.TargetMemoryInfo.TargetAddressSize;
-
-				reader.Offset = 2 * addr_size;
-				ApplicationBase = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
-				ApplicationName = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
-				CachePath = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
-				ConfigFile = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
-				DynamicBase = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
-				reader.Offset += 3 * addr_size;
-				ShadowCopyDirectories = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
-				ShadowCopyFiles = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ()) == "true";
-			}
-
-			public override string ToString ()
-			{
-				return String.Format ("AppDomainInfo ({0}:{1}:{2}:{3}:{4}:{5}:{6})",
-						      ApplicationBase, ApplicationName, CachePath, ConfigFile,
-						      DynamicBase, ShadowCopyDirectories, ShadowCopyFiles);
-			}
-		}
-	}
-}

--------------1.5.6--



From b0f85359e1717c8abce0061a67d35f4b1cf6e805 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 8 Sep 2009 17:05:20 +0200
Subject: [PATCH] library ...
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/mono/Makefile.am            |   13 +++++++++++++
 backend/mono/MonoLanguageBackend.cs |   24 ++++++++++++++++++++++++
 backend/mono/MonoThreadManager.cs   |    4 ++++
 frontend/Command.cs                 |    9 +++++++++
 languages/Language.cs               |    2 ++
 languages/native/NativeLanguage.cs  |    5 +++++
 6 files changed, 57 insertions(+), 0 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="b0f85359e1717c8abce0061a67d35f4b1cf6e805.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="b0f85359e1717c8abce0061a67d35f4b1cf6e805.diff"

diff --git a/backend/mono/Makefile.am b/backend/mono/Makefile.am
index bd74aad..7f89d42 100644
--- a/backend/mono/Makefile.am
+++ b/backend/mono/Makefile.am
@@ -1 +1,14 @@
 EXTRA_DIST = $(srcdir)/*.cs
+
+INCLUDES = @SERVER_DEPENDENCIES_CFLAGS@ @server_cflags@
+
+lib_LTLIBRARIES = libmonodebuggerlibrary.la
+
+libmonodebuggerlibrary_la_SOURCES = \
+	library.c		\
+	library.h
+
+libmonodebuggerlibrary_la_LDFLAGS = \
+	 -no-undefined -export-dynamic -shared
+
+CLEANFILES = lib*.a lib*.dll
diff --git a/backend/mono/MonoLanguageBackend.cs b/backend/mono/MonoLanguageBackend.cs
index e855226..115ad06 100644
--- a/backend/mono/MonoLanguageBackend.cs
+++ b/backend/mono/MonoLanguageBackend.cs
@@ -1381,6 +1381,30 @@ namespace Mono.Debugger.Languages.Mono
 			}
 		}
 
+		public override void Test (Thread thread)
+		{
+			Console.WriteLine ("TEST !!!");
+
+			var path = Path.Combine (AssemblyInfo.libdir, "libmonodebuggerlibrary.so");
+
+			TargetAddress test = thread.CallMethod (info.Test, TargetAddress.Null, 0, 0, path);
+
+			Console.WriteLine ("TEST: {0}", test);
+
+			TargetBinaryReader reader = thread.ReadMemory (test, 24).GetReader ();
+			long magic = reader.ReadAddress ();
+			int major = reader.ReadInt32 ();
+			int minor = reader.ReadInt32 ();
+
+			TargetAddress func = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
+
+			Console.WriteLine ("TEST: {0:x} {1} {2} - {3}", magic, major, minor, func);
+
+			TargetAddress ret = thread.CallMethod (func, 0x12345678, 0xdeadbeaf);
+
+			Console.WriteLine ("TEST #2: {0}", ret);
+		}
+
 		public bool Notification (SingleSteppingEngine engine, Inferior inferior,
 					  NotificationType type, TargetAddress data, long arg)
 		{
diff --git a/backend/mono/MonoThreadManager.cs b/backend/mono/MonoThreadManager.cs
index 88138df..c9e95bf 100644
--- a/backend/mono/MonoThreadManager.cs
+++ b/backend/mono/MonoThreadManager.cs
@@ -536,6 +536,8 @@ namespace Mono.Debugger.Backend.Mono
 		public readonly TargetAddress UsingMonoDebugger;
 		public readonly TargetAddress InterruptionRequest;
 
+		public readonly TargetAddress Test;
+
 		public static MonoDebuggerInfo Create (TargetMemoryAccess memory, TargetAddress info)
 		{
 			TargetBinaryReader header = memory.ReadMemory (info, 24).GetReader ();
@@ -633,6 +635,8 @@ namespace Mono.Debugger.Backend.Mono
 			UsingMonoDebugger         = reader.ReadAddress ();
 			InterruptionRequest       = reader.ReadAddress ();
 
+			Test                      = reader.ReadAddress ();
+
 			Report.Debug (DebugFlags.JitSymtab, this);
 		}
 	}
diff --git a/frontend/Command.cs b/frontend/Command.cs
index b8ce3c7..819f564 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -92,6 +92,7 @@ namespace Mono.Debugger.Frontend
 			RegisterCommand ("module", typeof (ModuleCommand));
 			RegisterCommand ("config", typeof (ConfigCommand));
 			RegisterCommand ("less", typeof (LessCommand));
+			RegisterCommand ("test", typeof (TestCommand));
 		}
 	}
 
@@ -3935,4 +3936,12 @@ namespace Mono.Debugger.Frontend
 		public string Documentation { get { return ""; } }
 	}
 
+	public class TestCommand : FrameCommand
+	{
+		protected override object DoExecute (ScriptingContext context)
+		{
+			context.CurrentFrame.Language.Test (context.CurrentThread);
+			return null;
+		}
+	}
 }
diff --git a/languages/Language.cs b/languages/Language.cs
index d24ac7d..889719f 100644
--- a/languages/Language.cs
+++ b/languages/Language.cs
@@ -77,5 +77,7 @@ namespace Mono.Debugger.Languages
 		public abstract TargetPointerType CreatePointerType (TargetType type);
 
 		public abstract bool IsExceptionType (TargetClassType type);
+
+		public abstract void Test (Thread thread);
 	}
 }
diff --git a/languages/native/NativeLanguage.cs b/languages/native/NativeLanguage.cs
index 2ddb755..2c1f931 100644
--- a/languages/native/NativeLanguage.cs
+++ b/languages/native/NativeLanguage.cs
@@ -182,6 +182,11 @@ namespace Mono.Debugger.Languages.Native
 			return false;
 		}
 
+		public override void Test (Thread thread)
+		{
+			throw new NotImplementedException ();
+		}
+
 		private bool disposed = false;
 
 		private void check_disposed ()

--------------1.5.6--



From 09a1c24d87258fd4d93c9f9456e7c60ca59b0707 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 8 Sep 2009 21:15:51 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/mono/Makefile.am            |    3 +
 backend/mono/MonoLanguageBackend.cs |    5 +-
 backend/mono/library.c              |   77 +++++++++++++++++++++++++++++++++++
 backend/mono/library.h              |   10 +++++
 4 files changed, 93 insertions(+), 2 deletions(-)
 create mode 100644 backend/mono/library.c
 create mode 100644 backend/mono/library.h
--------------1.5.6
Content-Type: text/x-patch; name="09a1c24d87258fd4d93c9f9456e7c60ca59b0707.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="09a1c24d87258fd4d93c9f9456e7c60ca59b0707.diff"

diff --git a/backend/mono/Makefile.am b/backend/mono/Makefile.am
index 7f89d42..37952c9 100644
--- a/backend/mono/Makefile.am
+++ b/backend/mono/Makefile.am
@@ -11,4 +11,7 @@ libmonodebuggerlibrary_la_SOURCES = \
 libmonodebuggerlibrary_la_LDFLAGS = \
 	 -no-undefined -export-dynamic -shared
 
+libmonodebuggerlibrary_la_LIBADD = \
+	@SERVER_DEPENDENCIES_LIBS@
+
 CLEANFILES = lib*.a lib*.dll
diff --git a/backend/mono/MonoLanguageBackend.cs b/backend/mono/MonoLanguageBackend.cs
index 115ad06..8f8797f 100644
--- a/backend/mono/MonoLanguageBackend.cs
+++ b/backend/mono/MonoLanguageBackend.cs
@@ -1391,16 +1391,17 @@ namespace Mono.Debugger.Languages.Mono
 
 			Console.WriteLine ("TEST: {0}", test);
 
-			TargetBinaryReader reader = thread.ReadMemory (test, 24).GetReader ();
+			TargetBinaryReader reader = thread.ReadMemory (test, 32).GetReader ();
 			long magic = reader.ReadAddress ();
 			int major = reader.ReadInt32 ();
 			int minor = reader.ReadInt32 ();
 
+			TargetAddress init = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
 			TargetAddress func = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
 
 			Console.WriteLine ("TEST: {0:x} {1} {2} - {3}", magic, major, minor, func);
 
-			TargetAddress ret = thread.CallMethod (func, 0x12345678, 0xdeadbeaf);
+			TargetAddress ret = thread.CallMethod (func, corlib.MonoImage, 0);
 
 			Console.WriteLine ("TEST #2: {0}", ret);
 		}
diff --git a/backend/mono/library.c b/backend/mono/library.c
new file mode 100644
index 0000000..6209b37
--- /dev/null
+++ b/backend/mono/library.c
@@ -0,0 +1,77 @@
+#include <library.h>
+#include <mono/metadata/image.h>
+#include <mono/metadata/class.h>
+
+typedef struct _MonoDebuggerLibraryHelpers {
+	MonoGenericInst * (* get_generic_inst) (int argc, MonoType **type_argv);
+	MonoGenericContext * (* get_generic_context) (MonoGenericInst *class_inst, MonoGenericInst *method_inst);
+} MonoDebuggerLibraryHelpers;
+
+typedef struct _MartinDebuggerTest {
+	guint64 magic;
+	guint32 major_version;
+	guint32 minor_version;
+
+	void (*initialize) (MonoDebuggerLibraryHelpers *helpers);
+	guint64 (*test) (guint64 argument);
+} MartinDebuggerTest;
+
+static MonoDebuggerLibraryHelpers *library_helpers = NULL;
+
+static void
+debugger_initialize (MonoDebuggerLibraryHelpers *helpers);
+
+static guint64
+debugger_library_test (guint64);
+
+MartinDebuggerTest MARTIN_DEBUGGER__test = {
+	0x7aff65af4253d427ULL,
+	1,
+	2,
+	&debugger_initialize,
+	&debugger_library_test
+};
+
+static void
+debugger_initialize (MonoDebuggerLibraryHelpers *helpers)
+{
+	g_message (G_STRLOC ": %p", helpers);
+	library_helpers = helpers;
+}
+
+guint64
+debugger_library_test (guint64 image_arg)
+{
+	MonoImage *image = (MonoImage *) GUINT_TO_POINTER ((gsize) image_arg);
+	MonoClass *int32_klass, *klass;
+	MonoGenericInst *ginst;
+	MonoGenericContext *gcontext;
+	MonoType *int32_type;
+	MonoType *inflated;
+
+	g_message (G_STRLOC ": %p - %s", image, mono_image_get_name (image));
+
+	int32_klass = mono_class_from_name (image, "System", "Int32");
+	g_message (G_STRLOC ": Int32 - %p", klass);
+
+	klass = mono_class_from_name (image, "System.Collections.Generic", "List`1");
+	g_message (G_STRLOC ": List`1 - %p", klass);
+
+	int32_type = mono_class_get_type (int32_klass);
+
+	ginst = library_helpers->get_generic_inst (1, &int32_type);
+	g_message (G_STRLOC ": ginst - %p", ginst);
+
+	gcontext = library_helpers->get_generic_context (ginst, NULL);
+	g_message (G_STRLOC ": gcontext - %p", gcontext);
+
+	inflated = mono_class_inflate_generic_type (mono_class_get_type (klass), gcontext);
+	g_message (G_STRLOC ": inflated - %p", inflated);
+
+	klass = mono_class_from_mono_type (inflated);
+	g_message (G_STRLOC ": klass - %p");
+
+	mono_class_init (klass);
+
+	return (guint64) (gsize) klass;
+}
diff --git a/backend/mono/library.h b/backend/mono/library.h
new file mode 100644
index 0000000..d91f4d1
--- /dev/null
+++ b/backend/mono/library.h
@@ -0,0 +1,10 @@
+#ifndef __MONO_DEBUGGER_LIBRARY_H__
+#define __MONO_DEBUGGER_LIBRARY_H__
+
+#include <glib.h>
+
+G_BEGIN_DECLS
+
+G_END_DECLS
+
+#endif

--------------1.5.6--



From 90a1c6de7b4d2401ef2c5de5979a01d88ee0c723 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 9 Sep 2009 04:39:01 +0200
Subject: [PATCH] Introduce MonoRuntimeTypeHandle.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/mono/RuntimeTypeHandle.cs |   80 +++++++++++++++++++++++++++++++++++++
 1 files changed, 80 insertions(+), 0 deletions(-)
 create mode 100644 backend/mono/RuntimeTypeHandle.cs
--------------1.5.6
Content-Type: text/x-patch; name="90a1c6de7b4d2401ef2c5de5979a01d88ee0c723.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="90a1c6de7b4d2401ef2c5de5979a01d88ee0c723.diff"

diff --git a/backend/mono/RuntimeTypeHandle.cs b/backend/mono/RuntimeTypeHandle.cs
new file mode 100644
index 0000000..96d24e7
--- /dev/null
+++ b/backend/mono/RuntimeTypeHandle.cs
@@ -0,0 +1,80 @@
+using System;
+
+using Mono.Debugger.Languages;
+using Mono.Debugger.Languages.Mono;
+
+namespace Mono.Debugger.Backend.Mono
+{
+	internal interface IMonoType
+	{
+		MonoRuntimeTypeHandle RuntimeTypeHandle {
+			get;
+		}
+	}
+
+	internal class MonoRuntimeTypeHandle : DebuggerMarshalByRefObject
+	{
+		public readonly TargetType Type;
+		public readonly byte[] TypeBlob;
+
+		public MonoRuntimeTypeHandle (TargetType type, byte[] blob)
+		{
+			this.Type = type;
+			this.TypeBlob = blob;
+		}
+
+		internal static MonoRuntimeTypeHandle CreateFundamental (MonoFundamentalType fundamental)
+		{
+			byte blob;
+
+			switch (fundamental.FundamentalKind) {
+			case FundamentalKind.Boolean:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_BOOLEAN;
+				break;
+			case FundamentalKind.Char:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_CHAR;
+				break;
+			case FundamentalKind.SByte:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_I1;
+				break;
+			case FundamentalKind.Byte:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_U1;
+				break;
+			case FundamentalKind.Int16:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_I2;
+				break;
+			case FundamentalKind.UInt16:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_U2;
+				break;
+			case FundamentalKind.Int32:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_I4;
+				break;
+			case FundamentalKind.UInt32:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_U4;
+				break;
+			case FundamentalKind.Int64:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_I8;
+				break;
+			case FundamentalKind.UInt64:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_U8;
+				break;
+			case FundamentalKind.Single:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_R4;
+				break;
+			case FundamentalKind.Double:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_R8;
+				break;
+			case FundamentalKind.IntPtr:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_I;
+				break;
+			case FundamentalKind.UIntPtr:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_U;
+				break;
+			default:
+				return null;
+			}
+
+			return new MonoRuntimeTypeHandle (fundamental, new byte[] { blob });
+		}
+	}
+}

--------------1.5.6--



From 3a1b7b4d3d6ebc49be45d7248fdf07a423e778e1 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 9 Sep 2009 16:42:41 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/mono/MonoLanguageBackend.cs   |   17 ++++++++++++-----
 backend/mono/library.c                |    2 +-
 frontend/Command.cs                   |   22 +++++++++++++++++++++-
 languages/Language.cs                 |    2 +-
 languages/mono/MonoClassType.cs       |    3 ++-
 languages/mono/MonoFundamentalType.cs |   11 ++++++++++-
 languages/native/NativeLanguage.cs    |    2 +-
 7 files changed, 48 insertions(+), 11 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="3a1b7b4d3d6ebc49be45d7248fdf07a423e778e1.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="3a1b7b4d3d6ebc49be45d7248fdf07a423e778e1.diff"

diff --git a/backend/mono/MonoLanguageBackend.cs b/backend/mono/MonoLanguageBackend.cs
index 8f8797f..a1644d3 100644
--- a/backend/mono/MonoLanguageBackend.cs
+++ b/backend/mono/MonoLanguageBackend.cs
@@ -1381,15 +1381,12 @@ namespace Mono.Debugger.Languages.Mono
 			}
 		}
 
-		public override void Test (Thread thread)
+		public override void Test (Thread thread, TargetType type)
 		{
-			Console.WriteLine ("TEST !!!");
-
 			var path = Path.Combine (AssemblyInfo.libdir, "libmonodebuggerlibrary.so");
-
 			TargetAddress test = thread.CallMethod (info.Test, TargetAddress.Null, 0, 0, path);
 
-			Console.WriteLine ("TEST: {0}", test);
+			Console.WriteLine ("TEST: {0} {1}", test, type);
 
 			TargetBinaryReader reader = thread.ReadMemory (test, 32).GetReader ();
 			long magic = reader.ReadAddress ();
@@ -1401,6 +1398,16 @@ namespace Mono.Debugger.Languages.Mono
 
 			Console.WriteLine ("TEST: {0:x} {1} {2} - {3}", magic, major, minor, func);
 
+			var mono_type = type as IMonoType;
+			if (mono_type == null)
+				throw new InvalidOperationException ();
+
+			var handle = mono_type.RuntimeTypeHandle;
+			if (handle == null)
+				throw new InvalidOperationException ();
+
+			Console.WriteLine ("TEST #1: {0}", TargetBinaryReader.HexDump (handle.TypeBlob));
+
 			TargetAddress ret = thread.CallMethod (func, corlib.MonoImage, 0);
 
 			Console.WriteLine ("TEST #2: {0}", ret);
diff --git a/backend/mono/library.c b/backend/mono/library.c
index 6209b37..179619a 100644
--- a/backend/mono/library.c
+++ b/backend/mono/library.c
@@ -69,7 +69,7 @@ debugger_library_test (guint64 image_arg)
 	g_message (G_STRLOC ": inflated - %p", inflated);
 
 	klass = mono_class_from_mono_type (inflated);
-	g_message (G_STRLOC ": klass - %p");
+	g_message (G_STRLOC ": klass - %p", klass);
 
 	mono_class_init (klass);
 
diff --git a/frontend/Command.cs b/frontend/Command.cs
index 819f564..37fbfc3 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -3938,9 +3938,29 @@ namespace Mono.Debugger.Frontend
 
 	public class TestCommand : FrameCommand
 	{
+		Expression expression;
+
+		protected override bool DoResolve (ScriptingContext context)
+		{
+			expression = ParseExpression (context);
+			if (expression == null)
+				return false;
+
+			Expression resolved = expression.TryResolveType (context);
+			if (resolved != null) {
+				expression = resolved;
+				return true;
+			}
+
+			return expression != null;
+			expression = expression.Resolve (context);
+		}
+
 		protected override object DoExecute (ScriptingContext context)
 		{
-			context.CurrentFrame.Language.Test (context.CurrentThread);
+			TargetType type = expression.EvaluateType (context);
+
+			context.CurrentFrame.Language.Test (context.CurrentThread, type);
 			return null;
 		}
 	}
diff --git a/languages/Language.cs b/languages/Language.cs
index 889719f..0e1c223 100644
--- a/languages/Language.cs
+++ b/languages/Language.cs
@@ -78,6 +78,6 @@ namespace Mono.Debugger.Languages
 
 		public abstract bool IsExceptionType (TargetClassType type);
 
-		public abstract void Test (Thread thread);
+		public abstract void Test (Thread thread, TargetType type);
 	}
 }
diff --git a/languages/mono/MonoClassType.cs b/languages/mono/MonoClassType.cs
index 9bf564b..dc9bc2e 100644
--- a/languages/mono/MonoClassType.cs
+++ b/languages/mono/MonoClassType.cs
@@ -7,6 +7,7 @@ using C = Mono.CompilerServices.SymbolWriter;
 using Cecil = Mono.Cecil;
 
 using Mono.Debugger.Backend;
+using Mono.Debugger.Backend.Mono;
 
 namespace Mono.Debugger.Languages.Mono
 {
@@ -31,7 +32,7 @@ namespace Mono.Debugger.Languages.Mono
 		MonoFunctionType LookupFunction (Cecil.MethodDefinition mdef);
 	}
 
-	internal class MonoClassType : TargetClassType, IMonoStructType
+	internal class MonoClassType : TargetClassType, IMonoStructType, IMonoType
 	{
 		MonoFieldInfo[] fields;
 		MonoMethodInfo[] methods;
diff --git a/languages/mono/MonoFundamentalType.cs b/languages/mono/MonoFundamentalType.cs
index 26d1aba..75f83f9 100644
--- a/languages/mono/MonoFundamentalType.cs
+++ b/languages/mono/MonoFundamentalType.cs
@@ -1,21 +1,30 @@
 using System;
 using System.Runtime.InteropServices;
 using Mono.Debugger.Backend;
+using Mono.Debugger.Backend.Mono;
 
 namespace Mono.Debugger.Languages.Mono
 {
-	internal class MonoFundamentalType : TargetFundamentalType
+	internal class MonoFundamentalType : TargetFundamentalType, IMonoType
 	{
 		MonoSymbolFile file;
 		MonoClassType class_type;
 		Cecil.TypeDefinition typedef;
 
+		MonoRuntimeTypeHandle handle;
+
 		protected MonoFundamentalType (MonoSymbolFile file, Cecil.TypeDefinition typedef,
 					       string name, FundamentalKind kind, int size)
 			: base (file.Language, name, kind, size)
 		{
 			this.file = file;
 			this.typedef = typedef;
+
+			handle = MonoRuntimeTypeHandle.CreateFundamental (this);
+		}
+
+		MonoRuntimeTypeHandle IMonoType.RuntimeTypeHandle {
+			get { return handle; }
 		}
 
 		public static MonoFundamentalType Create (MonoSymbolFile corlib,
diff --git a/languages/native/NativeLanguage.cs b/languages/native/NativeLanguage.cs
index 2c1f931..806017d 100644
--- a/languages/native/NativeLanguage.cs
+++ b/languages/native/NativeLanguage.cs
@@ -182,7 +182,7 @@ namespace Mono.Debugger.Languages.Native
 			return false;
 		}
 
-		public override void Test (Thread thread)
+		public override void Test (Thread thread, TargetType type)
 		{
 			throw new NotImplementedException ();
 		}

--------------1.5.6--



From 0cf9295643f9dec1b1899c65ed3c73e545123338 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 9 Sep 2009 19:50:13 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/mono/MonoLanguageBackend.cs       |    7 +++++--
 backend/mono/RuntimeTypeHandle.cs         |    3 +++
 backend/mono/library.c                    |   14 +++++++++++++-
 frontend/Command.cs                       |    2 +-
 languages/mono/MonoClassType.cs           |   19 +++++++++++++++++++
 languages/mono/MonoGenericInstanceType.cs |   28 +++++++++++++++++++++++++++-
 6 files changed, 68 insertions(+), 5 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="0cf9295643f9dec1b1899c65ed3c73e545123338.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="0cf9295643f9dec1b1899c65ed3c73e545123338.diff"

diff --git a/backend/mono/MonoLanguageBackend.cs b/backend/mono/MonoLanguageBackend.cs
index a1644d3..8121d41 100644
--- a/backend/mono/MonoLanguageBackend.cs
+++ b/backend/mono/MonoLanguageBackend.cs
@@ -1388,15 +1388,16 @@ namespace Mono.Debugger.Languages.Mono
 
 			Console.WriteLine ("TEST: {0} {1}", test, type);
 
-			TargetBinaryReader reader = thread.ReadMemory (test, 32).GetReader ();
+			TargetBinaryReader reader = thread.ReadMemory (test, 40).GetReader ();
 			long magic = reader.ReadAddress ();
 			int major = reader.ReadInt32 ();
 			int minor = reader.ReadInt32 ();
 
 			TargetAddress init = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
 			TargetAddress func = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
+			TargetAddress buffer = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
 
-			Console.WriteLine ("TEST: {0:x} {1} {2} - {3}", magic, major, minor, func);
+			Console.WriteLine ("TEST: {0:x} {1} {2} - {3} {4}", magic, major, minor, func, buffer);
 
 			var mono_type = type as IMonoType;
 			if (mono_type == null)
@@ -1408,6 +1409,8 @@ namespace Mono.Debugger.Languages.Mono
 
 			Console.WriteLine ("TEST #1: {0}", TargetBinaryReader.HexDump (handle.TypeBlob));
 
+			thread.WriteBuffer (buffer, handle.TypeBlob);
+
 			TargetAddress ret = thread.CallMethod (func, corlib.MonoImage, 0);
 
 			Console.WriteLine ("TEST #2: {0}", ret);
diff --git a/backend/mono/RuntimeTypeHandle.cs b/backend/mono/RuntimeTypeHandle.cs
index 96d24e7..f2b7d8b 100644
--- a/backend/mono/RuntimeTypeHandle.cs
+++ b/backend/mono/RuntimeTypeHandle.cs
@@ -70,6 +70,9 @@ namespace Mono.Debugger.Backend.Mono
 			case FundamentalKind.UIntPtr:
 				blob = (byte) MonoTypeEnum.MONO_TYPE_U;
 				break;
+			case FundamentalKind.String:
+				blob = (byte) MonoTypeEnum.MONO_TYPE_STRING;
+				break;
 			default:
 				return null;
 			}
diff --git a/backend/mono/library.c b/backend/mono/library.c
index 179619a..77823bc 100644
--- a/backend/mono/library.c
+++ b/backend/mono/library.c
@@ -1,12 +1,16 @@
 #include <library.h>
+#include <mono/metadata/blob.h>
 #include <mono/metadata/image.h>
 #include <mono/metadata/class.h>
 
 typedef struct _MonoDebuggerLibraryHelpers {
 	MonoGenericInst * (* get_generic_inst) (int argc, MonoType **type_argv);
 	MonoGenericContext * (* get_generic_context) (MonoGenericInst *class_inst, MonoGenericInst *method_inst);
+	MonoType * (* parse_type) (guint8 *ptr);
 } MonoDebuggerLibraryHelpers;
 
+static guint8 data_buffer [64536];
+
 typedef struct _MartinDebuggerTest {
 	guint64 magic;
 	guint32 major_version;
@@ -14,6 +18,8 @@ typedef struct _MartinDebuggerTest {
 
 	void (*initialize) (MonoDebuggerLibraryHelpers *helpers);
 	guint64 (*test) (guint64 argument);
+
+	guint8 *data_buffer;
 } MartinDebuggerTest;
 
 static MonoDebuggerLibraryHelpers *library_helpers = NULL;
@@ -29,7 +35,9 @@ MartinDebuggerTest MARTIN_DEBUGGER__test = {
 	1,
 	2,
 	&debugger_initialize,
-	&debugger_library_test
+	&debugger_library_test,
+
+	(guint8 *) &data_buffer
 };
 
 static void
@@ -48,6 +56,10 @@ debugger_library_test (guint64 image_arg)
 	MonoGenericContext *gcontext;
 	MonoType *int32_type;
 	MonoType *inflated;
+	MonoType *test;
+
+	test = library_helpers->parse_type (data_buffer);
+	g_message (G_STRLOC ": %p", test);
 
 	g_message (G_STRLOC ": %p - %s", image, mono_image_get_name (image));
 
diff --git a/frontend/Command.cs b/frontend/Command.cs
index 37fbfc3..dcc4713 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -3952,8 +3952,8 @@ namespace Mono.Debugger.Frontend
 				return true;
 			}
 
-			return expression != null;
 			expression = expression.Resolve (context);
+			return expression != null;
 		}
 
 		protected override object DoExecute (ScriptingContext context)
diff --git a/languages/mono/MonoClassType.cs b/languages/mono/MonoClassType.cs
index dc9bc2e..7c1d80e 100644
--- a/languages/mono/MonoClassType.cs
+++ b/languages/mono/MonoClassType.cs
@@ -1,4 +1,5 @@
 using System;
+using System.IO;
 using System.Text;
 using System.Diagnostics;
 using System.Collections;
@@ -55,6 +56,8 @@ namespace Mono.Debugger.Languages.Mono
 		DebuggerTypeProxyAttribute type_proxy;
 		bool is_compiler_generated;
 
+		MonoRuntimeTypeHandle handle;
+
 		public MonoClassType (MonoSymbolFile file, Cecil.TypeDefinition type)
 			: base (file.MonoLanguage, TargetObjectKind.Class)
 		{
@@ -74,6 +77,18 @@ namespace Mono.Debugger.Languages.Mono
 			} else
 				full_name = type.FullName;
 
+			using (MemoryStream ms = new MemoryStream (13)) {
+				var bw = new BinaryWriter (ms);
+				if (type.IsValueType)
+					bw.Write ((byte) MonoTypeEnum.MONO_TYPE_VALUETYPE);
+				else
+					bw.Write ((byte) MonoTypeEnum.MONO_TYPE_CLASS);
+				bw.Write (file.MonoImage.Address);
+				bw.Write (Token);
+
+				handle = new MonoRuntimeTypeHandle (this, ms.GetBuffer ());
+			}
+
 			DebuggerBrowsableState? browsable_state;
 			MonoSymbolFile.CheckCustomAttributes (type,
 							      out browsable_state,
@@ -89,6 +104,10 @@ namespace Mono.Debugger.Languages.Mono
 			this.class_info = class_info;
 		}
 
+		public MonoRuntimeTypeHandle RuntimeTypeHandle {
+			get { return handle; }
+		}
+
 		public override string BaseName {
 			get { return type.FullName; }
 		}
diff --git a/languages/mono/MonoGenericInstanceType.cs b/languages/mono/MonoGenericInstanceType.cs
index 645bb4e..33dcdbb 100644
--- a/languages/mono/MonoGenericInstanceType.cs
+++ b/languages/mono/MonoGenericInstanceType.cs
@@ -1,13 +1,17 @@
 using System;
+using System.IO;
 using System.Text;
 using System.Diagnostics;
 using System.Collections;
 using System.Collections.Generic;
 using Cecil = Mono.Cecil;
 
+using Mono.Debugger.Backend;
+using Mono.Debugger.Backend.Mono;
+
 namespace Mono.Debugger.Languages.Mono
 {
-	internal class MonoGenericInstanceType : TargetGenericInstanceType, IMonoStructType
+	internal class MonoGenericInstanceType : TargetGenericInstanceType, IMonoStructType, IMonoType
 	{
 		public readonly MonoClassType Container;
 		DebuggerDisplayAttribute debugger_display;
@@ -19,6 +23,8 @@ namespace Mono.Debugger.Languages.Mono
 		string full_name;
 		bool resolved;
 
+		MonoRuntimeTypeHandle handle;
+
 		public MonoGenericInstanceType (MonoClassType container, TargetType[] type_args,
 						TargetAddress class_ptr)
 			: base (container.File.MonoLanguage)
@@ -37,6 +43,22 @@ namespace Mono.Debugger.Languages.Mono
 			sb.Append ('>');
 			full_name = sb.ToString ();
 
+			using (MemoryStream ms = new MemoryStream ()) {
+				var bw = new BinaryWriter (ms);
+
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_GENERICINST);
+				bw.Write (container.RuntimeTypeHandle.TypeBlob);
+				bw.Write ((int) type_args.Length);
+
+				foreach (TargetType arg in type_args)
+					bw.Write (((IMonoType) arg).RuntimeTypeHandle.TypeBlob);
+
+				byte[] buffer = new byte [bw.BaseStream.Position];
+				Array.Copy (ms.GetBuffer (), buffer, buffer.Length);
+
+				handle = new MonoRuntimeTypeHandle (this, buffer);
+			}
+
 			bool is_compiler_generated;
 			DebuggerBrowsableState? browsable_state;
 			MonoSymbolFile.CheckCustomAttributes (container.Type,
@@ -46,6 +68,10 @@ namespace Mono.Debugger.Languages.Mono
 							      out is_compiler_generated);
 		}
 
+		MonoRuntimeTypeHandle IMonoType.RuntimeTypeHandle {
+			get { return handle; }
+		}
+
 		TargetStructType IMonoStructType.Type {
 			get { return this; }
 		}

--------------1.5.6--



From a923e2d704ddd9dde01917b0e1666301abbfd9d5 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 9 Sep 2009 20:19:45 +0200
Subject: [PATCH] Create the blob in one central location.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/mono/MonoLanguageBackend.cs |    6 +--
 backend/mono/RuntimeTypeHandle.cs   |  108 +++++++++++++++++++++++++++++++++++
 2 files changed, 109 insertions(+), 5 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="a923e2d704ddd9dde01917b0e1666301abbfd9d5.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="a923e2d704ddd9dde01917b0e1666301abbfd9d5.diff"

diff --git a/backend/mono/MonoLanguageBackend.cs b/backend/mono/MonoLanguageBackend.cs
index 8121d41..1aa199b 100644
--- a/backend/mono/MonoLanguageBackend.cs
+++ b/backend/mono/MonoLanguageBackend.cs
@@ -1399,11 +1399,7 @@ namespace Mono.Debugger.Languages.Mono
 
 			Console.WriteLine ("TEST: {0:x} {1} {2} - {3} {4}", magic, major, minor, func, buffer);
 
-			var mono_type = type as IMonoType;
-			if (mono_type == null)
-				throw new InvalidOperationException ();
-
-			var handle = mono_type.RuntimeTypeHandle;
+			var handle = MonoRuntimeTypeHandle.Create (type);
 			if (handle == null)
 				throw new InvalidOperationException ();
 
diff --git a/backend/mono/RuntimeTypeHandle.cs b/backend/mono/RuntimeTypeHandle.cs
index f2b7d8b..b1bb067 100644
--- a/backend/mono/RuntimeTypeHandle.cs
+++ b/backend/mono/RuntimeTypeHandle.cs
@@ -1,4 +1,5 @@
 using System;
+using System.IO;
 
 using Mono.Debugger.Languages;
 using Mono.Debugger.Languages.Mono;
@@ -79,5 +80,112 @@ namespace Mono.Debugger.Backend.Mono
 
 			return new MonoRuntimeTypeHandle (fundamental, new byte[] { blob });
 		}
+
+		static bool create_fundamental_blob (BinaryWriter bw, MonoFundamentalType type)
+		{
+			switch (type.FundamentalKind) {
+			case FundamentalKind.Boolean:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_BOOLEAN);
+				return true;
+			case FundamentalKind.Char:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_CHAR);
+				return true;
+			case FundamentalKind.SByte:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_I1);
+				return true;
+			case FundamentalKind.Byte:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_U1);
+				return true;
+			case FundamentalKind.Int16:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_I2);
+				return true;
+			case FundamentalKind.UInt16:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_U2);
+				return true;
+			case FundamentalKind.Int32:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_I4);
+				return true;
+			case FundamentalKind.UInt32:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_U4);
+				return true;
+			case FundamentalKind.Int64:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_I8);
+				return true;
+			case FundamentalKind.UInt64:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_U8);
+				return true;
+			case FundamentalKind.Single:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_R4);
+				return true;
+			case FundamentalKind.Double:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_R8);
+				return true;
+			case FundamentalKind.IntPtr:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_I);
+				return true;
+			case FundamentalKind.UIntPtr:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_U);
+				return true;
+			case FundamentalKind.String:
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_STRING);
+				return true;
+			default:
+				return false;
+			}
+		}
+
+		static bool create_blob (BinaryWriter bw, TargetType type)
+		{
+			switch (type.Kind) {
+			case TargetObjectKind.Fundamental:
+				return create_fundamental_blob (bw, (MonoFundamentalType) type);
+
+			case TargetObjectKind.Struct:
+			case TargetObjectKind.Class: {
+				MonoClassType ctype = (MonoClassType) type;
+
+				if (ctype.Type.IsValueType)
+					bw.Write ((byte) MonoTypeEnum.MONO_TYPE_VALUETYPE);
+				else
+					bw.Write ((byte) MonoTypeEnum.MONO_TYPE_CLASS);
+				bw.Write (ctype.File.MonoImage.Address);
+				bw.Write (ctype.Token);
+				return true;
+			}
+
+			case TargetObjectKind.GenericInstance: {
+				MonoGenericInstanceType ginst = (MonoGenericInstanceType) type;
+
+				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_GENERICINST);
+				if (!create_blob (bw, ginst.Container))
+					return false;
+				bw.Write ((int) ginst.TypeArguments.Length);
+
+				foreach (TargetType arg in ginst.TypeArguments) {
+					if (!create_blob (bw, arg))
+						return false;
+				}
+
+				return true;
+			}
+
+			default:
+				return false;
+			}
+		}
+
+		internal static MonoRuntimeTypeHandle Create (TargetType type)
+		{
+			using (MemoryStream ms = new MemoryStream ()) {
+				var bw = new BinaryWriter (ms);
+				if (!create_blob (bw, type))
+					return null;
+
+				byte[] buffer = new byte [bw.BaseStream.Position];
+				Array.Copy (ms.GetBuffer (), buffer, buffer.Length);
+
+				return new MonoRuntimeTypeHandle (type, buffer);
+			}
+		}
 	}
 }

--------------1.5.6--



From d957f183476b9d594788840eb7560847ae9f1774 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 9 Sep 2009 20:20:58 +0200
Subject: [PATCH] We don't need IMonoType anymore.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/mono/RuntimeTypeHandle.cs         |    7 -------
 languages/mono/MonoClassType.cs           |   20 +-------------------
 languages/mono/MonoFundamentalType.cs     |   10 +---------
 languages/mono/MonoGenericInstanceType.cs |   24 +-----------------------
 4 files changed, 3 insertions(+), 58 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="d957f183476b9d594788840eb7560847ae9f1774.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="d957f183476b9d594788840eb7560847ae9f1774.diff"

diff --git a/backend/mono/RuntimeTypeHandle.cs b/backend/mono/RuntimeTypeHandle.cs
index b1bb067..791d904 100644
--- a/backend/mono/RuntimeTypeHandle.cs
+++ b/backend/mono/RuntimeTypeHandle.cs
@@ -6,13 +6,6 @@ using Mono.Debugger.Languages.Mono;
 
 namespace Mono.Debugger.Backend.Mono
 {
-	internal interface IMonoType
-	{
-		MonoRuntimeTypeHandle RuntimeTypeHandle {
-			get;
-		}
-	}
-
 	internal class MonoRuntimeTypeHandle : DebuggerMarshalByRefObject
 	{
 		public readonly TargetType Type;
diff --git a/languages/mono/MonoClassType.cs b/languages/mono/MonoClassType.cs
index 7c1d80e..9cfc331 100644
--- a/languages/mono/MonoClassType.cs
+++ b/languages/mono/MonoClassType.cs
@@ -33,7 +33,7 @@ namespace Mono.Debugger.Languages.Mono
 		MonoFunctionType LookupFunction (Cecil.MethodDefinition mdef);
 	}
 
-	internal class MonoClassType : TargetClassType, IMonoStructType, IMonoType
+	internal class MonoClassType : TargetClassType, IMonoStructType
 	{
 		MonoFieldInfo[] fields;
 		MonoMethodInfo[] methods;
@@ -56,8 +56,6 @@ namespace Mono.Debugger.Languages.Mono
 		DebuggerTypeProxyAttribute type_proxy;
 		bool is_compiler_generated;
 
-		MonoRuntimeTypeHandle handle;
-
 		public MonoClassType (MonoSymbolFile file, Cecil.TypeDefinition type)
 			: base (file.MonoLanguage, TargetObjectKind.Class)
 		{
@@ -77,18 +75,6 @@ namespace Mono.Debugger.Languages.Mono
 			} else
 				full_name = type.FullName;
 
-			using (MemoryStream ms = new MemoryStream (13)) {
-				var bw = new BinaryWriter (ms);
-				if (type.IsValueType)
-					bw.Write ((byte) MonoTypeEnum.MONO_TYPE_VALUETYPE);
-				else
-					bw.Write ((byte) MonoTypeEnum.MONO_TYPE_CLASS);
-				bw.Write (file.MonoImage.Address);
-				bw.Write (Token);
-
-				handle = new MonoRuntimeTypeHandle (this, ms.GetBuffer ());
-			}
-
 			DebuggerBrowsableState? browsable_state;
 			MonoSymbolFile.CheckCustomAttributes (type,
 							      out browsable_state,
@@ -104,10 +90,6 @@ namespace Mono.Debugger.Languages.Mono
 			this.class_info = class_info;
 		}
 
-		public MonoRuntimeTypeHandle RuntimeTypeHandle {
-			get { return handle; }
-		}
-
 		public override string BaseName {
 			get { return type.FullName; }
 		}
diff --git a/languages/mono/MonoFundamentalType.cs b/languages/mono/MonoFundamentalType.cs
index 75f83f9..74dabab 100644
--- a/languages/mono/MonoFundamentalType.cs
+++ b/languages/mono/MonoFundamentalType.cs
@@ -5,26 +5,18 @@ using Mono.Debugger.Backend.Mono;
 
 namespace Mono.Debugger.Languages.Mono
 {
-	internal class MonoFundamentalType : TargetFundamentalType, IMonoType
+	internal class MonoFundamentalType : TargetFundamentalType
 	{
 		MonoSymbolFile file;
 		MonoClassType class_type;
 		Cecil.TypeDefinition typedef;
 
-		MonoRuntimeTypeHandle handle;
-
 		protected MonoFundamentalType (MonoSymbolFile file, Cecil.TypeDefinition typedef,
 					       string name, FundamentalKind kind, int size)
 			: base (file.Language, name, kind, size)
 		{
 			this.file = file;
 			this.typedef = typedef;
-
-			handle = MonoRuntimeTypeHandle.CreateFundamental (this);
-		}
-
-		MonoRuntimeTypeHandle IMonoType.RuntimeTypeHandle {
-			get { return handle; }
 		}
 
 		public static MonoFundamentalType Create (MonoSymbolFile corlib,
diff --git a/languages/mono/MonoGenericInstanceType.cs b/languages/mono/MonoGenericInstanceType.cs
index 33dcdbb..f1576ba 100644
--- a/languages/mono/MonoGenericInstanceType.cs
+++ b/languages/mono/MonoGenericInstanceType.cs
@@ -11,7 +11,7 @@ using Mono.Debugger.Backend.Mono;
 
 namespace Mono.Debugger.Languages.Mono
 {
-	internal class MonoGenericInstanceType : TargetGenericInstanceType, IMonoStructType, IMonoType
+	internal class MonoGenericInstanceType : TargetGenericInstanceType, IMonoStructType
 	{
 		public readonly MonoClassType Container;
 		DebuggerDisplayAttribute debugger_display;
@@ -23,8 +23,6 @@ namespace Mono.Debugger.Languages.Mono
 		string full_name;
 		bool resolved;
 
-		MonoRuntimeTypeHandle handle;
-
 		public MonoGenericInstanceType (MonoClassType container, TargetType[] type_args,
 						TargetAddress class_ptr)
 			: base (container.File.MonoLanguage)
@@ -43,22 +41,6 @@ namespace Mono.Debugger.Languages.Mono
 			sb.Append ('>');
 			full_name = sb.ToString ();
 
-			using (MemoryStream ms = new MemoryStream ()) {
-				var bw = new BinaryWriter (ms);
-
-				bw.Write ((byte) MonoTypeEnum.MONO_TYPE_GENERICINST);
-				bw.Write (container.RuntimeTypeHandle.TypeBlob);
-				bw.Write ((int) type_args.Length);
-
-				foreach (TargetType arg in type_args)
-					bw.Write (((IMonoType) arg).RuntimeTypeHandle.TypeBlob);
-
-				byte[] buffer = new byte [bw.BaseStream.Position];
-				Array.Copy (ms.GetBuffer (), buffer, buffer.Length);
-
-				handle = new MonoRuntimeTypeHandle (this, buffer);
-			}
-
 			bool is_compiler_generated;
 			DebuggerBrowsableState? browsable_state;
 			MonoSymbolFile.CheckCustomAttributes (container.Type,
@@ -68,10 +50,6 @@ namespace Mono.Debugger.Languages.Mono
 							      out is_compiler_generated);
 		}
 
-		MonoRuntimeTypeHandle IMonoType.RuntimeTypeHandle {
-			get { return handle; }
-		}
-
 		TargetStructType IMonoStructType.Type {
 			get { return this; }
 		}

--------------1.5.6--



From d1bd8e3af5cbe9639122d5fc99bee31e59c5bbac Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Wed, 9 Sep 2009 21:10:19 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/mono/RuntimeTypeHandle.cs |   57 -------------------------------------
 backend/mono/library.c            |   38 ++++++------------------
 2 files changed, 10 insertions(+), 85 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="d1bd8e3af5cbe9639122d5fc99bee31e59c5bbac.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="d1bd8e3af5cbe9639122d5fc99bee31e59c5bbac.diff"

diff --git a/backend/mono/RuntimeTypeHandle.cs b/backend/mono/RuntimeTypeHandle.cs
index 791d904..ed80a2c 100644
--- a/backend/mono/RuntimeTypeHandle.cs
+++ b/backend/mono/RuntimeTypeHandle.cs
@@ -17,63 +17,6 @@ namespace Mono.Debugger.Backend.Mono
 			this.TypeBlob = blob;
 		}
 
-		internal static MonoRuntimeTypeHandle CreateFundamental (MonoFundamentalType fundamental)
-		{
-			byte blob;
-
-			switch (fundamental.FundamentalKind) {
-			case FundamentalKind.Boolean:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_BOOLEAN;
-				break;
-			case FundamentalKind.Char:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_CHAR;
-				break;
-			case FundamentalKind.SByte:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_I1;
-				break;
-			case FundamentalKind.Byte:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_U1;
-				break;
-			case FundamentalKind.Int16:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_I2;
-				break;
-			case FundamentalKind.UInt16:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_U2;
-				break;
-			case FundamentalKind.Int32:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_I4;
-				break;
-			case FundamentalKind.UInt32:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_U4;
-				break;
-			case FundamentalKind.Int64:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_I8;
-				break;
-			case FundamentalKind.UInt64:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_U8;
-				break;
-			case FundamentalKind.Single:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_R4;
-				break;
-			case FundamentalKind.Double:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_R8;
-				break;
-			case FundamentalKind.IntPtr:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_I;
-				break;
-			case FundamentalKind.UIntPtr:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_U;
-				break;
-			case FundamentalKind.String:
-				blob = (byte) MonoTypeEnum.MONO_TYPE_STRING;
-				break;
-			default:
-				return null;
-			}
-
-			return new MonoRuntimeTypeHandle (fundamental, new byte[] { blob });
-		}
-
 		static bool create_fundamental_blob (BinaryWriter bw, MonoFundamentalType type)
 		{
 			switch (type.FundamentalKind) {
diff --git a/backend/mono/library.c b/backend/mono/library.c
index 77823bc..9c2f45a 100644
--- a/backend/mono/library.c
+++ b/backend/mono/library.c
@@ -50,38 +50,20 @@ debugger_initialize (MonoDebuggerLibraryHelpers *helpers)
 guint64
 debugger_library_test (guint64 image_arg)
 {
-	MonoImage *image = (MonoImage *) GUINT_TO_POINTER ((gsize) image_arg);
-	MonoClass *int32_klass, *klass;
-	MonoGenericInst *ginst;
-	MonoGenericContext *gcontext;
-	MonoType *int32_type;
-	MonoType *inflated;
-	MonoType *test;
+	MonoType *type;
+	MonoClass *klass;
 
-	test = library_helpers->parse_type (data_buffer);
-	g_message (G_STRLOC ": %p", test);
+	type = library_helpers->parse_type (data_buffer);
+	g_message (G_STRLOC ": %p", type);
 
-	g_message (G_STRLOC ": %p - %s", image, mono_image_get_name (image));
+	klass = mono_class_from_mono_type (type);
+	g_message (G_STRLOC ": %p", klass);
 
-	int32_klass = mono_class_from_name (image, "System", "Int32");
-	g_message (G_STRLOC ": Int32 - %p", klass);
+	if (!klass)
+		return 0;
 
-	klass = mono_class_from_name (image, "System.Collections.Generic", "List`1");
-	g_message (G_STRLOC ": List`1 - %p", klass);
-
-	int32_type = mono_class_get_type (int32_klass);
-
-	ginst = library_helpers->get_generic_inst (1, &int32_type);
-	g_message (G_STRLOC ": ginst - %p", ginst);
-
-	gcontext = library_helpers->get_generic_context (ginst, NULL);
-	g_message (G_STRLOC ": gcontext - %p", gcontext);
-
-	inflated = mono_class_inflate_generic_type (mono_class_get_type (klass), gcontext);
-	g_message (G_STRLOC ": inflated - %p", inflated);
-
-	klass = mono_class_from_mono_type (inflated);
-	g_message (G_STRLOC ": klass - %p", klass);
+	g_message (G_STRLOC ": klass - %p - %s.%s", klass,
+		   mono_class_get_namespace (klass), mono_class_get_name (klass));
 
 	mono_class_init (klass);
 

--------------1.5.6--



From 48b1d73cd1feb5ad0213fd630305ddfa6c51d920 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 10 Sep 2009 02:38:40 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/mono/MonoLanguageBackend.cs |    9 ++++--
 backend/mono/library.c              |   49 +++++++++++++++++++++++++++++-----
 frontend/Command.cs                 |    9 +++++-
 languages/Language.cs               |    2 +-
 languages/native/NativeLanguage.cs  |    2 +-
 5 files changed, 56 insertions(+), 15 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="48b1d73cd1feb5ad0213fd630305ddfa6c51d920.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="48b1d73cd1feb5ad0213fd630305ddfa6c51d920.diff"

diff --git a/backend/mono/MonoLanguageBackend.cs b/backend/mono/MonoLanguageBackend.cs
index 1aa199b..297b7d2 100644
--- a/backend/mono/MonoLanguageBackend.cs
+++ b/backend/mono/MonoLanguageBackend.cs
@@ -1381,8 +1381,10 @@ namespace Mono.Debugger.Languages.Mono
 			}
 		}
 
-		public override void Test (Thread thread, TargetType type)
+		public override void Test (Thread thread, TargetObject instance, TargetFunctionType type)
 		{
+			MonoFunctionType ftype = (MonoFunctionType) type;
+
 			var path = Path.Combine (AssemblyInfo.libdir, "libmonodebuggerlibrary.so");
 			TargetAddress test = thread.CallMethod (info.Test, TargetAddress.Null, 0, 0, path);
 
@@ -1399,7 +1401,7 @@ namespace Mono.Debugger.Languages.Mono
 
 			Console.WriteLine ("TEST: {0:x} {1} {2} - {3} {4}", magic, major, minor, func, buffer);
 
-			var handle = MonoRuntimeTypeHandle.Create (type);
+			var handle = MonoRuntimeTypeHandle.Create (ftype.DeclaringType);
 			if (handle == null)
 				throw new InvalidOperationException ();
 
@@ -1407,7 +1409,8 @@ namespace Mono.Debugger.Languages.Mono
 
 			thread.WriteBuffer (buffer, handle.TypeBlob);
 
-			TargetAddress ret = thread.CallMethod (func, corlib.MonoImage, 0);
+			TargetAddress instance_addr = instance.GetAddress (thread);
+			TargetAddress ret = thread.CallMethod (func, instance_addr, ftype.Token);
 
 			Console.WriteLine ("TEST #2: {0}", ret);
 		}
diff --git a/backend/mono/library.c b/backend/mono/library.c
index 9c2f45a..d6fd56b 100644
--- a/backend/mono/library.c
+++ b/backend/mono/library.c
@@ -2,6 +2,7 @@
 #include <mono/metadata/blob.h>
 #include <mono/metadata/image.h>
 #include <mono/metadata/class.h>
+#include <mono/metadata/object.h>
 
 typedef struct _MonoDebuggerLibraryHelpers {
 	MonoGenericInst * (* get_generic_inst) (int argc, MonoType **type_argv);
@@ -17,7 +18,7 @@ typedef struct _MartinDebuggerTest {
 	guint32 minor_version;
 
 	void (*initialize) (MonoDebuggerLibraryHelpers *helpers);
-	guint64 (*test) (guint64 argument);
+	guint64 (*test) (guint64 argument, guint64 token);
 
 	guint8 *data_buffer;
 } MartinDebuggerTest;
@@ -28,7 +29,7 @@ static void
 debugger_initialize (MonoDebuggerLibraryHelpers *helpers);
 
 static guint64
-debugger_library_test (guint64);
+debugger_library_test (guint64, guint64);
 
 MartinDebuggerTest MARTIN_DEBUGGER__test = {
 	0x7aff65af4253d427ULL,
@@ -47,11 +48,13 @@ debugger_initialize (MonoDebuggerLibraryHelpers *helpers)
 	library_helpers = helpers;
 }
 
-guint64
-debugger_library_test (guint64 image_arg)
+static MonoMethod *
+lookup_method (guint32 token)
 {
 	MonoType *type;
 	MonoClass *klass;
+	MonoMethod *method;
+	gpointer iter = NULL;
 
 	type = library_helpers->parse_type (data_buffer);
 	g_message (G_STRLOC ": %p", type);
@@ -60,12 +63,42 @@ debugger_library_test (guint64 image_arg)
 	g_message (G_STRLOC ": %p", klass);
 
 	if (!klass)
-		return 0;
+		return NULL;
 
-	g_message (G_STRLOC ": klass - %p - %s.%s", klass,
-		   mono_class_get_namespace (klass), mono_class_get_name (klass));
+	g_message (G_STRLOC ": klass - %p - %s.%s - %Lx", klass,
+		   mono_class_get_namespace (klass), mono_class_get_name (klass),
+		   token);
 
 	mono_class_init (klass);
 
-	return (guint64) (gsize) klass;
+	while (method = mono_class_get_methods (klass, &iter)) {
+		g_message (G_STRLOC ": %p - %x - %s", method,
+			   mono_method_get_token (method), mono_method_get_name (method));
+
+		if (mono_method_get_token (method) == token)
+			return method;
+	}
+
+	return NULL;
+}
+
+guint64
+debugger_library_test (guint64 instance_arg, guint64 token_arg)
+{
+	MonoObject *instance = (MonoObject *) GUINT_TO_POINTER ((gsize) instance_arg);
+	guint32 token = (guint32) token_arg;
+	MonoObject *ret, *exc = NULL;
+	MonoMethod *method;
+
+	method = lookup_method (token);
+	if (!method)
+		return 0;
+
+	g_message (G_STRLOC ": %p", method);
+
+	ret = mono_runtime_invoke (method, instance, NULL, &exc);
+
+	g_message (G_STRLOC ": %p", ret);
+
+	return (guint64) (gsize) ret;
 }
diff --git a/frontend/Command.cs b/frontend/Command.cs
index dcc4713..0113b1a 100644
--- a/frontend/Command.cs
+++ b/frontend/Command.cs
@@ -3958,9 +3958,14 @@ namespace Mono.Debugger.Frontend
 
 		protected override object DoExecute (ScriptingContext context)
 		{
-			TargetType type = expression.EvaluateType (context);
+			MemberExpression me = (MemberExpression) expression;
+
+			Console.WriteLine ("TEST EXECUTE: {0} {1}", expression, expression.GetType ());
+
+			var func = expression.EvaluateMethod (context, LocationType.PropertyGetter, new Expression [0]);
+			Console.WriteLine ("TEST #1: {0}", func);
 
-			context.CurrentFrame.Language.Test (context.CurrentThread, type);
+			context.CurrentFrame.Language.Test (context.CurrentThread, me.InstanceObject, func);
 			return null;
 		}
 	}
diff --git a/languages/Language.cs b/languages/Language.cs
index 0e1c223..3359076 100644
--- a/languages/Language.cs
+++ b/languages/Language.cs
@@ -78,6 +78,6 @@ namespace Mono.Debugger.Languages
 
 		public abstract bool IsExceptionType (TargetClassType type);
 
-		public abstract void Test (Thread thread, TargetType type);
+		public abstract void Test (Thread thread, TargetObject instance, TargetFunctionType type);
 	}
 }
diff --git a/languages/native/NativeLanguage.cs b/languages/native/NativeLanguage.cs
index 806017d..9635831 100644
--- a/languages/native/NativeLanguage.cs
+++ b/languages/native/NativeLanguage.cs
@@ -182,7 +182,7 @@ namespace Mono.Debugger.Languages.Native
 			return false;
 		}
 
-		public override void Test (Thread thread, TargetType type)
+		public override void Test (Thread thread, TargetObject instance, TargetFunctionType type)
 		{
 			throw new NotImplementedException ();
 		}

--------------1.5.6--



From 05eb30ec40ff08f9d0a84dd3ff3c6b07eec5ec43 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 10 Sep 2009 08:28:39 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs           |    1 +
 frontend/Expression.cs                    |    9 ++++++++-
 languages/mono/MonoClassType.cs           |    4 ++++
 languages/mono/MonoFunctionType.cs        |    1 +
 languages/mono/MonoGenericInstanceType.cs |    2 ++
 5 files changed, 16 insertions(+), 1 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="05eb30ec40ff08f9d0a84dd3ff3c6b07eec5ec43.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="05eb30ec40ff08f9d0a84dd3ff3c6b07eec5ec43.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 661bf8b..8c9906f 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -4023,6 +4023,7 @@ namespace Mono.Debugger.Backend
 				switch (stage) {
 				case Stage.Uninitialized: {
 					class_info = RTI.Function.ResolveClass (inferior, false);
+					Console.WriteLine ("RTI: {0} {1}", RTI.Function, class_info);
 					if (class_info != null)
 						goto case Stage.ResolvedClass;
 
diff --git a/frontend/Expression.cs b/frontend/Expression.cs
index 4396367..a9a2144 100644
--- a/frontend/Expression.cs
+++ b/frontend/Expression.cs
@@ -1733,7 +1733,14 @@ namespace Mono.Debugger.Frontend
 				}
 			}
 
-			TargetClassType ctype = stype as TargetClassType;
+			TargetClassType ctype;
+
+			TargetGenericInstanceType ginst = stype as TargetGenericInstanceType;
+			if (ginst != null)
+				ctype = ginst.ContainerType;
+			else
+				ctype = stype as TargetClassType;
+
 			if (ctype != null) {
 				TargetMemberInfo member = ctype.FindMember (
 					name, search_static, search_instance);
diff --git a/languages/mono/MonoClassType.cs b/languages/mono/MonoClassType.cs
index 9cfc331..6c72a52 100644
--- a/languages/mono/MonoClassType.cs
+++ b/languages/mono/MonoClassType.cs
@@ -338,10 +338,14 @@ namespace Mono.Debugger.Languages.Mono
 
 			TargetAddress image = file.MonoImage;
 
+			Console.WriteLine ("FORCE CLASS INIT: {0} {1} {2}", this, image, Name);
+
 			TargetAddress klass = thread.CallMethod (
 				file.MonoLanguage.MonoDebuggerInfo.LookupClass, image, 0, 0,
 				Name);
 
+			Console.WriteLine ("FORCE CLASS INIT #1: {0} {1} {2} - {3}", this, image, Name, klass);
+
 			return (TargetClass) thread.ThreadServant.DoTargetAccess (
 				delegate (TargetMemoryAccess target) {
 					class_info = MonoClassInfo.ReadClassInfo (
diff --git a/languages/mono/MonoFunctionType.cs b/languages/mono/MonoFunctionType.cs
index b15ca8a..399c268 100644
--- a/languages/mono/MonoFunctionType.cs
+++ b/languages/mono/MonoFunctionType.cs
@@ -175,6 +175,7 @@ namespace Mono.Debugger.Languages.Mono
 
 		internal MonoClassInfo ResolveClass (TargetMemoryAccess target, bool fail)
 		{
+			Console.WriteLine ("FUNC RESOLVE CLASS: {0} {1}", this, klass);
 			return klass.ResolveClass (target, fail);
 		}
 
diff --git a/languages/mono/MonoGenericInstanceType.cs b/languages/mono/MonoGenericInstanceType.cs
index f1576ba..bf99c0c 100644
--- a/languages/mono/MonoGenericInstanceType.cs
+++ b/languages/mono/MonoGenericInstanceType.cs
@@ -41,6 +41,8 @@ namespace Mono.Debugger.Languages.Mono
 			sb.Append ('>');
 			full_name = sb.ToString ();
 
+			Console.WriteLine ("GENERIC INSTANCE TYPE: {0} {1} {2}", container, full_name, class_ptr);
+
 			bool is_compiler_generated;
 			DebuggerBrowsableState? browsable_state;
 			MonoSymbolFile.CheckCustomAttributes (container.Type,

--------------1.5.6--



From 1e8b67be5de7b2333797686899a1f007909e4a5a Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 10 Sep 2009 14:37:21 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs     |   19 +++++++++++++++++++
 backend/mono/MonoLanguageBackend.cs |   25 +++++++++++++++++++++++--
 backend/mono/MonoThreadManager.cs   |    9 +++++++--
 backend/mono/library.c              |   19 +++----------------
 4 files changed, 52 insertions(+), 20 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="1e8b67be5de7b2333797686899a1f007909e4a5a.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="1e8b67be5de7b2333797686899a1f007909e4a5a.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 8c9906f..b20438c 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -4020,8 +4020,15 @@ namespace Mono.Debugger.Backend
 
 			void do_execute ()
 			{
+				Console.WriteLine ("RTI EXECUTE: {0}", stage);
+
 				switch (stage) {
 				case Stage.Uninitialized: {
+					Console.WriteLine ("RTI: {0}", RTI.Function);
+
+					language.Test (inferior, RTI.Function, ID);
+					break;
+
 					class_info = RTI.Function.ResolveClass (inferior, false);
 					Console.WriteLine ("RTI: {0} {1}", RTI.Function, class_info);
 					if (class_info != null)
@@ -4129,10 +4136,22 @@ namespace Mono.Debugger.Backend
 
 			protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
 			{
+				Console.WriteLine ("RTI RESULT: {0} {1:x}", stage, data1);
+
 				switch (stage) {
 				case Stage.Uninitialized: {
+					method = new TargetAddress (inferior.AddressDomain, data1);
+					Console.WriteLine ("RTI RESOLVED METHOD: {0}", method);
+					stage = Stage.HasMethodAddress;
+					do_execute ();
+					args = null;
+					return EventResult.Running;
+
+
 					TargetAddress klass = new TargetAddress (inferior.AddressDomain, data1);
 
+					Console.WriteLine ("RTI RESOLVED CLASS: {0}", klass);
+
 					Report.Debug (DebugFlags.SSE,
 						      "{0} rti resolved class: {1}", sse, klass);
 
diff --git a/backend/mono/MonoLanguageBackend.cs b/backend/mono/MonoLanguageBackend.cs
index 297b7d2..426ca21 100644
--- a/backend/mono/MonoLanguageBackend.cs
+++ b/backend/mono/MonoLanguageBackend.cs
@@ -1381,21 +1381,42 @@ namespace Mono.Debugger.Languages.Mono
 			}
 		}
 
+		internal void Test (Inferior inferior, MonoFunctionType type, long callback_id)
+		{
+			var handle = MonoRuntimeTypeHandle.Create (type.DeclaringType);
+			if (handle == null)
+				throw new InvalidOperationException ();
+
+			Console.WriteLine ("TEST: {0}", TargetBinaryReader.HexDump (handle.TypeBlob));
+
+			using (MemoryStream ms = new MemoryStream ()) {
+				var bw = new BinaryWriter (ms);
+				bw.Write (handle.TypeBlob);
+				bw.Write (type.Token);
+
+				byte[] buffer = new byte [bw.BaseStream.Position];
+				Array.Copy (ms.GetBuffer (), buffer, buffer.Length);
+
+				inferior.CallMethod (info.ParseMethod, buffer, callback_id);
+			}
+		}
+
 		public override void Test (Thread thread, TargetObject instance, TargetFunctionType type)
 		{
 			MonoFunctionType ftype = (MonoFunctionType) type;
 
 			var path = Path.Combine (AssemblyInfo.libdir, "libmonodebuggerlibrary.so");
-			TargetAddress test = thread.CallMethod (info.Test, TargetAddress.Null, 0, 0, path);
+			TargetAddress test = thread.CallMethod (info.LoadLibrary, TargetAddress.Null, 0, 0, path);
 
 			Console.WriteLine ("TEST: {0} {1}", test, type);
 
-			TargetBinaryReader reader = thread.ReadMemory (test, 40).GetReader ();
+			TargetBinaryReader reader = thread.ReadMemory (test, 48).GetReader ();
 			long magic = reader.ReadAddress ();
 			int major = reader.ReadInt32 ();
 			int minor = reader.ReadInt32 ();
 
 			TargetAddress init = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
+			reader.Position += 8;
 			TargetAddress func = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
 			TargetAddress buffer = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
 
diff --git a/backend/mono/MonoThreadManager.cs b/backend/mono/MonoThreadManager.cs
index c9e95bf..4b94dec 100644
--- a/backend/mono/MonoThreadManager.cs
+++ b/backend/mono/MonoThreadManager.cs
@@ -536,7 +536,9 @@ namespace Mono.Debugger.Backend.Mono
 		public readonly TargetAddress UsingMonoDebugger;
 		public readonly TargetAddress InterruptionRequest;
 
-		public readonly TargetAddress Test;
+		public readonly TargetAddress ParseType;
+		public readonly TargetAddress ParseMethod;
+		public readonly TargetAddress LoadLibrary;
 
 		public static MonoDebuggerInfo Create (TargetMemoryAccess memory, TargetAddress info)
 		{
@@ -618,6 +620,7 @@ namespace Mono.Debugger.Backend.Mono
 			ThreadTable               = reader.ReadAddress ();
 
 			ExecutableCodeBuffer      = reader.ReadAddress ();
+
 			BreakpointInfo            = reader.ReadAddress ();
 			BreakpointInfoIndex       = reader.ReadAddress ();
 
@@ -635,7 +638,9 @@ namespace Mono.Debugger.Backend.Mono
 			UsingMonoDebugger         = reader.ReadAddress ();
 			InterruptionRequest       = reader.ReadAddress ();
 
-			Test                      = reader.ReadAddress ();
+			ParseType                 = reader.ReadAddress ();
+			ParseMethod               = reader.ReadAddress ();
+			LoadLibrary               = reader.ReadAddress ();
 
 			Report.Debug (DebugFlags.JitSymtab, this);
 		}
diff --git a/backend/mono/library.c b/backend/mono/library.c
index d6fd56b..b4bde8d 100644
--- a/backend/mono/library.c
+++ b/backend/mono/library.c
@@ -7,7 +7,6 @@
 typedef struct _MonoDebuggerLibraryHelpers {
 	MonoGenericInst * (* get_generic_inst) (int argc, MonoType **type_argv);
 	MonoGenericContext * (* get_generic_context) (MonoGenericInst *class_inst, MonoGenericInst *method_inst);
-	MonoType * (* parse_type) (guint8 *ptr);
 } MonoDebuggerLibraryHelpers;
 
 static guint8 data_buffer [64536];
@@ -48,6 +47,7 @@ debugger_initialize (MonoDebuggerLibraryHelpers *helpers)
 	library_helpers = helpers;
 }
 
+#if 0
 static MonoMethod *
 lookup_method (guint32 token)
 {
@@ -81,24 +81,11 @@ lookup_method (guint32 token)
 
 	return NULL;
 }
+#endif
 
 guint64
-debugger_library_test (guint64 instance_arg, guint64 token_arg)
+debugger_library_test (G_GNUC_UNUSED guint64 arg1, G_GNUC_UNUSED guint64 arg2)
 {
-	MonoObject *instance = (MonoObject *) GUINT_TO_POINTER ((gsize) instance_arg);
-	guint32 token = (guint32) token_arg;
-	MonoObject *ret, *exc = NULL;
-	MonoMethod *method;
-
-	method = lookup_method (token);
-	if (!method)
 		return 0;
 
-	g_message (G_STRLOC ": %p", method);
-
-	ret = mono_runtime_invoke (method, instance, NULL, &exc);
-
-	g_message (G_STRLOC ": %p", ret);
-
-	return (guint64) (gsize) ret;
 }

--------------1.5.6--



From d8fa7378bd62c909f9192eeb53ef20aa37e2031f Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Mon, 14 Sep 2009 15:01:17 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs     |   33 ++++++++++++++++++++++++++++++++-
 backend/mono/MonoLanguageBackend.cs |   26 +++++++++++++++++++++++++-
 backend/mono/MonoThreadManager.cs   |    2 ++
 3 files changed, 59 insertions(+), 2 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="d8fa7378bd62c909f9192eeb53ef20aa37e2031f.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="d8fa7378bd62c909f9192eeb53ef20aa37e2031f.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index b20438c..bea0b83 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -3649,6 +3649,9 @@ namespace Mono.Debugger.Backend
 			}
 
 			try {
+				if (cevent.CallbackData != null)
+					return CallbackCompleted (cevent.Data1, cevent.Data2, cevent.CallbackData, out args);
+				else
 				return CallbackCompleted (cevent.Data1, cevent.Data2, out args);
 			} catch (Exception ex) {
 				Report.Debug (DebugFlags.SSE, "{0} got exception while handling event {1}: {2}",
@@ -3660,6 +3663,11 @@ namespace Mono.Debugger.Backend
 
 		protected abstract EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args);
 
+		protected virtual EventResult CallbackCompleted (long data1, long data2, byte[] data3, out TargetEventArgs args)
+		{
+			return CallbackCompleted (data1, data2, out args);
+		}
+
 		public override bool IsSourceOperation {
 			get { return false; }
 		}
@@ -4134,12 +4142,32 @@ namespace Mono.Debugger.Backend
 				return false;
 			}
 
+			protected override EventResult CallbackCompleted (long data1, long data2, byte[] data3,
+									  out TargetEventArgs args)
+			{
+				switch (stage) {
+				case Stage.Uninitialized:
+					method = language.TestDone (inferior, data1, data2, data3);
+					Console.WriteLine ("RTI RESOLVED METHOD: {0}", method);
+					stage = Stage.HasMethodAddress;
+					do_execute ();
+					args = null;
+					return EventResult.Running;
+
+					break;
+				default:
+					throw new InternalError ();
+				}
+			}
+
 			protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
 			{
-				Console.WriteLine ("RTI RESULT: {0} {1:x}", stage, data1);
+				Console.WriteLine ("RTI RESULT: {0} {1:x} {2:x}", stage, data1, data2);
 
 				switch (stage) {
 				case Stage.Uninitialized: {
+					throw new InternalError ();
+
 					method = new TargetAddress (inferior.AddressDomain, data1);
 					Console.WriteLine ("RTI RESOLVED METHOD: {0}", method);
 					stage = Stage.HasMethodAddress;
@@ -4241,6 +4269,9 @@ namespace Mono.Debugger.Backend
 			protected override EventResult DoProcessEvent (Inferior.ChildEvent cevent,
 								       out TargetEventArgs args)
 			{
+				Console.WriteLine ("RTI PROCESS EVENT: {0} {1}", cevent,
+						   cevent.CallbackData != null);
+
 				if ((cevent.Type == Inferior.ChildEventType.CHILD_HIT_BREAKPOINT) ||
 				    ((cevent.Type == Inferior.ChildEventType.CHILD_STOPPED) &&
 				     (cevent.Argument == 0))) {
diff --git a/backend/mono/MonoLanguageBackend.cs b/backend/mono/MonoLanguageBackend.cs
index 426ca21..e0c2dfb 100644
--- a/backend/mono/MonoLanguageBackend.cs
+++ b/backend/mono/MonoLanguageBackend.cs
@@ -1391,16 +1391,40 @@ namespace Mono.Debugger.Languages.Mono
 
 			using (MemoryStream ms = new MemoryStream ()) {
 				var bw = new BinaryWriter (ms);
+				bw.Write ((byte) 0x01);
+				int ret_size = 2 * inferior.TargetAddressSize;
+				bw.Write (ret_size);
+				bw.BaseStream.Position += ret_size;
 				bw.Write (handle.TypeBlob);
 				bw.Write (type.Token);
 
 				byte[] buffer = new byte [bw.BaseStream.Position];
 				Array.Copy (ms.GetBuffer (), buffer, buffer.Length);
 
-				inferior.CallMethod (info.ParseMethod, buffer, callback_id);
+				inferior.CallMethod (info.RunCommand, buffer, callback_id);
 			}
 		}
 
+		internal TargetAddress TestDone (Inferior inferior, long data1, long data2, byte[] data3)
+		{
+			Console.WriteLine ("TEST DONE: {0:x} {1:x}\n{2}", data1, data2,
+					   TargetBinaryReader.HexDump (data3));
+
+			TargetBinaryReader reader = new TargetBinaryReader (data3, inferior.TargetMemoryInfo);
+
+			byte command = reader.ReadByte ();
+			int ret_size = reader.ReadInt32 ();
+
+			Console.WriteLine ("TEST DONE #1: {0} {1}", command, ret_size);
+
+			TargetAddress klass = new TargetAddress (inferior.AddressDomain, reader.ReadAddress ());
+			TargetAddress method = new TargetAddress (inferior.AddressDomain, reader.ReadAddress ());
+
+			Console.WriteLine ("TEST DONE #2: {0} {1}", klass, method);
+
+			return method;
+		}
+
 		public override void Test (Thread thread, TargetObject instance, TargetFunctionType type)
 		{
 			MonoFunctionType ftype = (MonoFunctionType) type;
diff --git a/backend/mono/MonoThreadManager.cs b/backend/mono/MonoThreadManager.cs
index 4b94dec..5b959e4 100644
--- a/backend/mono/MonoThreadManager.cs
+++ b/backend/mono/MonoThreadManager.cs
@@ -538,6 +538,7 @@ namespace Mono.Debugger.Backend.Mono
 
 		public readonly TargetAddress ParseType;
 		public readonly TargetAddress ParseMethod;
+		public readonly TargetAddress RunCommand;
 		public readonly TargetAddress LoadLibrary;
 
 		public static MonoDebuggerInfo Create (TargetMemoryAccess memory, TargetAddress info)
@@ -640,6 +641,7 @@ namespace Mono.Debugger.Backend.Mono
 
 			ParseType                 = reader.ReadAddress ();
 			ParseMethod               = reader.ReadAddress ();
+			RunCommand                = reader.ReadAddress ();
 			LoadLibrary               = reader.ReadAddress ();
 
 			Report.Debug (DebugFlags.JitSymtab, this);

--------------1.5.6--



From a27f2863fb9136651b04911dc6fcc1259c76f9ce Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Mon, 14 Sep 2009 15:52:15 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs     |    6 +-
 backend/mono/DebuggerCommands.cs    |  118 +++++++++++++++++++++++++++++++++++
 backend/mono/MonoLanguageBackend.cs |    8 +++
 3 files changed, 130 insertions(+), 2 deletions(-)
 create mode 100644 backend/mono/DebuggerCommands.cs
--------------1.5.6
Content-Type: text/x-patch; name="a27f2863fb9136651b04911dc6fcc1259c76f9ce.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="a27f2863fb9136651b04911dc6fcc1259c76f9ce.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index bea0b83..9ba7907 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -4034,7 +4034,7 @@ namespace Mono.Debugger.Backend
 				case Stage.Uninitialized: {
 					Console.WriteLine ("RTI: {0}", RTI.Function);
 
-					language.Test (inferior, RTI.Function, ID);
+					language.DebuggerCommands.ParseMethod (inferior, RTI.Function, ID);
 					break;
 
 					class_info = RTI.Function.ResolveClass (inferior, false);
@@ -4147,7 +4147,9 @@ namespace Mono.Debugger.Backend
 			{
 				switch (stage) {
 				case Stage.Uninitialized:
-					method = language.TestDone (inferior, data1, data2, data3);
+					TargetAddress klass;
+					language.DebuggerCommands.ParseMethodDone (
+						inferior, data1, data2, data3, out klass, out method);
 					Console.WriteLine ("RTI RESOLVED METHOD: {0}", method);
 					stage = Stage.HasMethodAddress;
 					do_execute ();
diff --git a/backend/mono/DebuggerCommands.cs b/backend/mono/DebuggerCommands.cs
new file mode 100644
index 0000000..4e6f482
--- /dev/null
+++ b/backend/mono/DebuggerCommands.cs
@@ -0,0 +1,118 @@
+using System;
+using System.IO;
+
+using Mono.Debugger.Languages;
+using Mono.Debugger.Languages.Mono;
+
+namespace Mono.Debugger.Backend.Mono
+{
+	internal class DebuggerCommands : DebuggerMarshalByRefObject
+	{
+		internal enum Command {
+			ParseType		= 1,
+			ParseMethod
+		}
+
+		internal enum CommandResult {
+			Ok			= 0,
+			InvalidCommand,
+			UnknownError,
+
+			ParseTypeFailed		= 16
+		}
+
+		public readonly MonoLanguageBackend Mono;
+		public readonly TargetAddress CommandFunction;
+
+		public DebuggerCommands (MonoLanguageBackend mono, TargetAddress func)
+		{
+			this.Mono = mono;
+			this.CommandFunction = func;
+		}
+
+		internal void ParseType (Inferior inferior, TargetType type, long callback_id)
+		{
+			var handle = MonoRuntimeTypeHandle.Create (type);
+			if (handle == null)
+				throw new InvalidOperationException ();
+
+			Console.WriteLine ("PARSE TYPE: {0}", TargetBinaryReader.HexDump (handle.TypeBlob));
+
+			using (MemoryStream ms = new MemoryStream ()) {
+				var bw = new BinaryWriter (ms);
+				bw.Write ((byte) Command.ParseType);
+				int ret_size = inferior.TargetAddressSize;
+				bw.Write (ret_size);
+				bw.BaseStream.Position += ret_size;
+				bw.Write (handle.TypeBlob);
+
+				byte[] buffer = new byte [bw.BaseStream.Position];
+				Array.Copy (ms.GetBuffer (), buffer, buffer.Length);
+
+				inferior.CallMethod (CommandFunction, buffer, callback_id);
+			}
+		}
+
+		internal TargetAddress ParseTypeDone (Inferior inferior, long data1, long data2, byte[] data3)
+		{
+			Console.WriteLine ("PARSE TYPE DONE: {0:x} {1:x}\n{2}", data1, data2,
+					   TargetBinaryReader.HexDump (data3));
+
+			TargetBinaryReader reader = new TargetBinaryReader (data3, inferior.TargetMemoryInfo);
+
+			byte command = reader.ReadByte ();
+			int ret_size = reader.ReadInt32 ();
+
+			Console.WriteLine ("PARSE TYPE DONE #1: {0} {1}", command, ret_size);
+
+			TargetAddress klass = new TargetAddress (inferior.AddressDomain, reader.ReadAddress ());
+
+			Console.WriteLine ("PARSE TYPE DONE #2: {0}", klass);
+
+			return klass;
+		}
+
+		internal void ParseMethod (Inferior inferior, MonoFunctionType func, long callback_id)
+		{
+			var handle = MonoRuntimeTypeHandle.Create (func.DeclaringType);
+			if (handle == null)
+				throw new InvalidOperationException ();
+
+			Console.WriteLine ("PARSE METHOD: {0}", TargetBinaryReader.HexDump (handle.TypeBlob));
+
+			using (MemoryStream ms = new MemoryStream ()) {
+				var bw = new BinaryWriter (ms);
+				bw.Write ((byte) Command.ParseMethod);
+				int ret_size = 2 * inferior.TargetAddressSize;
+				bw.Write (ret_size);
+				bw.BaseStream.Position += ret_size;
+				bw.Write (handle.TypeBlob);
+				bw.Write (func.Token);
+
+				byte[] buffer = new byte [bw.BaseStream.Position];
+				Array.Copy (ms.GetBuffer (), buffer, buffer.Length);
+
+				inferior.CallMethod (CommandFunction, buffer, callback_id);
+			}
+		}
+
+		internal void ParseMethodDone (Inferior inferior, long data1, long data2, byte[] data3,
+					       out TargetAddress klass, out TargetAddress method)
+		{
+			Console.WriteLine ("PARSE METHOD DONE: {0:x} {1:x}\n{2}", data1, data2,
+					   TargetBinaryReader.HexDump (data3));
+
+			TargetBinaryReader reader = new TargetBinaryReader (data3, inferior.TargetMemoryInfo);
+
+			byte command = reader.ReadByte ();
+			int ret_size = reader.ReadInt32 ();
+
+			Console.WriteLine ("PARSE METHOD DONE #1: {0} {1}", command, ret_size);
+
+			klass = new TargetAddress (inferior.AddressDomain, reader.ReadAddress ());
+			method = new TargetAddress (inferior.AddressDomain, reader.ReadAddress ());
+
+			Console.WriteLine ("PARSE METHOD DONE #2: {0} {1}", klass, method);
+		}
+	}
+}
diff --git a/backend/mono/MonoLanguageBackend.cs b/backend/mono/MonoLanguageBackend.cs
index e0c2dfb..3060d99 100644
--- a/backend/mono/MonoLanguageBackend.cs
+++ b/backend/mono/MonoLanguageBackend.cs
@@ -229,11 +229,15 @@ namespace Mono.Debugger.Languages.Mono
 		TargetAddress[] trampolines;
 		bool initialized;
 
+		DebuggerCommands commands;
+
 		public MonoLanguageBackend (ProcessServant process, MonoDebuggerInfo info)
 		{
 			this.process = process;
 			this.info = info;
 			data_tables = new Hashtable ();
+
+			commands = new DebuggerCommands (this, info.RunCommand);
 		}
 
 		public override string Name {
@@ -268,6 +272,10 @@ namespace Mono.Debugger.Languages.Mono
 			get { return trampolines; }
 		}
 
+		internal DebuggerCommands DebuggerCommands {
+			get { return commands; }
+		}
+
 		internal bool IsTrampolineAddress (TargetAddress address)
 		{
 			foreach (TargetAddress trampoline in trampolines) {

--------------1.5.6--



From 4a82eca005bbe9579f800dc91f5f6f9f18bb6814 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Mon, 14 Sep 2009 18:13:38 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/ProcessStart.cs         |    2 --
 backend/SingleSteppingEngine.cs |    6 ++++++
 2 files changed, 6 insertions(+), 2 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="4a82eca005bbe9579f800dc91f5f6f9f18bb6814.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="4a82eca005bbe9579f800dc91f5f6f9f18bb6814.diff"

diff --git a/backend/ProcessStart.cs b/backend/ProcessStart.cs
index 52a54a5..be264ec 100644
--- a/backend/ProcessStart.cs
+++ b/backend/ProcessStart.cs
@@ -278,8 +278,6 @@ namespace Mono.Debugger.Backend
 
 			add_env_path (hash, "MONO_SHARED_HOSTNAME", "mdb");
 
-			add_env_path (hash, "MONO_GENERIC_SHARING", "none");
-
 			ArrayList list = new ArrayList ();
 			foreach (DictionaryEntry entry in hash) {
 				string key = (string) entry.Key;
diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 9ba7907..68b7109 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -4076,6 +4076,8 @@ namespace Mono.Debugger.Backend
 					Report.Debug (DebugFlags.SSE,
 						      "{0} rti compiling method: {1}", sse, method);
 
+					Console.WriteLine ("COMPILE METHOD: {0}", method);
+
 					stage = Stage.CompilingMethod;
 					inferior.CallMethod (
 						sse.MonoDebuggerInfo.CompileMethod, method.Address, 0, ID);
@@ -4212,6 +4214,8 @@ namespace Mono.Debugger.Backend
 				case Stage.GettingVirtualMethod: {
 					method = new TargetAddress (inferior.AddressDomain, data1);
 
+					Console.WriteLine ("GOT VIRTUAL METHOD: {0}", method);
+
 					Report.Debug (DebugFlags.SSE,
 						      "{0} rti got virtual method: {1}", sse, method);
 
@@ -4247,6 +4251,8 @@ namespace Mono.Debugger.Backend
 				case Stage.CompilingMethod: {
 					invoke = new TargetAddress (inferior.AddressDomain, data1);
 
+					Console.WriteLine ("COMPILED METHOD: {0}", data1);
+
 					Report.Debug (DebugFlags.SSE,
 						      "{0} rti compiled method: {1}", sse, invoke);
 

--------------1.5.6--



From 4bcdae978cbff094a1432d9b3697a09709698fff Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 15 Sep 2009 02:03:30 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 frontend/Expression.cs                    |    2 +-
 languages/TargetClassType.cs              |    4 -
 languages/TargetStructType.cs             |    4 +
 languages/mono/MonoClassType.cs           |   45 ++-------------
 languages/mono/MonoGenericInstanceType.cs |   24 ++++----
 languages/mono/MonoMember.cs              |    2 +-
 languages/mono/MonoStructType.cs          |   89 +++++++++++++++++++++++++++++
 7 files changed, 114 insertions(+), 56 deletions(-)
 create mode 100644 languages/mono/MonoStructType.cs
--------------1.5.6
Content-Type: text/x-patch; name="4bcdae978cbff094a1432d9b3697a09709698fff.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="4bcdae978cbff094a1432d9b3697a09709698fff.diff"

diff --git a/frontend/Expression.cs b/frontend/Expression.cs
index a9a2144..b4ddbc0 100644
--- a/frontend/Expression.cs
+++ b/frontend/Expression.cs
@@ -1767,7 +1767,7 @@ namespace Mono.Debugger.Frontend
 						is_static = true;
 					}
 				} else {
-					foreach (TargetMethodInfo method in ctype.Methods) {
+					foreach (TargetMethodInfo method in stype.Methods) {
 						if (method.IsStatic && !search_static)
 							continue;
 						if (!method.IsStatic && !search_instance)
diff --git a/languages/TargetClassType.cs b/languages/TargetClassType.cs
index f3f8761..3cad62d 100644
--- a/languages/TargetClassType.cs
+++ b/languages/TargetClassType.cs
@@ -22,10 +22,6 @@ namespace Mono.Debugger.Languages
 			get;
 		}
 
-		public abstract TargetMethodInfo[] Methods {
-			get;
-		}
-
 		public abstract TargetMethodInfo[] Constructors {
 			get;
 		}
diff --git a/languages/TargetStructType.cs b/languages/TargetStructType.cs
index cc53ca5..1067558 100644
--- a/languages/TargetStructType.cs
+++ b/languages/TargetStructType.cs
@@ -21,6 +21,10 @@ namespace Mono.Debugger.Languages
 			get;
 		}
 
+		public abstract TargetMethodInfo[] Methods {
+			get;
+		}
+
 		public virtual DebuggerDisplayAttribute DebuggerDisplayAttribute {
 			get { return null; }
 		}
diff --git a/languages/mono/MonoClassType.cs b/languages/mono/MonoClassType.cs
index 6c72a52..aa85c44 100644
--- a/languages/mono/MonoClassType.cs
+++ b/languages/mono/MonoClassType.cs
@@ -46,6 +46,8 @@ namespace Mono.Debugger.Languages.Mono
 		IMonoStructType parent_type;
 		MonoClassInfo class_info;
 
+		MonoStructType struct_type;
+
 		bool resolved;
 		Hashtable load_handlers;
 		int load_handler_id;
@@ -62,6 +64,8 @@ namespace Mono.Debugger.Languages.Mono
 			this.type = type;
 			this.file = file;
 
+			this.struct_type = new MonoStructType (file, type);
+
 			if (type.GenericParameters.Count > 0) {
 				StringBuilder sb = new StringBuilder (type.FullName);
 				sb.Append ('<');
@@ -188,29 +192,6 @@ namespace Mono.Debugger.Languages.Mono
 			}
 		}
 
-		void get_methods ()
-		{
-			if (methods != null)
-				return;
-
-			int num_methods = 0;
-			foreach (Cecil.MethodDefinition method in type.Methods) {
-				if ((method.Attributes & Cecil.MethodAttributes.SpecialName) != 0)
-					continue;
-				num_methods++;
-			}
-
-			methods = new MonoMethodInfo [num_methods];
-
-			int pos = 0;
-			foreach (Cecil.MethodDefinition method in type.Methods) {
-				if ((method.Attributes & Cecil.MethodAttributes.SpecialName) != 0)
-					continue;
-				methods [pos] = MonoMethodInfo.Create (this, pos, method);
-				pos++;
-			}
-		}
-
 		void get_properties ()
 		{
 			if (properties != null)
@@ -228,10 +209,7 @@ namespace Mono.Debugger.Languages.Mono
 		}
 
 		public override TargetMethodInfo[] Methods {
-			get {
-				get_methods ();
-				return methods;
-			}
+			get { return struct_type.Methods; }
 		}
 
 		public override TargetPropertyInfo[] Properties {
@@ -387,20 +365,9 @@ namespace Mono.Debugger.Languages.Mono
 			return (TargetStructObject) current.GetObject (target, location);
 		}
 
-		Dictionary<int,MonoFunctionType> function_hash;
-
 		public MonoFunctionType LookupFunction (Cecil.MethodDefinition mdef)
 		{
-			int token = MonoDebuggerSupport.GetMethodToken (mdef);
-			if (function_hash == null)
-				function_hash = new Dictionary<int,MonoFunctionType> ();
-			if (!function_hash.ContainsKey (token)) {
-				MonoFunctionType function = new MonoFunctionType (this, mdef);
-				function_hash.Add (token, function);
-				return function;
-			}
-
-			return function_hash [token];
+			return struct_type.LookupFunction (mdef);
 		}
 	}
 }
diff --git a/languages/mono/MonoGenericInstanceType.cs b/languages/mono/MonoGenericInstanceType.cs
index bf99c0c..778d641 100644
--- a/languages/mono/MonoGenericInstanceType.cs
+++ b/languages/mono/MonoGenericInstanceType.cs
@@ -23,6 +23,8 @@ namespace Mono.Debugger.Languages.Mono
 		string full_name;
 		bool resolved;
 
+		MonoStructType struct_type;
+
 		public MonoGenericInstanceType (MonoClassType container, TargetType[] type_args,
 						TargetAddress class_ptr)
 			: base (container.File.MonoLanguage)
@@ -31,6 +33,8 @@ namespace Mono.Debugger.Languages.Mono
 			this.type_args = type_args;
 			this.class_ptr = class_ptr;
 
+			this.struct_type = new MonoStructType (container.File, container.Type);
+
 			StringBuilder sb = new StringBuilder (container.BaseName);
 			sb.Append ('<');
 			for (int i = 0; i < type_args.Length; i++) {
@@ -198,20 +202,18 @@ namespace Mono.Debugger.Languages.Mono
 			return new MonoGenericInstanceObject (this, class_info, location);
 		}
 
-		Dictionary<int,MonoFunctionType> function_hash;
-
-		MonoFunctionType IMonoStructType.LookupFunction (Cecil.MethodDefinition mdef)
+		public MonoFunctionType LookupFunction (Cecil.MethodDefinition mdef)
 		{
-			int token = MonoDebuggerSupport.GetMethodToken (mdef);
-			if (function_hash == null)
-				function_hash = new Dictionary<int,MonoFunctionType> ();
-			if (!function_hash.ContainsKey (token)) {
-				MonoFunctionType function = new MonoFunctionType (this, mdef);
-				function_hash.Add (token, function);
-				return function;
+			return struct_type.LookupFunction (mdef);
 			}
 
-			return function_hash [token];
+		#region New Stuff
+
+		public override TargetMethodInfo[] Methods {
+			get { return struct_type.Methods; }
 		}
+
+		#endregion
+
 	}
 }
diff --git a/languages/mono/MonoMember.cs b/languages/mono/MonoMember.cs
index 6c34b54..17a2453 100644
--- a/languages/mono/MonoMember.cs
+++ b/languages/mono/MonoMember.cs
@@ -98,7 +98,7 @@ namespace Mono.Debugger.Languages.Mono
 	{
 		public readonly MonoFunctionType FunctionType;
 
-		private MonoMethodInfo (IMonoStructType klass, int index, Cecil.MethodDefinition minfo,
+		public MonoMethodInfo (IMonoStructType klass, int index, Cecil.MethodDefinition minfo,
 					MonoFunctionType type)
 			: base (type, MonoFunctionType.GetMethodName (minfo), index,
 				minfo.IsStatic, GetAccessibility (minfo), type.FullName)
diff --git a/languages/mono/MonoStructType.cs b/languages/mono/MonoStructType.cs
new file mode 100644
index 0000000..b66f6c3
--- /dev/null
+++ b/languages/mono/MonoStructType.cs
@@ -0,0 +1,89 @@
+using System;
+using System.IO;
+using System.Text;
+using System.Diagnostics;
+using System.Collections;
+using System.Collections.Generic;
+using C = Mono.CompilerServices.SymbolWriter;
+using Cecil = Mono.Cecil;
+
+using Mono.Debugger.Backend;
+using Mono.Debugger.Backend.Mono;
+
+namespace Mono.Debugger.Languages.Mono
+{
+	internal class MonoStructType : IMonoStructType
+	{
+		public MonoSymbolFile File {
+			get; private set;
+		}
+
+		public TargetStructType Type {
+			get; private set;
+		}
+
+		public Cecil.TypeDefinition TypeDef {
+			get; private set;
+		}
+
+		MonoClassInfo class_info;
+
+		public MonoStructType (MonoSymbolFile file, Cecil.TypeDefinition typedef)
+		{
+			this.File = file;
+			this.TypeDef = typedef;
+		}
+
+		MonoClassInfo IMonoStructType.ClassInfo {
+			get { return class_info; }
+			set { class_info = value; }
+		}
+
+		public MonoClassInfo ResolveClass (TargetMemoryAccess target, bool fail)
+		{
+			return null;
+		}
+
+		TargetMethodInfo[] methods;
+		Dictionary<Cecil.MethodDefinition,MonoFunctionType> function_hash;
+
+		void get_methods ()
+		{
+			if (methods != null)
+				return;
+
+			int num_methods = 0;
+			foreach (Cecil.MethodDefinition method in TypeDef.Methods) {
+				if ((method.Attributes & Cecil.MethodAttributes.SpecialName) != 0)
+					continue;
+				num_methods++;
+			}
+
+			methods = new MonoMethodInfo [num_methods];
+			function_hash = new Dictionary<Cecil.MethodDefinition, MonoFunctionType> ();
+
+			int pos = 0;
+			foreach (Cecil.MethodDefinition method in TypeDef.Methods) {
+				MonoFunctionType func = new MonoFunctionType (this, method);
+				function_hash.Add (method, func);
+				if ((method.Attributes & Cecil.MethodAttributes.SpecialName) != 0)
+					continue;
+				methods [pos] = new MonoMethodInfo (this, pos, method, func);
+				pos++;
+			}
+		}
+
+		public TargetMethodInfo[] Methods {
+			get {
+				get_methods ();
+				return methods;
+			}
+		}
+
+		public MonoFunctionType LookupFunction (Cecil.MethodDefinition mdef)
+		{
+			get_methods ();
+			return function_hash [mdef];
+		}
+	}
+}

--------------1.5.6--



From dd4594c89f71149a7c6008ca363d339c7e4e2179 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 15 Sep 2009 14:55:42 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 languages/mono/MonoClassType.cs           |    2 +-
 languages/mono/MonoGenericInstanceType.cs |    2 +-
 languages/mono/MonoStructType.cs          |    3 ++-
 3 files changed, 4 insertions(+), 3 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="dd4594c89f71149a7c6008ca363d339c7e4e2179.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="dd4594c89f71149a7c6008ca363d339c7e4e2179.diff"

diff --git a/languages/mono/MonoClassType.cs b/languages/mono/MonoClassType.cs
index aa85c44..21f9030 100644
--- a/languages/mono/MonoClassType.cs
+++ b/languages/mono/MonoClassType.cs
@@ -64,7 +64,7 @@ namespace Mono.Debugger.Languages.Mono
 			this.type = type;
 			this.file = file;
 
-			this.struct_type = new MonoStructType (file, type);
+			this.struct_type = new MonoStructType (file, this, type);
 
 			if (type.GenericParameters.Count > 0) {
 				StringBuilder sb = new StringBuilder (type.FullName);
diff --git a/languages/mono/MonoGenericInstanceType.cs b/languages/mono/MonoGenericInstanceType.cs
index 778d641..9a16666 100644
--- a/languages/mono/MonoGenericInstanceType.cs
+++ b/languages/mono/MonoGenericInstanceType.cs
@@ -33,7 +33,7 @@ namespace Mono.Debugger.Languages.Mono
 			this.type_args = type_args;
 			this.class_ptr = class_ptr;
 
-			this.struct_type = new MonoStructType (container.File, container.Type);
+			this.struct_type = new MonoStructType (container.File, container, container.Type);
 
 			StringBuilder sb = new StringBuilder (container.BaseName);
 			sb.Append ('<');
diff --git a/languages/mono/MonoStructType.cs b/languages/mono/MonoStructType.cs
index b66f6c3..48aad1b 100644
--- a/languages/mono/MonoStructType.cs
+++ b/languages/mono/MonoStructType.cs
@@ -28,9 +28,10 @@ namespace Mono.Debugger.Languages.Mono
 
 		MonoClassInfo class_info;
 
-		public MonoStructType (MonoSymbolFile file, Cecil.TypeDefinition typedef)
+		public MonoStructType (MonoSymbolFile file, TargetStructType type, Cecil.TypeDefinition typedef)
 		{
 			this.File = file;
+			this.Type = type;
 			this.TypeDef = typedef;
 		}
 

--------------1.5.6--



From b7a0bd555d5aa736766109ff2a39b7b2d2494c77 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 15 Sep 2009 15:00:10 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 frontend/Expression.cs                    |    3 +++
 languages/mono/MonoGenericInstanceType.cs |    2 +-
 2 files changed, 4 insertions(+), 1 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="b7a0bd555d5aa736766109ff2a39b7b2d2494c77.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="b7a0bd555d5aa736766109ff2a39b7b2d2494c77.diff"

diff --git a/frontend/Expression.cs b/frontend/Expression.cs
index b4ddbc0..424f9a7 100644
--- a/frontend/Expression.cs
+++ b/frontend/Expression.cs
@@ -1775,6 +1775,9 @@ namespace Mono.Debugger.Frontend
 						if (method.Name != name)
 							continue;
 
+						Console.WriteLine ("FOUND METHOD: {0} {1} {2}",
+								   stype, method, method.Type);
+
 						methods.Add (method.Type);
 						if (method.IsStatic)
 							is_static = true;
diff --git a/languages/mono/MonoGenericInstanceType.cs b/languages/mono/MonoGenericInstanceType.cs
index 9a16666..14a9b17 100644
--- a/languages/mono/MonoGenericInstanceType.cs
+++ b/languages/mono/MonoGenericInstanceType.cs
@@ -33,7 +33,7 @@ namespace Mono.Debugger.Languages.Mono
 			this.type_args = type_args;
 			this.class_ptr = class_ptr;
 
-			this.struct_type = new MonoStructType (container.File, container, container.Type);
+			this.struct_type = new MonoStructType (container.File, this, container.Type);
 
 			StringBuilder sb = new StringBuilder (container.BaseName);
 			sb.Append ('<');

--------------1.5.6--



From f6a6ee32c3f4a0956952ad202dfac954a645e9a7 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 15 Sep 2009 15:14:15 +0200
Subject: [PATCH] Move all members into MonoStructType.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 languages/mono/MonoClassType.cs  |   84 ++---------------------------------
 languages/mono/MonoMember.cs     |    6 +-
 languages/mono/MonoStructType.cs |   91 +++++++++++++++++++++++++++++++++++++-
 3 files changed, 98 insertions(+), 83 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="f6a6ee32c3f4a0956952ad202dfac954a645e9a7.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="f6a6ee32c3f4a0956952ad202dfac954a645e9a7.diff"

diff --git a/languages/mono/MonoClassType.cs b/languages/mono/MonoClassType.cs
index 21f9030..19e2849 100644
--- a/languages/mono/MonoClassType.cs
+++ b/languages/mono/MonoClassType.cs
@@ -35,12 +35,6 @@ namespace Mono.Debugger.Languages.Mono
 
 	internal class MonoClassType : TargetClassType, IMonoStructType
 	{
-		MonoFieldInfo[] fields;
-		MonoMethodInfo[] methods;
-		MonoPropertyInfo[] properties;
-		MonoEventInfo[] events;
-		MonoMethodInfo[] constructors;
-
 		Cecil.TypeDefinition type;
 		MonoSymbolFile file;
 		IMonoStructType parent_type;
@@ -171,41 +165,8 @@ namespace Mono.Debugger.Languages.Mono
 			get { return (int) (type.MetadataToken.TokenType + type.MetadataToken.RID); }
 		}
 
-		void get_fields ()
-		{
-			if (fields != null)
-				return;
-
-			fields = new MonoFieldInfo [type.Fields.Count];
-
-			for (int i = 0; i < fields.Length; i++) {
-				Cecil.FieldDefinition field = type.Fields [i];
-				TargetType ftype = File.MonoLanguage.LookupMonoType (field.FieldType);
-				fields [i] = new MonoFieldInfo (this, ftype, i, field);
-			}
-		}
-
 		public override TargetFieldInfo[] Fields {
-			get {
-				get_fields ();
-				return fields;
-			}
-		}
-
-		void get_properties ()
-		{
-			if (properties != null)
-				return;
-
-			properties = new MonoPropertyInfo [type.Properties.Count];
-
-			for (int i = 0; i < properties.Length; i++) {
-				Cecil.PropertyDefinition prop = type.Properties [i];
-				Cecil.MethodDefinition m = prop.GetMethod;
-				if (m == null) m = prop.SetMethod;
-
-				properties [i] = MonoPropertyInfo.Create (this, i, prop);
-			}
+			get { return struct_type.Fields; }
 		}
 
 		public override TargetMethodInfo[] Methods {
@@ -213,56 +174,21 @@ namespace Mono.Debugger.Languages.Mono
 		}
 
 		public override TargetPropertyInfo[] Properties {
-			get {
-				get_properties ();
-				return properties;
-			}
-		}
-
-		void get_events ()
-		{
-			if (events != null)
-				return;
-
-			events = new MonoEventInfo [type.Events.Count];
-
-			for (int i = 0; i < events.Length; i++) {
-				Cecil.EventDefinition ev = type.Events [i];
-				events [i] = MonoEventInfo.Create (this, i, ev);
-			}
+			get { return struct_type.Properties; }
 		}
 
 		public override TargetEventInfo[] Events {
-			get {
-				get_events ();
-				return events;
-			}
+			get { return struct_type.Events; }
 		}
 
 		public TargetObject GetStaticEvent (StackFrame frame, int index)
 		{
-			get_events ();
-			return null;
+			throw new NotImplementedException ();
 		}
 
-		void get_constructors ()
-		{
-			if (constructors != null)
-				return;
-
-			constructors = new MonoMethodInfo [type.Constructors.Count];
-
-			for (int i = 0; i < constructors.Length; i++) {
-				Cecil.MethodDefinition method = type.Constructors [i];
-				constructors [i] = MonoMethodInfo.Create (this, i, method);
-			}
-		}
 
 		public override TargetMethodInfo[] Constructors {
-			get {
-				get_constructors ();
-				return constructors;
-			}
+			get { return struct_type.Constructors; }
 		}
 
 		internal override TargetClass GetClass (TargetMemoryAccess target)
diff --git a/languages/mono/MonoMember.cs b/languages/mono/MonoMember.cs
index 17a2453..fe2be12 100644
--- a/languages/mono/MonoMember.cs
+++ b/languages/mono/MonoMember.cs
@@ -133,10 +133,10 @@ namespace Mono.Debugger.Languages.Mono
 	[Serializable]
 	internal class MonoEventInfo : TargetEventInfo
 	{
-		public readonly MonoClassType Klass;
+		public readonly IMonoStructType Klass;
 		public readonly MonoFunctionType AddType, RemoveType, RaiseType;
 
-		private MonoEventInfo (MonoClassType klass, int index, Cecil.EventDefinition einfo,
+		private MonoEventInfo (IMonoStructType klass, int index, Cecil.EventDefinition einfo,
 				       TargetType type, bool is_static,
 				       TargetMemberAccessibility accessibility, MonoFunctionType add,
 				       MonoFunctionType remove, MonoFunctionType raise)
@@ -148,7 +148,7 @@ namespace Mono.Debugger.Languages.Mono
 			this.RaiseType = raise;
 		}
 
-		internal static MonoEventInfo Create (MonoClassType klass, int index,
+		internal static MonoEventInfo Create (IMonoStructType klass, int index,
 						      Cecil.EventDefinition einfo)
 		{
 			TargetType type = klass.File.MonoLanguage.LookupMonoType (einfo.EventType);
diff --git a/languages/mono/MonoStructType.cs b/languages/mono/MonoStructType.cs
index 48aad1b..41b86f6 100644
--- a/languages/mono/MonoStructType.cs
+++ b/languages/mono/MonoStructType.cs
@@ -45,9 +45,57 @@ namespace Mono.Debugger.Languages.Mono
 			return null;
 		}
 
-		TargetMethodInfo[] methods;
+		MonoFieldInfo[] fields;
+		MonoPropertyInfo[] properties;
+		MonoEventInfo[] events;
+		MonoMethodInfo[] methods;
+		MonoMethodInfo[] constructors;
+
 		Dictionary<Cecil.MethodDefinition,MonoFunctionType> function_hash;
 
+		void get_fields ()
+		{
+			if (fields != null)
+				return;
+
+			fields = new MonoFieldInfo [TypeDef.Fields.Count];
+
+			for (int i = 0; i < fields.Length; i++) {
+				Cecil.FieldDefinition field = TypeDef.Fields [i];
+				TargetType ftype = File.MonoLanguage.LookupMonoType (field.FieldType);
+				fields [i] = new MonoFieldInfo (this, ftype, i, field);
+			}
+		}
+
+		void get_properties ()
+		{
+			if (properties != null)
+				return;
+
+			properties = new MonoPropertyInfo [TypeDef.Properties.Count];
+
+			for (int i = 0; i < properties.Length; i++) {
+				Cecil.PropertyDefinition prop = TypeDef.Properties [i];
+				Cecil.MethodDefinition m = prop.GetMethod;
+				if (m == null) m = prop.SetMethod;
+
+				properties [i] = MonoPropertyInfo.Create (this, i, prop);
+			}
+		}
+
+		void get_events ()
+		{
+			if (events != null)
+				return;
+
+			events = new MonoEventInfo [TypeDef.Events.Count];
+
+			for (int i = 0; i < events.Length; i++) {
+				Cecil.EventDefinition ev = TypeDef.Events [i];
+				events [i] = MonoEventInfo.Create (this, i, ev);
+			}
+		}
+
 		void get_methods ()
 		{
 			if (methods != null)
@@ -74,6 +122,19 @@ namespace Mono.Debugger.Languages.Mono
 			}
 		}
 
+		void get_constructors ()
+		{
+			if (constructors != null)
+				return;
+
+			constructors = new MonoMethodInfo [TypeDef.Constructors.Count];
+
+			for (int i = 0; i < constructors.Length; i++) {
+				Cecil.MethodDefinition method = TypeDef.Constructors [i];
+				constructors [i] = MonoMethodInfo.Create (this, i, method);
+			}
+		}
+
 		public TargetMethodInfo[] Methods {
 			get {
 				get_methods ();
@@ -81,6 +142,34 @@ namespace Mono.Debugger.Languages.Mono
 			}
 		}
 
+		public TargetFieldInfo[] Fields {
+			get {
+				get_fields ();
+				return fields;
+			}
+		}
+
+		public TargetPropertyInfo[] Properties {
+			get {
+				get_properties ();
+				return properties;
+			}
+		}
+
+		public TargetEventInfo[] Events {
+			get {
+				get_events ();
+				return events;
+			}
+		}
+
+		public TargetMethodInfo[] Constructors {
+			get {
+				get_constructors ();
+				return constructors;
+			}
+		}
+
 		public MonoFunctionType LookupFunction (Cecil.MethodDefinition mdef)
 		{
 			get_methods ();

--------------1.5.6--



From 29258a1890e236cfcccb492d1fa80b3f53b2d623 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 15 Sep 2009 15:18:27 +0200
Subject: [PATCH] Move everything into TargetClassType.
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 languages/TargetClassType.cs              |   53 -------------------------
 languages/TargetStructType.cs             |   61 +++++++++++++++++++++++++++++
 languages/mono/MonoClassType.cs           |   16 ++++----
 languages/mono/MonoGenericInstanceType.cs |   22 ++++++++++-
 4 files changed, 90 insertions(+), 62 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="29258a1890e236cfcccb492d1fa80b3f53b2d623.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="29258a1890e236cfcccb492d1fa80b3f53b2d623.diff"

diff --git a/languages/TargetClassType.cs b/languages/TargetClassType.cs
index 3cad62d..e006d80 100644
--- a/languages/TargetClassType.cs
+++ b/languages/TargetClassType.cs
@@ -5,58 +5,5 @@ namespace Mono.Debugger.Languages
 		protected TargetClassType (Language language, TargetObjectKind kind)
 			: base (language, kind)
 		{ }
-
-		public abstract bool IsCompilerGenerated {
-			get;
-		}
-
-		public abstract TargetFieldInfo[] Fields {
-			get;
-		}
-
-		public abstract TargetPropertyInfo[] Properties {
-			get;
-		}
-
-		public abstract TargetEventInfo[] Events {
-			get;
-		}
-
-		public abstract TargetMethodInfo[] Constructors {
-			get;
-		}
-
-		public virtual TargetMemberInfo FindMember (string name, bool search_static,
-							    bool search_instance)
-		{
-			foreach (TargetFieldInfo field in Fields) {
-				if (field.IsStatic && !search_static)
-					continue;
-				if (!field.IsStatic && !search_instance)
-					continue;
-				if (field.Name == name)
-					return field;
-			}
-
-			foreach (TargetPropertyInfo property in Properties) {
-				if (property.IsStatic && !search_static)
-					continue;
-				if (!property.IsStatic && !search_instance)
-					continue;
-				if (property.Name == name)
-					return property;
-			}
-
-			foreach (TargetEventInfo ev in Events) {
-				if (ev.IsStatic && !search_static)
-					continue;
-				if (!ev.IsStatic && !search_instance)
-					continue;
-				if (ev.Name == name)
-					return ev;
-			}
-
-			return null;
-		}
 	}
 }
diff --git a/languages/TargetStructType.cs b/languages/TargetStructType.cs
index 1067558..10b1472 100644
--- a/languages/TargetStructType.cs
+++ b/languages/TargetStructType.cs
@@ -21,10 +21,69 @@ namespace Mono.Debugger.Languages
 			get;
 		}
 
+		#region Members
+
 		public abstract TargetMethodInfo[] Methods {
 			get;
 		}
 
+		public abstract TargetMethodInfo[] Constructors {
+			get;
+		}
+
+		public abstract TargetFieldInfo[] Fields {
+			get;
+		}
+
+		public abstract TargetPropertyInfo[] Properties {
+			get;
+		}
+
+		public abstract TargetEventInfo[] Events {
+			get;
+		}
+
+		public virtual TargetMemberInfo FindMember (string name, bool search_static,
+							    bool search_instance)
+		{
+			foreach (TargetFieldInfo field in Fields) {
+				if (field.IsStatic && !search_static)
+					continue;
+				if (!field.IsStatic && !search_instance)
+					continue;
+				if (field.Name == name)
+					return field;
+			}
+
+			foreach (TargetPropertyInfo property in Properties) {
+				if (property.IsStatic && !search_static)
+					continue;
+				if (!property.IsStatic && !search_instance)
+					continue;
+				if (property.Name == name)
+					return property;
+			}
+
+			foreach (TargetEventInfo ev in Events) {
+				if (ev.IsStatic && !search_static)
+					continue;
+				if (!ev.IsStatic && !search_instance)
+					continue;
+				if (ev.Name == name)
+					return ev;
+			}
+
+			return null;
+		}
+
+		#endregion
+
+		#region Debuggable Attributes
+
+		public abstract bool IsCompilerGenerated {
+			get;
+		}
+
 		public virtual DebuggerDisplayAttribute DebuggerDisplayAttribute {
 			get { return null; }
 		}
@@ -33,6 +92,8 @@ namespace Mono.Debugger.Languages
 			get { return null; }
 		}
 
+		#endregion
+
 		internal abstract TargetStructType GetParentType (TargetMemoryAccess target);
 
 		public TargetStructType GetParentType (Thread thread)
diff --git a/languages/mono/MonoClassType.cs b/languages/mono/MonoClassType.cs
index 19e2849..77ccbd5 100644
--- a/languages/mono/MonoClassType.cs
+++ b/languages/mono/MonoClassType.cs
@@ -165,14 +165,18 @@ namespace Mono.Debugger.Languages.Mono
 			get { return (int) (type.MetadataToken.TokenType + type.MetadataToken.RID); }
 		}
 
-		public override TargetFieldInfo[] Fields {
-			get { return struct_type.Fields; }
-		}
-
 		public override TargetMethodInfo[] Methods {
 			get { return struct_type.Methods; }
 		}
 
+		public override TargetMethodInfo[] Constructors {
+			get { return struct_type.Constructors; }
+		}
+
+		public override TargetFieldInfo[] Fields {
+			get { return struct_type.Fields; }
+		}
+
 		public override TargetPropertyInfo[] Properties {
 			get { return struct_type.Properties; }
 		}
@@ -187,10 +191,6 @@ namespace Mono.Debugger.Languages.Mono
 		}
 
 
-		public override TargetMethodInfo[] Constructors {
-			get { return struct_type.Constructors; }
-		}
-
 		internal override TargetClass GetClass (TargetMemoryAccess target)
 		{
 			return ResolveClass (target, false);
diff --git a/languages/mono/MonoGenericInstanceType.cs b/languages/mono/MonoGenericInstanceType.cs
index 14a9b17..98cde45 100644
--- a/languages/mono/MonoGenericInstanceType.cs
+++ b/languages/mono/MonoGenericInstanceType.cs
@@ -16,6 +16,7 @@ namespace Mono.Debugger.Languages.Mono
 		public readonly MonoClassType Container;
 		DebuggerDisplayAttribute debugger_display;
 		DebuggerTypeProxyAttribute type_proxy;
+		bool is_compiler_generated;
 		TargetType[] type_args;
 		TargetAddress class_ptr;
 		MonoClassInfo class_info;
@@ -47,7 +48,6 @@ namespace Mono.Debugger.Languages.Mono
 
 			Console.WriteLine ("GENERIC INSTANCE TYPE: {0} {1} {2}", container, full_name, class_ptr);
 
-			bool is_compiler_generated;
 			DebuggerBrowsableState? browsable_state;
 			MonoSymbolFile.CheckCustomAttributes (container.Type,
 							      out browsable_state,
@@ -108,6 +108,10 @@ namespace Mono.Debugger.Languages.Mono
 			get { return true; }
 		}
 
+		public override bool IsCompilerGenerated {
+			get { return is_compiler_generated; }
+		}
+
 		public override DebuggerDisplayAttribute DebuggerDisplayAttribute {
 			get { return debugger_display; }
 		}
@@ -213,6 +217,22 @@ namespace Mono.Debugger.Languages.Mono
 			get { return struct_type.Methods; }
 		}
 
+		public override TargetMethodInfo[] Constructors {
+			get { return struct_type.Constructors; }
+		}
+
+		public override TargetFieldInfo[] Fields {
+			get { return struct_type.Fields; }
+		}
+
+		public override TargetPropertyInfo[] Properties {
+			get { return struct_type.Properties; }
+		}
+
+		public override TargetEventInfo[] Events {
+			get { return struct_type.Events; }
+		}
+
 		#endregion
 
 	}

--------------1.5.6--



From 667da3df6383e6a5fa732b2d2d740900bee929bd Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 15 Sep 2009 18:18:06 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/mono/MonoRuntime.cs               |  700 -----------------------------
 languages/mono/MonoGenericInstanceType.cs |   25 -
 2 files changed, 0 insertions(+), 725 deletions(-)
 delete mode 100644 backend/mono/MonoRuntime.cs
--------------1.5.6
Content-Type: text/x-patch; name="667da3df6383e6a5fa732b2d2d740900bee929bd.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="667da3df6383e6a5fa732b2d2d740900bee929bd.diff"

diff --git a/backend/mono/MonoRuntime.cs b/backend/mono/MonoRuntime.cs
deleted file mode 100644
index d2f6add..0000000
--- a/backend/mono/MonoRuntime.cs
+++ /dev/null
@@ -1,700 +0,0 @@
-using System;
-
-using Mono.Debugger.Languages;
-using Mono.Debugger.Languages.Mono;
-
-namespace Mono.Debugger.Backend.Mono
-{
-	internal enum MonoTypeEnum
-	{
-		MONO_TYPE_END        = 0x00,       /* End of List */
-		MONO_TYPE_VOID       = 0x01,
-		MONO_TYPE_BOOLEAN    = 0x02,
-		MONO_TYPE_CHAR       = 0x03,
-		MONO_TYPE_I1         = 0x04,
-		MONO_TYPE_U1         = 0x05,
-		MONO_TYPE_I2         = 0x06,
-		MONO_TYPE_U2         = 0x07,
-		MONO_TYPE_I4         = 0x08,
-		MONO_TYPE_U4         = 0x09,
-		MONO_TYPE_I8         = 0x0a,
-		MONO_TYPE_U8         = 0x0b,
-		MONO_TYPE_R4         = 0x0c,
-		MONO_TYPE_R8         = 0x0d,
-		MONO_TYPE_STRING     = 0x0e,
-		MONO_TYPE_PTR        = 0x0f,       /* arg: <type> token */
-		MONO_TYPE_BYREF      = 0x10,       /* arg: <type> token */
-		MONO_TYPE_VALUETYPE  = 0x11,       /* arg: <type> token */
-		MONO_TYPE_CLASS      = 0x12,       /* arg: <type> token */
-		MONO_TYPE_VAR	     = 0x13,	   /* number */
-		MONO_TYPE_ARRAY      = 0x14,       /* type, rank, boundsCount, bound1, loCount, lo1 */
-		MONO_TYPE_GENERICINST= 0x15,	   /* <type> <type-arg-count> <type-1> \x{2026} <type-n> */
-		MONO_TYPE_TYPEDBYREF = 0x16,
-		MONO_TYPE_I          = 0x18,
-		MONO_TYPE_U          = 0x19,
-		MONO_TYPE_FNPTR      = 0x1b,	      /* arg: full method signature */
-		MONO_TYPE_OBJECT     = 0x1c,
-		MONO_TYPE_SZARRAY    = 0x1d,       /* 0-based one-dim-array */
-		MONO_TYPE_MVAR	     = 0x1e,       /* number */
-		MONO_TYPE_CMOD_REQD  = 0x1f,       /* arg: typedef or typeref token */
-		MONO_TYPE_CMOD_OPT   = 0x20,       /* optional arg: typedef or typref token */
-		MONO_TYPE_INTERNAL   = 0x21,       /* CLR internal type */
-
-		MONO_TYPE_MODIFIER   = 0x40,       /* Or with the following types */
-		MONO_TYPE_SENTINEL   = 0x41,       /* Sentinel for varargs method signature */
-		MONO_TYPE_PINNED     = 0x45,       /* Local var that points to pinned object */
-
-		MONO_TYPE_ENUM       = 0x55        /* an enumeration */
-	}
-
-	internal class MonoRuntime : DebuggerMarshalByRefObject
-	{
-		protected readonly MonoDebuggerInfo MonoDebuggerInfo;
-		protected readonly MetadataInfo MonoMetadataInfo;
-
-		protected MonoRuntime (MonoDebuggerInfo info, MetadataInfo metadata)
-		{
-			this.MonoDebuggerInfo = info;
-			this.MonoMetadataInfo = metadata;
-		}
-
-		public static MonoRuntime Create (TargetMemoryAccess memory, MonoDebuggerInfo info)
-		{
-			MetadataInfo metadata = new MetadataInfo (memory, info.MonoMetadataInfo);
-			return new MonoRuntime (info, metadata);
-		}
-
-		//
-		// MonoClass
-		//
-
-		public TargetAddress MonoClassGetMonoImage (TargetMemoryAccess memory,
-							    TargetAddress klass)
-		{
-			return memory.ReadAddress (klass + MonoMetadataInfo.KlassImageOffset);
-		}
-
-		public int MonoClassGetToken (TargetMemoryAccess memory,
-					      TargetAddress klass)
-		{
-			return memory.ReadInteger (klass + MonoMetadataInfo.KlassTokenOffset);
-		}
-
-		public int MonoClassGetInstanceSize (TargetMemoryAccess memory,
-						     TargetAddress klass)
-		{
-			int flags = memory.ReadInteger (klass + 4 * memory.TargetAddressSize);
-
-			bool size_inited = (flags & 4) != 0;
-			bool valuetype = (flags & 8) != 0;
-
-			if (!size_inited)
-				throw new TargetException (TargetError.ClassNotInitialized);
-
-			int size = memory.ReadInteger (klass + 4 + 3 * memory.TargetAddressSize);
-			if (valuetype)
-				size -= 2 * memory.TargetAddressSize;
-
-			return size;
-		}
-
-		public TargetAddress MonoClassGetParent (TargetMemoryAccess memory,
-							 TargetAddress klass)
-		{
-			return memory.ReadAddress (klass + MonoMetadataInfo.KlassParentOffset);
-		}
-
-		public TargetAddress MonoClassGetGenericClass (TargetMemoryAccess memory,
-							       TargetAddress klass)
-		{
-			return memory.ReadAddress (klass + MonoMetadataInfo.KlassGenericClassOffset);
-		}
-
-		public TargetAddress MonoClassGetGenericContainer (TargetMemoryAccess memory,
-								   TargetAddress klass)
-		{
-			return memory.ReadAddress (klass + MonoMetadataInfo.KlassGenericContainerOffset);
-		}
-
-		public TargetAddress MonoClassGetByValType (TargetMemoryAccess memory,
-							    TargetAddress klass)
-		{
-			return klass + MonoMetadataInfo.KlassByValArgOffset;
-		}
-
-		public bool MonoClassHasFields (TargetMemoryAccess memory, TargetAddress klass)
-		{
-			TargetAddress fields = memory.ReadAddress (
-				klass + MonoMetadataInfo.KlassFieldOffset);
-			return !fields.IsNull;
-		}
-
-		public int MonoClassGetFieldCount (TargetMemoryAccess memory, TargetAddress klass)
-		{
-			return memory.ReadInteger (klass + MonoMetadataInfo.KlassFieldCountOffset);
-		}
-
-		public TargetAddress MonoClassGetFieldType (TargetMemoryAccess memory, TargetAddress klass,
-							    int index)
-		{
-			int offset = index * MonoMetadataInfo.FieldInfoSize +
-				MonoMetadataInfo.FieldInfoTypeOffset;
-
-			TargetAddress fields = memory.ReadAddress (
-				klass + MonoMetadataInfo.KlassFieldOffset);
-			if (fields.IsNull)
-				throw new TargetException (TargetError.ClassNotInitialized);
-
-			return memory.ReadAddress (fields + offset);
-		}
-
-		public int MonoClassGetFieldOffset (TargetMemoryAccess memory, TargetAddress klass,
-						    int index)
-		{
-			int offset = index * MonoMetadataInfo.FieldInfoSize +
-				MonoMetadataInfo.FieldInfoOffsetOffset;
-
-			TargetAddress fields = memory.ReadAddress (
-				klass + MonoMetadataInfo.KlassFieldOffset);
-			if (fields.IsNull)
-				throw new TargetException (TargetError.ClassNotInitialized);
-
-			return memory.ReadInteger (fields + offset);
-		}
-
-		public bool MonoClassHasMethods (TargetMemoryAccess memory, TargetAddress klass)
-		{
-			TargetAddress methods = memory.ReadAddress (
-				klass + MonoMetadataInfo.KlassMethodsOffset);
-			return !methods.IsNull;
-		}
-
-		public int MonoClassGetMethodCount (TargetMemoryAccess memory, TargetAddress klass)
-		{
-			return memory.ReadInteger (klass + MonoMetadataInfo.KlassMethodCountOffset);
-		}
-
-		public TargetAddress MonoClassGetMethod (TargetMemoryAccess memory, TargetAddress klass,
-							 int index)
-		{
-			TargetAddress methods = memory.ReadAddress (
-				klass + MonoMetadataInfo.KlassMethodsOffset);
-
-			if (methods.IsNull)
-				throw new TargetException (TargetError.ClassNotInitialized);
-
-			methods += index * memory.TargetAddressSize;
-			return memory.ReadAddress (methods);
-		}
-
-		//
-		// MonoMethod
-		//
-
-		public int MonoMethodGetToken (TargetMemoryAccess memory, TargetAddress method)
-		{
-			return memory.ReadInteger (method + MonoMetadataInfo.MonoMethodTokenOffset);
-		}
-
-		public TargetAddress MonoMethodGetClass (TargetMemoryAccess memory, TargetAddress method)
-		{
-			return memory.ReadAddress (method + MonoMetadataInfo.MonoMethodKlassOffset);
-		}
-
-		//
-		// MonoType
-		//
-
-		public MonoTypeEnum MonoTypeGetType (TargetMemoryAccess memory, TargetAddress type)
-		{
-			uint flags = (uint) memory.ReadInteger (
-				type + memory.TargetMemoryInfo.TargetAddressSize);
-
-			return (MonoTypeEnum) ((flags & 0x00ff0000) >> 16);
-		}
-
-		public bool MonoTypeGetIsByRef (TargetMemoryAccess memory, TargetAddress type)
-		{
-			uint flags = (uint) memory.ReadInteger (
-				type + memory.TargetMemoryInfo.TargetAddressSize);
-			return (int) ((flags & 0x40000000) >> 30) != 0;
-		}
-
-		public TargetAddress MonoTypeGetData (TargetMemoryAccess memory, TargetAddress type)
-		{
-			return memory.ReadAddress (type);
-		}
-
-		public TargetAddress MonoArrayTypeGetClass (TargetMemoryAccess memory,
-							    TargetAddress atype)
-		{
-			return memory.ReadAddress (atype);
-		}
-
-		public int MonoArrayTypeGetRank (TargetMemoryAccess memory,
-						 TargetAddress atype)
-		{
-			return memory.ReadByte (atype + memory.TargetAddressSize);
-		}
-
-		public int MonoArrayTypeGetNumSizes (TargetMemoryAccess memory,
-						     TargetAddress atype)
-		{
-			return memory.ReadByte (atype + memory.TargetAddressSize + 1);
-		}
-
-		public int MonoArrayTypeGetNumLoBounds (TargetMemoryAccess memory,
-							TargetAddress atype)
-		{
-			return memory.ReadByte (atype + memory.TargetAddressSize + 2);
-		}
-
-		internal void MonoArrayTypeGetBounds (TargetMemoryAccess memory,
-						      TargetAddress data)
-		{
-			//
-			// FIXME: Only check whether the low bounds are all zero
-			//
-			int num_sizes = memory.ReadByte (data + memory.TargetAddressSize + 1);
-			if (num_sizes != 0)
-				throw new InternalError ();
-
-			int num_lobounds = memory.ReadByte (data + memory.TargetAddressSize + 2);
-			if (num_lobounds == 0)
-				return;
-
-			TargetAddress array = memory.ReadAddress (data + 3 * memory.TargetAddressSize);
-			TargetBinaryReader bounds = memory.ReadMemory (array, num_lobounds * 4).GetReader ();
-			for (int i = 0; i < num_lobounds; i++) {
-				int bound = bounds.ReadInt32 ();
-				if (bound != 0)
-					throw new InternalError ();
-			}
-		}
-
-		//
-		// Fundamental types
-		//
-
-		public TargetAddress GetBooleanClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsBooleanOffset);
-		}
-
-		public TargetAddress GetCharClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsCharOffset);
-		}
-
-		public TargetAddress GetSByteClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsSByteOffset);
-		}
-
-		public TargetAddress GetByteClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsByteOffset);
-		}
-
-		public TargetAddress GetInt16Class (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsInt16Offset);
-		}
-
-		public TargetAddress GetUInt16Class (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsUInt16Offset);
-		}
-
-		public TargetAddress GetInt32Class (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsInt32Offset);
-		}
-
-		public TargetAddress GetUInt32Class (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsUInt32Offset);
-		}
-
-		public TargetAddress GetInt64Class (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsInt64Offset);
-		}
-
-		public TargetAddress GetUInt64Class (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsUInt64Offset);
-		}
-
-		public TargetAddress GetSingleClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsSingleOffset);
-		}
-
-		public TargetAddress GetDoubleClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsDoubleOffset);
-		}
-
-		public TargetAddress GetIntPtrClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsIntOffset);
-		}
-
-		public TargetAddress GetUIntPtrClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsUIntOffset);
-		}
-
-		public TargetAddress GetVoidClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsVoidOffset);
-		}
-
-		public TargetAddress GetStringClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsStringOffset);
-		}
-
-		public TargetAddress GetObjectClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsObjectOffset);
-		}
-
-		public TargetAddress GetArrayClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsArrayOffset);
-		}
-
-		public TargetAddress GetDelegateClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsDelegateOffset);
-		}
-
-		public TargetAddress GetExceptionClass (TargetMemoryAccess memory)
-		{
-			return memory.ReadAddress (MonoMetadataInfo.MonoDefaultsAddress +
-						   MonoMetadataInfo.MonoDefaultsExceptionOffset);
-		}
-
-		public MonoMethodSignature GetMethodSignature (MonoLanguageBackend mono,
-							       TargetMemoryAccess memory,
-							       TargetAddress signature)
-		{
-			int count = memory.ReadInteger (signature + 4) & 0x0000ffff;
-
-			int offset = memory.TargetAddressSize == 8 ? 16 : 12;
-			TargetAddress ret = memory.ReadAddress (signature + offset);
-
-			TargetType ret_type = mono.ReadType (memory, ret);
-			if (count == 0)
-				return new MonoMethodSignature (ret_type, new TargetType [0]);
-
-			offset += memory.TargetAddressSize;
-			TargetReader reader = new TargetReader (
-				memory.ReadMemory (signature + offset, count * memory.TargetAddressSize));
-
-			TargetType[] param_types = new TargetType [count];
-			for (int i = 0; i < count; i++)
-				param_types [i] = mono.ReadType (memory, reader.ReadAddress ());
-
-			return new MonoMethodSignature (ret_type, param_types);
-		}
-
-		protected class MetadataInfo
-		{
-			public readonly int MonoDefaultsSize;
-			public readonly TargetAddress MonoDefaultsAddress;
-			public readonly int TypeSize;
-			public readonly int ArrayTypeSize;
-			public readonly int KlassSize;
-			public readonly int ThreadSize;
-
-			public readonly int ThreadTidOffset;
-			public readonly int ThreadStackPtrOffset;
-			public readonly int ThreadEndStackOffset;
-
-			public readonly int KlassImageOffset;
-			public readonly int KlassInstanceSizeOffset;
-			public readonly int KlassParentOffset;
-			public readonly int KlassTokenOffset;
-			public readonly int KlassFieldOffset;
-			public readonly int KlassFieldCountOffset;
-			public readonly int KlassMethodsOffset;
-			public readonly int KlassMethodCountOffset;
-			public readonly int KlassThisArgOffset;
-			public readonly int KlassByValArgOffset;
-			public readonly int KlassGenericClassOffset;
-			public readonly int KlassGenericContainerOffset;
-			public readonly int KlassVTableOffset;
-			public readonly int FieldInfoSize;
-			public readonly int FieldInfoTypeOffset;
-			public readonly int FieldInfoOffsetOffset;
-
-			public readonly int MonoDefaultsCorlibOffset;
-			public readonly int MonoDefaultsObjectOffset;
-			public readonly int MonoDefaultsByteOffset;
-			public readonly int MonoDefaultsVoidOffset;
-			public readonly int MonoDefaultsBooleanOffset;
-			public readonly int MonoDefaultsSByteOffset;
-			public readonly int MonoDefaultsInt16Offset;
-			public readonly int MonoDefaultsUInt16Offset;
-			public readonly int MonoDefaultsInt32Offset;
-			public readonly int MonoDefaultsUInt32Offset;
-			public readonly int MonoDefaultsIntOffset;
-			public readonly int MonoDefaultsUIntOffset;
-			public readonly int MonoDefaultsInt64Offset;
-			public readonly int MonoDefaultsUInt64Offset;
-			public readonly int MonoDefaultsSingleOffset;
-			public readonly int MonoDefaultsDoubleOffset;
-			public readonly int MonoDefaultsCharOffset;
-			public readonly int MonoDefaultsStringOffset;
-			public readonly int MonoDefaultsEnumOffset;
-			public readonly int MonoDefaultsArrayOffset;
-			public readonly int MonoDefaultsDelegateOffset;
-			public readonly int MonoDefaultsExceptionOffset;
-
-			public readonly int MonoMethodKlassOffset;
-			public readonly int MonoMethodTokenOffset;
-			public readonly int MonoMethodFlagsOffset;
-			public readonly int MonoMethodInflatedOffset;
-
-			public readonly int MonoVTableKlassOffset;
-			public readonly int MonoVTableVTableOffset;
-
-			public MetadataInfo (TargetMemoryAccess memory, TargetAddress address)
-			{
-				int size = memory.ReadInteger (address);
-				TargetBinaryReader reader = memory.ReadMemory (address, size).GetReader ();
-				reader.ReadInt32 ();
-
-				MonoDefaultsSize = reader.ReadInt32 ();
-				MonoDefaultsAddress = new TargetAddress (
-					memory.AddressDomain, reader.ReadAddress ());
-
-				TypeSize = reader.ReadInt32 ();
-				ArrayTypeSize = reader.ReadInt32 ();
-				KlassSize = reader.ReadInt32 ();
-				ThreadSize = reader.ReadInt32 ();
-
-				ThreadTidOffset = reader.ReadInt32 ();
-				ThreadStackPtrOffset = reader.ReadInt32 ();
-				ThreadEndStackOffset = reader.ReadInt32 ();
-
-				KlassImageOffset = reader.ReadInt32 ();
-				KlassInstanceSizeOffset = reader.ReadInt32 ();
-				KlassParentOffset = reader.ReadInt32 ();
-				KlassTokenOffset = reader.ReadInt32 ();
-				KlassFieldOffset = reader.ReadInt32 ();
-				KlassMethodsOffset = reader.ReadInt32 ();
-				KlassMethodCountOffset = reader.ReadInt32 ();
-				KlassThisArgOffset = reader.ReadInt32 ();
-				KlassByValArgOffset = reader.ReadInt32 ();
-				KlassGenericClassOffset = reader.ReadInt32 ();
-				KlassGenericContainerOffset = reader.ReadInt32 ();
-				KlassVTableOffset = reader.ReadInt32 ();
-
-				FieldInfoSize = reader.ReadInt32 ();
-				FieldInfoTypeOffset = reader.ReadInt32 ();
-				FieldInfoOffsetOffset = reader.ReadInt32 ();
-
-				KlassFieldCountOffset = KlassMethodCountOffset - 8;
-
-				MonoDefaultsCorlibOffset = reader.ReadInt32 ();
-				MonoDefaultsObjectOffset = reader.ReadInt32 ();
-				MonoDefaultsByteOffset = reader.ReadInt32 ();
-				MonoDefaultsVoidOffset = reader.ReadInt32 ();
-				MonoDefaultsBooleanOffset = reader.ReadInt32 ();
-				MonoDefaultsSByteOffset = reader.ReadInt32 ();
-				MonoDefaultsInt16Offset = reader.ReadInt32 ();
-				MonoDefaultsUInt16Offset = reader.ReadInt32 ();
-				MonoDefaultsInt32Offset = reader.ReadInt32 ();
-				MonoDefaultsUInt32Offset = reader.ReadInt32 ();
-				MonoDefaultsIntOffset = reader.ReadInt32 ();
-				MonoDefaultsUIntOffset = reader.ReadInt32 ();
-				MonoDefaultsInt64Offset = reader.ReadInt32 ();
-				MonoDefaultsUInt64Offset = reader.ReadInt32 ();
-				MonoDefaultsSingleOffset = reader.ReadInt32 ();
-				MonoDefaultsDoubleOffset = reader.ReadInt32 ();
-				MonoDefaultsCharOffset = reader.ReadInt32 ();
-				MonoDefaultsStringOffset = reader.ReadInt32 ();
-				MonoDefaultsEnumOffset = reader.ReadInt32 ();
-				MonoDefaultsArrayOffset = reader.ReadInt32 ();
-				MonoDefaultsDelegateOffset = reader.ReadInt32 ();
-				MonoDefaultsExceptionOffset = reader.ReadInt32 ();
-
-				MonoMethodKlassOffset = reader.ReadInt32 ();
-				MonoMethodTokenOffset = reader.ReadInt32 ();
-				MonoMethodFlagsOffset = reader.ReadInt32 ();
-				MonoMethodInflatedOffset = reader.ReadInt32 ();
-
-				MonoVTableKlassOffset = reader.ReadInt32 ();
-				MonoVTableVTableOffset = reader.ReadInt32 ();
-			}
-		}
-
-		//
-		// The following API is new in `terrania'.
-		//
-
-		public GenericClassInfo GetGenericClass (TargetMemoryAccess memory,
-							 TargetAddress address)
-		{
-			int addr_size = memory.TargetMemoryInfo.TargetAddressSize;
-
-			TargetReader reader = new TargetReader (memory.ReadMemory (address, 5 * addr_size));
-			TargetAddress container = reader.ReadAddress ();
-			TargetAddress class_inst = reader.ReadAddress ();
-			reader.ReadAddress (); /* method_inst */
-			reader.ReadAddress ();
-			TargetAddress cached_class = reader.ReadAddress ();
-
-			int inst_id = memory.ReadInteger (class_inst);
-			int inst_data = memory.ReadInteger (class_inst + 4);
-
-			TargetAddress inst_argv;
-			if (MonoDebuggerInfo.MajorVersion == 80)
-				inst_argv = memory.ReadAddress (class_inst + 8);
-			else
-				inst_argv = class_inst + 8;
-
-			int type_argc = inst_data & 0x3fffff;
-
-			TargetReader argv_reader = new TargetReader (
-				memory.ReadMemory (inst_argv, type_argc * addr_size));
-
-			TargetAddress[] type_args = new TargetAddress [type_argc];
-			for (int i = 0; i < type_argc; i++)
-				type_args [i] = argv_reader.ReadAddress ();
-
-			TargetAddress cached_class_ptr = address + 4 * addr_size;
-
-			return new GenericClassInfo (container, type_args, cached_class_ptr,
-						     cached_class);
-		}
-
-		public class GenericClassInfo
-		{
-			/* `MonoClass *' of the container class. */
-			public readonly TargetAddress ContainerClass;
-
-			/* `MonoType *' array of the instantiation. */
-			public readonly TargetAddress[] TypeArguments;
-
-			/* `MonoClass *' of this instantiation, if present. */
-			public readonly TargetAddress KlassPtr;
-			public readonly TargetAddress Klass;
-
-			public GenericClassInfo (TargetAddress container, TargetAddress[] type_args,
-						 TargetAddress klass_ptr, TargetAddress klass)
-			{
-				this.ContainerClass = container;
-				this.TypeArguments = type_args;
-				this.KlassPtr = klass_ptr;
-				this.Klass = klass;
-			}
-		}
-
-		public GenericParamInfo GetGenericParameter (TargetMemoryAccess memory,
-							     TargetAddress address)
-		{
-			int addr_size = memory.TargetMemoryInfo.TargetAddressSize;
-
-			TargetReader reader = new TargetReader (
-				memory.ReadMemory (address, 4 * addr_size + 4));
-			TargetAddress container = reader.ReadAddress ();
-			TargetAddress klass = reader.ReadAddress ();
-			TargetAddress name_addr = reader.ReadAddress ();
-			reader.BinaryReader.ReadInt16 (); /* flags */
-			int pos = reader.BinaryReader.ReadInt16 ();
-
-			string name;
-			if (!name_addr.IsNull)
-				name = memory.ReadString (name_addr);
-			else
-				name = String.Format ("!{0}", pos);
-
-			return new GenericParamInfo (container, klass, name, pos);
-		}
-
-		public class GenericParamInfo
-		{
-			public readonly TargetAddress Container;
-			public readonly TargetAddress Klass;
-			public readonly string Name;
-			public readonly int Position;
-
-			public GenericParamInfo (TargetAddress container, TargetAddress klass,
-						 string name, int pos)
-			{
-				this.Container = container;
-				this.Klass = klass;
-				this.Name = name;
-				this.Position = pos;
-			}
-		}
-
-		public AppDomainInfo GetAppDomainInfo (MonoLanguageBackend mono, TargetMemoryAccess memory,
-						       TargetAddress address)
-		{
-			int addr_size = memory.TargetMemoryInfo.TargetAddressSize;
-			TargetReader reader = new TargetReader (memory.ReadMemory (address, 12 * addr_size));
-
-			return new AppDomainInfo (mono, memory, reader);
-		}
-
-		public class AppDomainInfo
-		{
-			public readonly string ApplicationBase;
-			public readonly string ApplicationName;
-			public readonly string CachePath;
-			public readonly string ConfigFile;
-			public readonly string DynamicBase;
-			public readonly string ShadowCopyDirectories;
-			public readonly bool ShadowCopyFiles;
-
-			public string ShadowCopyPath;
-
-			public AppDomainInfo (MonoLanguageBackend mono, TargetMemoryAccess memory, TargetReader reader)
-			{
-				int addr_size = memory.TargetMemoryInfo.TargetAddressSize;
-
-				reader.Offset = 2 * addr_size;
-				ApplicationBase = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
-				ApplicationName = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
-				CachePath = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
-				ConfigFile = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
-				DynamicBase = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
-				reader.Offset += 3 * addr_size;
-				ShadowCopyDirectories = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ());
-				ShadowCopyFiles = MonoStringObject.ReadString (mono, memory, reader.ReadAddress ()) == "true";
-			}
-
-			public override string ToString ()
-			{
-				return String.Format ("AppDomainInfo ({0}:{1}:{2}:{3}:{4}:{5}:{6})",
-						      ApplicationBase, ApplicationName, CachePath, ConfigFile,
-						      DynamicBase, ShadowCopyDirectories, ShadowCopyFiles);
-			}
-		}
-	}
-}
diff --git a/languages/mono/MonoGenericInstanceType.cs b/languages/mono/MonoGenericInstanceType.cs
index 59b7577..352a536 100644
--- a/languages/mono/MonoGenericInstanceType.cs
+++ b/languages/mono/MonoGenericInstanceType.cs
@@ -230,30 +230,5 @@ namespace Mono.Debugger.Languages.Mono
 		{
 			return struct_type.LookupFunction (mdef);
 		}
-
-		#region New Stuff
-
-		public override TargetMethodInfo[] Methods {
-			get { return struct_type.Methods; }
-		}
-
-		public override TargetMethodInfo[] Constructors {
-			get { return struct_type.Constructors; }
-		}
-
-		public override TargetFieldInfo[] Fields {
-			get { return struct_type.Fields; }
-		}
-
-		public override TargetPropertyInfo[] Properties {
-			get { return struct_type.Properties; }
-		}
-
-		public override TargetEventInfo[] Events {
-			get { return struct_type.Events; }
-		}
-
-		#endregion
-
 	}
 }

--------------1.5.6--



From 7a30b6683b4920559b474fe36e5d738edc94c468 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 15 Sep 2009 18:22:02 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs                    |    4 ++--
 backend/mono/MonoLanguageBackend.cs                |    6 +++---
 .../{DebuggerCommands.cs => RuntimeCommands.cs}    |    4 ++--
 3 files changed, 7 insertions(+), 7 deletions(-)
 rename backend/mono/{DebuggerCommands.cs => RuntimeCommands.cs} (96%)
--------------1.5.6
Content-Type: text/x-patch; name="7a30b6683b4920559b474fe36e5d738edc94c468.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="7a30b6683b4920559b474fe36e5d738edc94c468.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 6072899..4a23f04 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -4034,7 +4034,7 @@ namespace Mono.Debugger.Backend
 				case Stage.Uninitialized: {
 					Console.WriteLine ("RTI: {0}", RTI.Function);
 
-					language.DebuggerCommands.ParseMethod (inferior, RTI.Function, ID);
+					language.RuntimeCommands.ParseMethod (inferior, RTI.Function, ID);
 					break;
 
 					class_info = RTI.Function.ResolveClass (inferior, false);
@@ -4150,7 +4150,7 @@ namespace Mono.Debugger.Backend
 				switch (stage) {
 				case Stage.Uninitialized:
 					TargetAddress klass;
-					language.DebuggerCommands.ParseMethodDone (
+					language.RuntimeCommands.ParseMethodDone (
 						inferior, data1, data2, data3, out klass, out method);
 					Console.WriteLine ("RTI RESOLVED METHOD: {0}", method);
 					stage = Stage.HasMethodAddress;
diff --git a/backend/mono/MonoLanguageBackend.cs b/backend/mono/MonoLanguageBackend.cs
index 6737a31..5d5dc77 100644
--- a/backend/mono/MonoLanguageBackend.cs
+++ b/backend/mono/MonoLanguageBackend.cs
@@ -230,7 +230,7 @@ namespace Mono.Debugger.Backend.Mono
 		TargetAddress[] trampolines;
 		bool initialized;
 
-		DebuggerCommands commands;
+		RuntimeCommands commands;
 
 		public MonoLanguageBackend (ProcessServant process, MonoDebuggerInfo info)
 		{
@@ -238,7 +238,7 @@ namespace Mono.Debugger.Backend.Mono
 			this.info = info;
 			data_tables = new Hashtable ();
 
-			commands = new DebuggerCommands (this, info.RunCommand);
+			commands = new RuntimeCommands (this, info.RunCommand);
 		}
 
 		public override string Name {
@@ -273,7 +273,7 @@ namespace Mono.Debugger.Backend.Mono
 			get { return trampolines; }
 		}
 
-		internal DebuggerCommands DebuggerCommands {
+		internal RuntimeCommands RuntimeCommands {
 			get { return commands; }
 		}
 
diff --git a/backend/mono/DebuggerCommands.cs b/backend/mono/RuntimeCommands.cs
similarity index 96%
rename from backend/mono/DebuggerCommands.cs
rename to backend/mono/RuntimeCommands.cs
index 4e6f482..18b5dcb 100644
--- a/backend/mono/DebuggerCommands.cs
+++ b/backend/mono/RuntimeCommands.cs
@@ -6,7 +6,7 @@ using Mono.Debugger.Languages.Mono;
 
 namespace Mono.Debugger.Backend.Mono
 {
-	internal class DebuggerCommands : DebuggerMarshalByRefObject
+	internal class RuntimeCommands : DebuggerMarshalByRefObject
 	{
 		internal enum Command {
 			ParseType		= 1,
@@ -24,7 +24,7 @@ namespace Mono.Debugger.Backend.Mono
 		public readonly MonoLanguageBackend Mono;
 		public readonly TargetAddress CommandFunction;
 
-		public DebuggerCommands (MonoLanguageBackend mono, TargetAddress func)
+		public RuntimeCommands (MonoLanguageBackend mono, TargetAddress func)
 		{
 			this.Mono = mono;
 			this.CommandFunction = func;

--------------1.5.6--



From c8b0320951d1b17d73837c5b02674e8748555776 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Tue, 15 Sep 2009 18:25:07 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 frontend/Expression.cs |   41 ++++++++++++++++-------------------------
 1 files changed, 16 insertions(+), 25 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="c8b0320951d1b17d73837c5b02674e8748555776.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="c8b0320951d1b17d73837c5b02674e8748555776.diff"

diff --git a/frontend/Expression.cs b/frontend/Expression.cs
index 5a0d1bb..87dd22a 100644
--- a/frontend/Expression.cs
+++ b/frontend/Expression.cs
@@ -1695,17 +1695,20 @@ namespace Mono.Debugger.Frontend
 							   TargetClassObject instance, string name,
 							   bool search_static, bool search_instance)
 		{
+			ArrayList methods;
+			TargetMemberInfo member;
+			bool is_instance, is_static;
+
 		again:
 			TargetClass klass = stype.GetClass (target);
 			if (klass != null) {
-				TargetMemberInfo member = klass.FindMember (
-					target, name, search_static, search_instance);
+				member = klass.FindMember (target, name, search_static, search_instance);
 				if (member != null)
 					return new StructAccessExpression (stype, instance, member);
 
-				ArrayList methods = new ArrayList ();
-				bool is_instance = false;
-				bool is_static = false;
+				methods = new ArrayList ();
+				is_instance = false;
+				is_static = false;
 
 				TargetMethodInfo[] klass_methods = klass.GetMethods (target);
 				if (klass_methods != null) {
@@ -1733,34 +1736,23 @@ namespace Mono.Debugger.Frontend
 				}
 			}
 
-			TargetClassType ctype;
-
-			TargetGenericInstanceType ginst = stype as TargetGenericInstanceType;
-			if (ginst != null)
-				ctype = ginst.ContainerType;
-			else
-				ctype = stype as TargetClassType;
-
-			if (ctype != null) {
-				TargetMemberInfo member = ctype.FindMember (
-					name, search_static, search_instance);
-
+			member = stype.FindMember (name, search_static, search_instance);
 				if (member != null)
-					return new StructAccessExpression (ctype, instance, member);
+				return new StructAccessExpression (stype, instance, member);
 
-				ArrayList methods = new ArrayList ();
-				bool is_instance = false;
-				bool is_static = false;
+			methods = new ArrayList ();
+			is_instance = false;
+			is_static = false;
 
 				if (name == ".ctor") {
-					foreach (TargetMethodInfo method in ctype.Constructors) {
+				foreach (TargetMethodInfo method in stype.Constructors) {
 						if (method.IsStatic)
 							continue;
 						methods.Add (method.Type);
 						is_instance = true;
 					}
 				} else if (name == ".cctor") {
-					foreach (TargetMethodInfo method in ctype.Constructors) {
+				foreach (TargetMethodInfo method in stype.Constructors) {
 						if (!method.IsStatic)
 							continue;
 						methods.Add (method.Type);
@@ -1790,8 +1782,7 @@ namespace Mono.Debugger.Frontend
 					TargetFunctionType[] funcs = new TargetFunctionType [methods.Count];
 					methods.CopyTo (funcs, 0);
 					return new MethodGroupExpression (
-						ctype, instance, name, funcs, is_instance, is_static);
-				}
+					stype, instance, name, funcs, is_instance, is_static);
 			}
 
 			if (stype.HasParent) {

--------------1.5.6--



From bc3546703437fb91ef6f938d76818ba5c0c04bba Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 17 Sep 2009 15:04:37 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs    |   42 ++++++++++++++++++++++++++++++++++-
 backend/ThreadServant.cs           |    2 +
 backend/arch/CoreFile.cs           |    5 ++++
 backend/mono/RuntimeCommands.cs    |   43 ++++++++++++++++++++++++++++++++++++
 classes/Thread.cs                  |   19 ++++++++++++++++
 languages/mono/MonoFunctionType.cs |    5 ++++
 6 files changed, 115 insertions(+), 1 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="bc3546703437fb91ef6f938d76818ba5c0c04bba.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="bc3546703437fb91ef6f938d76818ba5c0c04bba.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 4a23f04..86e58aa 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -1816,6 +1816,12 @@ namespace Mono.Debugger.Backend
 			return StartOperation (new OperationCallMethod (this, method, method_arg, object_arg));
 		}
 
+		public override CommandResult CallMethod (TargetAddress method, byte[] data)
+		{
+			enforce_managed_context ();
+			return StartOperation (new OperationCallMethod (this, method, data));
+		}
+
 		public override CommandResult Return (ReturnMode mode)
 		{
 			return (CommandResult) SendCommand (delegate {
@@ -4322,6 +4328,7 @@ namespace Mono.Debugger.Backend
 		public readonly long Argument1;
 		public readonly long Argument2;
 		public readonly long Argument3;
+		public readonly byte[] DataArgument;
 		public readonly TargetObject ObjectArgument;
 		public readonly string StringArgument;
 
@@ -4358,6 +4365,15 @@ namespace Mono.Debugger.Backend
 			this.ObjectArgument = object_arg;
 		}
 
+		public OperationCallMethod (SingleSteppingEngine sse, TargetAddress method,
+					    byte[] data)
+			: base (sse)
+		{
+			this.Type = CallMethodType.Data;
+			this.Method = method;
+			this.DataArgument = data;
+		}
+
 		bool interrupted_syscall;
 
 		protected override void DoExecute ()
@@ -4399,6 +4415,10 @@ namespace Mono.Debugger.Backend
 				inferior.CallMethod (Method, Argument1, ObjectArgument, ID);
 				break;
 
+			case CallMethodType.Data:
+				inferior.CallMethod (Method, DataArgument, ID);
+				break;
+
 			default:
 				throw new InvalidOperationException ();
 			}
@@ -4429,6 +4449,25 @@ namespace Mono.Debugger.Backend
 			return EventResult.Running;
 		}
 
+		protected override EventResult CallbackCompleted (long data1, long data2, byte[] data3,
+								  out TargetEventArgs args)
+		{
+			if (Type != CallMethodType.Data)
+				throw new InternalError ();
+			if (inferior.TargetAddressSize == 4)
+				data1 &= 0xffffffffL;
+
+			Report.Debug (DebugFlags.SSE,
+				      "{0} call method done: {1:x} {2:x} {3}",
+				      sse, data1, data2, Result);
+
+			RestoreStack ();
+			Result.Result = data3;
+			args = null;
+			return EventResult.CompletedCallback;
+		}
+
+
 		protected override EventResult CallbackCompleted (long data1, long data2, out TargetEventArgs args)
 		{
 			if (inferior.TargetAddressSize == 4)
@@ -5011,6 +5050,7 @@ namespace Mono.Debugger.Backend
 	{
 		LongLong,
 		LongLongLongString,
-		LongObject
+		LongObject,
+		Data
 	}
 }
diff --git a/backend/ThreadServant.cs b/backend/ThreadServant.cs
index 638a5c7..9676ce4 100644
--- a/backend/ThreadServant.cs
+++ b/backend/ThreadServant.cs
@@ -197,6 +197,8 @@ namespace Mono.Debugger.Backend
 		public abstract CommandResult CallMethod (TargetAddress method, TargetAddress method_argument,
 							  TargetObject object_argument);
 
+		public abstract CommandResult CallMethod (TargetAddress method, byte[] data);
+
 		public abstract CommandResult Return (ReturnMode mode);
 
 		internal abstract void AbortInvocation (long ID);
diff --git a/backend/arch/CoreFile.cs b/backend/arch/CoreFile.cs
index 63b0c04..282c3ce 100644
--- a/backend/arch/CoreFile.cs
+++ b/backend/arch/CoreFile.cs
@@ -583,6 +583,11 @@ namespace Mono.Debugger.Backend
 				throw new InvalidOperationException ();
 			}
 
+			public override CommandResult CallMethod (TargetAddress method, byte[] data)
+			{
+				throw new InvalidOperationException ();
+			}
+
 			public override CommandResult Return (ReturnMode mode)
 			{
 				throw new InvalidOperationException ();
diff --git a/backend/mono/RuntimeCommands.cs b/backend/mono/RuntimeCommands.cs
index 18b5dcb..27d5f6e 100644
--- a/backend/mono/RuntimeCommands.cs
+++ b/backend/mono/RuntimeCommands.cs
@@ -114,5 +114,48 @@ namespace Mono.Debugger.Backend.Mono
 
 			Console.WriteLine ("PARSE METHOD DONE #2: {0} {1}", klass, method);
 		}
+
+		internal TargetAddress ResolveMethod (Thread thread, MonoFunctionType func)
+		{
+			var handle = MonoRuntimeTypeHandle.Create (func.DeclaringType);
+			if (handle == null)
+				throw new InvalidOperationException ();
+
+			Console.WriteLine ("RESOLVE METHOD: {0}", TargetBinaryReader.HexDump (handle.TypeBlob));
+
+			byte[] buffer;
+			int ret_size;
+
+			using (MemoryStream ms = new MemoryStream ()) {
+				var bw = new BinaryWriter (ms);
+				bw.Write ((byte) Command.ParseMethod);
+				ret_size = 2 * thread.TargetAddressSize;
+				bw.Write (ret_size);
+				bw.BaseStream.Position += ret_size;
+				bw.Write (handle.TypeBlob);
+				bw.Write (func.Token);
+
+				buffer = new byte [bw.BaseStream.Position];
+				Array.Copy (ms.GetBuffer (), buffer, buffer.Length);
+			}
+
+			byte[] result = thread.CallMethod (CommandFunction, buffer);
+			Console.WriteLine ("RESOLVE METHOD DONE: {0}", TargetBinaryReader.HexDump (result));
+
+			TargetBinaryReader reader = new TargetBinaryReader (result, thread.TargetMemoryInfo);
+
+			byte command = reader.ReadByte ();
+			if (reader.ReadInt32 () != ret_size)
+				throw new InternalError ();
+
+			Console.WriteLine ("RESOLVE METHOD DONE #1: {0} {1}", command, ret_size);
+
+			TargetAddress klass = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
+			TargetAddress method = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
+
+			Console.WriteLine ("RESOLVE METHOD DONE #2: {0} {1}", klass, method);
+
+			return method;
+		}
 	}
 }
diff --git a/classes/Thread.cs b/classes/Thread.cs
index 3ed8e6c..7ab2f80 100644
--- a/classes/Thread.cs
+++ b/classes/Thread.cs
@@ -621,6 +621,25 @@ namespace Mono.Debugger
 			return (TargetAddress) result.Result;
 		}
 
+		public byte[] CallMethod (TargetAddress method, byte[] data)
+		{
+			CommandResult result;
+
+			lock (this) {
+				check_alive ();
+				result = servant.CallMethod (method, data);
+			}
+
+			result.Wait ();
+
+			if (result.Result == null)
+				throw new TargetException (TargetError.UnknownError);
+
+			Console.WriteLine ("CALL METHOD DONE: {0} {1}", result.Result, result.Result.GetType ());
+
+			return (byte[]) result.Result;
+		}
+
 		public void Return (ReturnMode mode)
 		{
 			CommandResult result;
diff --git a/languages/mono/MonoFunctionType.cs b/languages/mono/MonoFunctionType.cs
index 2d2816f..8fdeb14 100644
--- a/languages/mono/MonoFunctionType.cs
+++ b/languages/mono/MonoFunctionType.cs
@@ -190,11 +190,16 @@ namespace Mono.Debugger.Languages.Mono
 			if (!thread.CurrentFrame.Language.IsManaged)
 				throw new TargetException (TargetError.InvalidContext);
 
+			RuntimeCommands commands = klass.File.MonoLanguage.RuntimeCommands;
+			TargetAddress addr = commands.ResolveMethod (thread, this);
+
+#if FIXME
 			TargetAddress addr = (TargetAddress) thread.ThreadServant.DoTargetAccess (
 				delegate (TargetMemoryAccess target)  {
 					MonoClassInfo class_info = ResolveClass (target, true);
 					return class_info.GetMethodAddress (target, token);
 			});
+#endif
 
 			MonoLanguageBackend mono = klass.File.MonoLanguage;
 

--------------1.5.6--



From db061df628c5bfeb2c1190d0bea2da18a20d73b0 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 17 Sep 2009 16:19:51 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/mono/MonoLanguageBackend.cs |    4 +++
 backend/mono/RuntimeCommands.cs     |   47 ++++++++++++++++++++++++++++++++++-
 languages/mono/MonoFunctionType.cs  |   19 +++++++++-----
 3 files changed, 62 insertions(+), 8 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="db061df628c5bfeb2c1190d0bea2da18a20d73b0.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="db061df628c5bfeb2c1190d0bea2da18a20d73b0.diff"

diff --git a/backend/mono/MonoLanguageBackend.cs b/backend/mono/MonoLanguageBackend.cs
index 5d5dc77..b970d83 100644
--- a/backend/mono/MonoLanguageBackend.cs
+++ b/backend/mono/MonoLanguageBackend.cs
@@ -273,6 +273,10 @@ namespace Mono.Debugger.Backend.Mono
 			get { return trampolines; }
 		}
 
+		internal bool HasRuntimeCommands {
+			get { return commands != null; }
+		}
+
 		internal RuntimeCommands RuntimeCommands {
 			get { return commands; }
 		}
diff --git a/backend/mono/RuntimeCommands.cs b/backend/mono/RuntimeCommands.cs
index 27d5f6e..5837a7b 100644
--- a/backend/mono/RuntimeCommands.cs
+++ b/backend/mono/RuntimeCommands.cs
@@ -10,7 +10,9 @@ namespace Mono.Debugger.Backend.Mono
 	{
 		internal enum Command {
 			ParseType		= 1,
-			ParseMethod
+			ParseMethod,
+			ParseVirtualMethod,
+			GetMethodSignature
 		}
 
 		internal enum CommandResult {
@@ -157,5 +159,48 @@ namespace Mono.Debugger.Backend.Mono
 
 			return method;
 		}
+
+		internal TargetAddress GetMethodSignature (Thread thread, MonoFunctionType func)
+		{
+			var handle = MonoRuntimeTypeHandle.Create (func.DeclaringType);
+			if (handle == null)
+				throw new InvalidOperationException ();
+
+			Console.WriteLine ("GET METHOD SIGNATURE: {0}", TargetBinaryReader.HexDump (handle.TypeBlob));
+
+			byte[] buffer;
+			int ret_size;
+
+			using (MemoryStream ms = new MemoryStream ()) {
+				var bw = new BinaryWriter (ms);
+				bw.Write ((byte) Command.GetMethodSignature);
+				ret_size = 3 * thread.TargetAddressSize;
+				bw.Write (ret_size);
+				bw.BaseStream.Position += ret_size;
+				bw.Write (handle.TypeBlob);
+				bw.Write (func.Token);
+
+				buffer = new byte [bw.BaseStream.Position];
+				Array.Copy (ms.GetBuffer (), buffer, buffer.Length);
+			}
+
+			byte[] result = thread.CallMethod (CommandFunction, buffer);
+			Console.WriteLine ("GET METHOD SIGNATURE DONE: {0}", TargetBinaryReader.HexDump (result));
+
+			TargetBinaryReader reader = new TargetBinaryReader (result, thread.TargetMemoryInfo);
+
+			byte command = reader.ReadByte ();
+			if (reader.ReadInt32 () != ret_size)
+				throw new InternalError ();
+
+			TargetAddress klass = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
+			TargetAddress method = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
+			TargetAddress sig = new TargetAddress (thread.AddressDomain, reader.ReadAddress ());
+
+			Console.WriteLine ("GET METHOD SIGNATURE DONE #1: {0} {1} {2}", klass, method, sig);
+
+			return sig;
+		}
+
 	}
 }
diff --git a/languages/mono/MonoFunctionType.cs b/languages/mono/MonoFunctionType.cs
index 8fdeb14..ed8eee2 100644
--- a/languages/mono/MonoFunctionType.cs
+++ b/languages/mono/MonoFunctionType.cs
@@ -190,21 +190,26 @@ namespace Mono.Debugger.Languages.Mono
 			if (!thread.CurrentFrame.Language.IsManaged)
 				throw new TargetException (TargetError.InvalidContext);
 
-			RuntimeCommands commands = klass.File.MonoLanguage.RuntimeCommands;
-			TargetAddress addr = commands.ResolveMethod (thread, this);
+			TargetAddress sig;
+			MonoLanguageBackend mono = klass.File.MonoLanguage;
 
-#if FIXME
+			if (mono.HasRuntimeCommands) {
+				RuntimeCommands commands = klass.File.MonoLanguage.RuntimeCommands;
+				sig = commands.GetMethodSignature (thread, this);
+			} else {
 			TargetAddress addr = (TargetAddress) thread.ThreadServant.DoTargetAccess (
 				delegate (TargetMemoryAccess target)  {
 					MonoClassInfo class_info = ResolveClass (target, true);
+						if (class_info == null)
+							return TargetAddress.Null;
 					return class_info.GetMethodAddress (target, token);
 			});
-#endif
 
-			MonoLanguageBackend mono = klass.File.MonoLanguage;
+				if (addr.IsNull)
+					throw new TargetException (TargetError.ClassNotInitialized);
 
-			TargetAddress sig = thread.CallMethod (
-				mono.MonoDebuggerInfo.GetMethodSignature, addr, 0);
+				sig = thread.CallMethod (mono.MonoDebuggerInfo.GetMethodSignature, addr, 0);
+			}
 
 			signature = (MonoMethodSignature) thread.ThreadServant.DoTargetAccess (
 				delegate (TargetMemoryAccess target)  {

--------------1.5.6--



From b21f585ad56f0570c89247cc99e61ace8105b431 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 17 Sep 2009 16:24:33 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |    8 ++++++--
 1 files changed, 6 insertions(+), 2 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="b21f585ad56f0570c89247cc99e61ace8105b431.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="b21f585ad56f0570c89247cc99e61ace8105b431.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 3695bb4..7d88136 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -3998,7 +3998,8 @@ namespace Mono.Debugger.Backend
 				HasVirtualMethod,
 				CompilingMethod,
 				CompiledMethod,
-				InvokedMethod
+				InvokedMethod,
+				RcResolvingMethod
 			}
 
 			public override bool IsSourceOperation {
@@ -4040,8 +4041,11 @@ namespace Mono.Debugger.Backend
 				case Stage.Uninitialized: {
 					Console.WriteLine ("RTI: {0}", RTI.Function);
 
+					if (language.HasRuntimeCommands) {
 					language.RuntimeCommands.ParseMethod (inferior, RTI.Function, ID);
+						stage = Stage.RcResolvingMethod;
 					break;
+					}
 
 					class_info = RTI.Function.ResolveClass (inferior, false);
 					Console.WriteLine ("RTI: {0} {1}", RTI.Function, class_info);
@@ -4154,7 +4158,7 @@ namespace Mono.Debugger.Backend
 									  out TargetEventArgs args)
 			{
 				switch (stage) {
-				case Stage.Uninitialized:
+				case Stage.RcResolvingMethod:
 					TargetAddress klass;
 					language.RuntimeCommands.ParseMethodDone (
 						inferior, data1, data2, data3, out klass, out method);

--------------1.5.6--



From 098b81e3ba9dcf59437e235c0b3afe942c634bb2 Mon Sep 17 00:00:00 2001
From: Martin Baulig <martin@novell.com>
Date: Thu, 17 Sep 2009 16:45:46 +0200
Subject: [PATCH] .
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="------------1.5.6"

This is a multi-part message in MIME format.
--------------1.5.6
Content-Type: text/plain; charset=UTF-8; format=fixed
Content-Transfer-Encoding: 8bit

---
 backend/SingleSteppingEngine.cs |   27 +++++++++++++++++++--------
 backend/mono/RuntimeCommands.cs |   32 ++++++++++++++++++++++++++++++++
 2 files changed, 51 insertions(+), 8 deletions(-)
--------------1.5.6
Content-Type: text/x-patch; name="098b81e3ba9dcf59437e235c0b3afe942c634bb2.diff"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline; filename="098b81e3ba9dcf59437e235c0b3afe942c634bb2.diff"

diff --git a/backend/SingleSteppingEngine.cs b/backend/SingleSteppingEngine.cs
index 7d88136..af6a8d6 100644
--- a/backend/SingleSteppingEngine.cs
+++ b/backend/SingleSteppingEngine.cs
@@ -3999,7 +3999,10 @@ namespace Mono.Debugger.Backend
 				CompilingMethod,
 				CompiledMethod,
 				InvokedMethod,
-				RcResolvingMethod
+
+				RcInitialize,
+				RcResolveMethod,
+				RcResolveVirtualMethod
 			}
 
 			public override bool IsSourceOperation {
@@ -4041,11 +4044,8 @@ namespace Mono.Debugger.Backend
 				case Stage.Uninitialized: {
 					Console.WriteLine ("RTI: {0}", RTI.Function);
 
-					if (language.HasRuntimeCommands) {
-						language.RuntimeCommands.ParseMethod (inferior, RTI.Function, ID);
-						stage = Stage.RcResolvingMethod;
-						break;
-					}
+					if (language.HasRuntimeCommands)
+						goto case Stage.RcInitialize;
 
 					class_info = RTI.Function.ResolveClass (inferior, false);
 					Console.WriteLine ("RTI: {0} {1}", RTI.Function, class_info);
@@ -4106,6 +4106,16 @@ namespace Mono.Debugger.Backend
 					return;
 				}
 
+				case Stage.RcInitialize:
+					if (RTI.IsVirtual) {
+						language.RuntimeCommands.ParseVirtualMethod (inferior, RTI.Function, instance, ID);
+						stage = Stage.RcResolveVirtualMethod;
+					} else {
+						language.RuntimeCommands.ParseMethod (inferior, RTI.Function, ID);
+						stage = Stage.RcResolveMethod;
+					}
+					break;
+
 				default:
 					throw new InternalError ();
 				}
@@ -4158,7 +4168,8 @@ namespace Mono.Debugger.Backend
 									  out TargetEventArgs args)
 			{
 				switch (stage) {
-				case Stage.RcResolvingMethod:
+				case Stage.RcResolveMethod:
+				case Stage.RcResolveVirtualMethod: {
 					TargetAddress klass;
 					language.RuntimeCommands.ParseMethodDone (
 						inferior, data1, data2, data3, out klass, out method);
@@ -4167,8 +4178,8 @@ namespace Mono.Debugger.Backend
 					do_execute ();
 					args = null;
 					return EventResult.Running;
+				}
 
-					break;
 				default:
 					throw new InternalError ();
 				}
diff --git a/backend/mono/RuntimeCommands.cs b/backend/mono/RuntimeCommands.cs
index 5837a7b..5097829 100644
--- a/backend/mono/RuntimeCommands.cs
+++ b/backend/mono/RuntimeCommands.cs
@@ -98,6 +98,38 @@ namespace Mono.Debugger.Backend.Mono
 			}
 		}
 
+		internal void ParseVirtualMethod (Inferior inferior, MonoFunctionType func, TargetStructObject instance,
+						  long callback_id)
+		{
+			var handle = MonoRuntimeTypeHandle.Create (func.DeclaringType);
+			if (handle == null)
+				throw new InvalidOperationException ();
+
+			bool is_virtual = (instance != null) && instance.HasAddress & instance.Type.IsByRef;
+
+			Console.WriteLine ("PARSE METHOD: {0}", TargetBinaryReader.HexDump (handle.TypeBlob));
+
+			using (MemoryStream ms = new MemoryStream ()) {
+				var bw = new BinaryWriter (ms);
+				if (is_virtual)
+					bw.Write ((byte) Command.ParseVirtualMethod);
+				else
+					bw.Write ((byte) Command.ParseMethod);
+				int ret_size = 2 * inferior.TargetAddressSize;
+				bw.Write (ret_size);
+				bw.BaseStream.Position += ret_size;
+				bw.Write (handle.TypeBlob);
+				bw.Write (func.Token);
+				if (is_virtual)
+					bw.Write (instance.Location.GetAddress (inferior).Address);
+
+				byte[] buffer = new byte [bw.BaseStream.Position];
+				Array.Copy (ms.GetBuffer (), buffer, buffer.Length);
+
+				inferior.CallMethod (CommandFunction, buffer, callback_id);
+			}
+		}
+
 		internal void ParseMethodDone (Inferior inferior, long data1, long data2, byte[] data3,
 					       out TargetAddress klass, out TargetAddress method)
 		{

--------------1.5.6--


