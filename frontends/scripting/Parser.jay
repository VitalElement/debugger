%{
using System.Text;
using System.IO;
using System.Collections;
using System;

namespace Mono.Debugger.Frontends.CommandLine
{
	public class Parser
	{
		string name;
		ScriptingContext current_context;
		MyTextReader reader;
		bool do_quit = false;

		protected bool yacc_verbose_flag = false;

		public bool yacc_verbose {
			set {
				yacc_verbose_flag = value;
			}

			get {
				return yacc_verbose_flag;
			}
		}

		public bool Quit {
			get {
				return do_quit;
			}
		}

		Tokenizer lexer;

		public Tokenizer Lexer {
			get {
				return lexer;
			}
		}		   

%}

%token QUIT
%token EOL
%token EOF
%token NONE	// This token is never returned by our lexer
%token ERROR	// This is used not by the parser, but by the tokenizer.
		// do not remove.

%token IDENTIFIER
%token INTEGER
%token NUMBER
%token STRING
%token HASH
%token AT
%token PERCENT
%token DOLLAR
%token DOT
%token BANG
%token COMMA
%token ASSIGN
%token STAR
%token PLUS
%token MINUS
%token DIV
%token OPEN_PARENS
%token CLOSE_PARENS
%token OPEN_BRACKET
%token CLOSE_BRACKET
%token OP_LT
%token OP_GT
%token COLON

%token PROCESSES
%token REGISTERS
%token PARAMETERS
%token LOCALS
%token TYPE
%token METHOD
%token PARENT
%token LENGTH
%token LOWER
%token UPPER

%token KIND
%token ACCESSIBLE
%token CONTENTS
%token LINE
%token NOT

%token UNKNOWN
%token FUNDAMENTAL
%token ARRAY
%token STRUCT
%token CLASS
%token POINTER
%token MODULES
%token SOURCES
%token METHODS
%token BREAKPOINTS
%token THREADGROUPS
%token GLOBAL

%token FRAME
%token START
%token SHOW
%token PROCESS
%token CONTINUE
%token BACKTRACE
%token UP
%token DOWN
%token STEP
%token NEXT
%token STEPI
%token NEXTI
%token FINISH
%token BREAK
%token PRINT
%token DISASSEMBLE
%token SET
%token ASSERT
%token BREAKPOINT
%token SAVE
%token KILL
%token THREADGROUP
%token SEARCH
%token LIST
%token RUN
%token EXAMINE

%token NATIVE
%token SELECT
%token BACKGROUND
%token STOP

%token MODULE
%token IGNORE
%token UNIGNORE
%token ALL
%token ENABLE
%token DISABLE
%token DELETE
%token CREATE
%token ADD
%token REMOVE

%token HELP
%start command_loop
%%

command_loop
	: /* empty */
	| command_loop command EOL
	  {
		((Command) $2).Execute (current_context);
	  }
	| command_loop EOL
	| command_loop EOF
	| QUIT EOL
	  {
		do_quit = true;
		reader.Close ();
	  }
	;

command : generated_command | other_command | assert_command;

generated_command
	: CONTINUE process_expression
	  {
		$$ = new ContinueCommand ((ProcessExpression) $2);
	  }
	| STEP process_expression
	  {
		$$ = new StepCommand ((ProcessExpression) $2);
	  }
	| NEXT process_expression
	  {
		$$ = new NextCommand ((ProcessExpression) $2);
	  }
	| STEPI process_expression
	  {
		$$ = new StepInstructionCommand ((ProcessExpression) $2);
	  }
	| NATIVE STEPI process_expression
	  {
		$$ = new StepNativeInstructionCommand ((ProcessExpression) $3);
	  }
	| NEXTI process_expression
	  {
		$$ = new NextInstructionCommand ((ProcessExpression) $2);
	  }
	| FINISH process_expression
	  {
		$$ = new FinishCommand ((ProcessExpression) $2);
	  }
	| BACKTRACE process_expression
	  {
		$$ = new BacktraceCommand ((ProcessExpression) $2);
	  }
	| UP process_expression
	  {
		$$ = new UpCommand ((ProcessExpression) $2);
	  }
	| DOWN process_expression
	  {
		$$ = new DownCommand ((ProcessExpression) $2);
	  }
	| KILL
	  {
		$$ = new KillCommand ();
	  }
	| RUN
	  {
		$$ = new RunCommand ();
	  }
	| SHOW PROCESSES
	  {
		$$ = new ShowProcessesCommand ();
	  }
	| SHOW REGISTERS frame_expression
	  {
		$$ = new ShowRegistersCommand ((FrameExpression) $3);
	  }
	| SHOW PARAMETERS frame_expression
	  {
		$$ = new ShowParametersCommand ((FrameExpression) $3);
	  }
	| SHOW LOCALS frame_expression
	  {
		$$ = new ShowLocalsCommand ((FrameExpression) $3);
	  }
	| SHOW MODULES
	  {
		$$ = new ShowModulesCommand ();
	  }
	| SHOW SOURCES module_list_expression
	  {
		$$ = new ShowSourcesCommand ((ModuleListExpression) $3);
	  }
	| SHOW METHODS source_list_expression
	  {
		$$ = new ShowMethodsCommand ((SourceListExpression) $3);
	  }
	| SHOW BREAKPOINTS
	  {
		$$ = new ShowBreakpointsCommand ();
	  }
	| SHOW THREADGROUPS
	  {
		$$ = new ShowThreadGroupsCommand ();
	  }
	| SHOW TYPE variable_expression
	  {
		$$ = new ShowVariableTypeCommand ((VariableExpression) $3);
	  }
	| BREAK thread_group_expression source_expression
	  {
		$$ = new BreakCommand ((ThreadGroupExpression) $2, (SourceExpression) $3);
	  }
	| BREAKPOINT ENABLE breakpoint_number_expression
	  {
		$$ = new BreakpointEnableCommand ((BreakpointNumberExpression) $3);
	  }
	| BREAKPOINT DISABLE breakpoint_number_expression
	  {
		$$ = new BreakpointDisableCommand ((BreakpointNumberExpression) $3);
	  }
	| BREAKPOINT DELETE breakpoint_number_expression
	  {
		$$ = new BreakpointDeleteCommand ((BreakpointNumberExpression) $3);
	  }
	| FRAME frame_expression
	  {
		$$ = new FrameCommand ((FrameExpression) $2);
	  }
	| DISASSEMBLE frame_expression
	  {
		$$ = new DisassembleCommand ((FrameExpression) $2);
	  }
	| DISASSEMBLE METHOD frame_expression
	  {
		$$ = new DisassembleMethodCommand ((FrameExpression) $3);
	  }
	| PROCESS process_expression
	  {
		$$ = new SelectProcessCommand ((ProcessExpression) $2);
	  }
	| BACKGROUND process_expression
	  {
		$$ = new BackgroundProcessCommand ((ProcessExpression) $2);
	  }
	| STOP process_expression
	  {
		$$ = new StopProcessCommand ((ProcessExpression) $2);
	  }
	| MODULE module_list_expression module_operations
	  {
		$$ = new ModuleOperationCommand ((ModuleListExpression) $2, (ModuleOperationListExpression) $3);
	  }
	| THREADGROUP CREATE STRING
	  {
		$$ = new ThreadGroupCreateCommand ((string) $3);
	  }
	| THREADGROUP ADD STRING process_list_expression
	  {
		$$ = new ThreadGroupAddCommand ((string) $3, (ProcessListExpression) $4);
	  }
	| THREADGROUP REMOVE STRING process_list_expression
	  {
		$$ = new ThreadGroupRemoveCommand ((string) $3, (ProcessListExpression) $4);
	  }
	| LIST source_expression
	  {
		$$ = new ListCommand ((SourceExpression) $2);
	  }
	| LIST CONTINUE
	  {
		$$ = new ListCommand (null);
	  }
	;

other_command
	: SAVE STRING
	  {
		$$ = new SaveCommand ((string) $2);
	  }
	| SET BANG IDENTIFIER ASSIGN variable_expression
	  {
		$$ = new ScriptingVariableAssignCommand ((string) $3, (VariableExpression) $5);
	  }
	| PRINT expression
	  {
		$$ = new PrintCommand ((Expression) $2);
	  }
	| EXAMINE examine_format variable_expression
	  {
		$$ = new ExamineCommand ((ExamineCommand.Format) $2, (VariableExpression) $3);
	  }
	| START program_arguments_expression
	  {
		$$ = new StartCommand ((ProgramArgumentsExpression) $2);
	  }
	;

kind
	: UNKNOWN
	  {
		$$ = TargetObjectKind.Unknown;
	  }
	| FUNDAMENTAL
	  {
		$$ = TargetObjectKind.Fundamental;
	  }
	| ARRAY
	  {
		$$ = TargetObjectKind.Array;
	  }
	| STRUCT
	  {
		$$ = TargetObjectKind.Struct;
	  }
	| CLASS
	  {
		$$ = TargetObjectKind.Class;
	  }
	| POINTER
	  {
		$$ = TargetObjectKind.Pointer;
	  }
	;

assert_command
	: ASSERT KIND kind variable_expression
	  {
		$$ = new AssertKindCommand ((TargetObjectKind) $3, (VariableExpression) $4);
	  }
	| ASSERT ACCESSIBLE variable_expression
	  {
		$$ = new AssertAccessibleCommand ((VariableExpression) $3, true);
	  }
	| ASSERT NOT ACCESSIBLE variable_expression
	  {
		$$ = new AssertAccessibleCommand ((VariableExpression) $4, false);
	  }
	| ASSERT TYPE STRING variable_expression
	  {
		$$ = new AssertTypeCommand ((string) $3, (VariableExpression) $4);
	  }
	| ASSERT CONTENTS STRING variable_expression
	  {
		$$ = new AssertContentsCommand ((string) $3, (VariableExpression) $4);
	  }
	| ASSERT LINE INTEGER
	  {
		$$ = new AssertLineCommand ((int) $3);
	  }
	;

expression
	: LENGTH OPEN_PARENS variable_expression CLOSE_PARENS
	  {
		$$ = new ArrayLengthExpression ((VariableExpression) $3);
	  }
	| LOWER OPEN_PARENS variable_expression CLOSE_PARENS
	  {
		$$ = new ArrayLowerBoundExpression ((VariableExpression) $3);
	  }
	| UPPER OPEN_PARENS variable_expression CLOSE_PARENS
	  {
		$$ = new ArrayUpperBoundExpression ((VariableExpression) $3);
	  }
	| NUMBER
	  {
		$$ = new NumberExpression ((long) $1);
	  }
	| INTEGER
	  {
		$$ = new NumberExpression ((int) $1);
	  }
	| expression binary_operator expression
	  {
		$$ = new BinaryOperator ((BinaryOperator.Kind) $2, (Expression) $1, (Expression) $3);
	  }
	| OPEN_PARENS expression CLOSE_PARENS
	  {
		$$ = new ExpressionGroup ((Expression) $2);
	  }
	| variable_expression
	  {
		$$ = $1;
	  }
	;

variable_expression
	: STAR variable_expression
	  {
		$$ = new VariableDereferenceExpression ((VariableExpression) $2);
	  }
	| BANG IDENTIFIER
	  {
		$$ = new ScriptingVariableReference ((string) $2);
	  }
	| frame_expression DOLLAR IDENTIFIER
	  {
		$$ = new VariableReferenceExpression ((FrameExpression) $1, (string) $3);
	  }
	| frame_expression PERCENT NUMBER
	  {
		$$ = new PointerExpression ((FrameExpression) $1, (long) $3);
	  }
	| frame_expression PERCENT IDENTIFIER opt_regoffset
	  {
		$$ = new RegisterExpression ((FrameExpression) $1, (string) $3, (long) $4);
	  }
	| variable_expression DOT IDENTIFIER
	  {
		$$ = new StructAccessExpression ((VariableExpression) $1, (string) $3);
	  }
	| variable_expression OPEN_BRACKET expression CLOSE_BRACKET
	  {
		$$ = new ArrayAccessExpression ((VariableExpression) $1, (Expression) $3);
	  }
	| PARENT OPEN_PARENS variable_expression CLOSE_PARENS
	  {
		$$ = new ParentClassExpression ((VariableExpression) $3);
	  }
	;

program_arguments_expression
	: program_arglist
	  {
		string[] args = new string [((ArrayList) $1).Count];
		((ArrayList) $1).CopyTo (args, 0);
		$$ = new ProgramArgumentsExpression (args);
	  }
	;

program_arglist
	: STRING
	  {
		ArrayList args = new ArrayList ();
		args.Add ($1);

		$$ = args;
	  }
	| program_arglist STRING
	  {
		ArrayList args = (ArrayList) $1;
		args.Add ($2);

		$$ = args;
	  }
	;

examine_format
	: /* empty */
	  {
		$$ = ExamineCommand.Format.Standard;
	  }
	| DIV integer_or_number
	  {
		$$ = new ExamineCommand.Format ((int)(long) $2);
	  }
	;

opt_regoffset
	: /* empty */
	  {
		$$ = (long) 0;
	  }
	| PLUS integer_or_number
	  {
		$$ = (long) $2;
	  }
	| MINUS integer_or_number
	  {
		$$ = -(long) $2;
	  }
	;

integer_or_number
	: INTEGER
	  {
		$$ = (long)(int) $1;
	  }
	| NUMBER
	  {
		$$ = (long) $1;
	  }
	;

breakpoint_number_expression
	: INTEGER
	  {
		$$ = new BreakpointNumberExpression ((int) $1);
	  }
	;

thread_group_expression
	: /* empty */
	  {
		$$ = new ThreadGroupExpression ("main");
	  }
	| OP_LT IDENTIFIER OP_GT
	  {
		$$ = new ThreadGroupExpression ((string) $3);
	  }
	| OP_LT GLOBAL OP_GT
	  {
		$$ = new ThreadGroupExpression ("global");
	  }
	;

process_expression
	: /* empty */
	  {
		$$ = new ProcessExpression (-1);
	  }
	| AT INTEGER
	  {
		$$ = new ProcessExpression ((int) $2);
	  }
	;	

frame_expression
	: process_expression /* empty */
	  {
		$$ = new FrameExpression ((ProcessExpression) $1, -1);
	  }
	| process_expression HASH INTEGER
	  {
		$$ = new FrameExpression ((ProcessExpression) $1, (int) $3);
	  }
	;

opt_line
	: /* empty */
	  {
		$$ = -1;
	  }
	| COLON INTEGER
	  {
		$$ = $2;
	  }
	;

source_expression
	: frame_expression
	  {
		$$ = new SourceExpression ((FrameExpression) $1, null, -1);
	  }
	| frame_expression IDENTIFIER opt_line
	  {
		$$ = new SourceExpression ((FrameExpression) $1, (string) $2, (int) $3);
	  }
	| frame_expression INTEGER
	  {
		$$ = new SourceExpression ((FrameExpression) $1, (int) $2);
	  }
	| STRING
	  {
		$$ = new SourceExpression ((string) $1);
	  }
	| STRING COLON INTEGER
	  {
		$$ = new SourceExpression ((string) $1, (int) $3);
	  }
	| BANG INTEGER
	  {
		$$ = new SourceExpression ((int) $2);
	  }
	;

module_list_expression
	: number_list
	  {
		int[] indices = new int [((ArrayList) $1).Count];
		((ArrayList) $1).CopyTo (indices, 0);

		$$ = new ModuleListExpression (indices);
	  }
	;

source_list_expression
	: number_list
	  {
		int[] indices = new int [((ArrayList) $1).Count];
		((ArrayList) $1).CopyTo (indices, 0);

		$$ = new SourceListExpression (indices);
	  }
	;

process_list_expression
	: number_list
	  {
		int[] indices = new int [((ArrayList) $1).Count];
		((ArrayList) $1).CopyTo (indices, 0);

		$$ = new ProcessListExpression (indices);
	  }
	;

number_list
	: INTEGER
	  {
		ArrayList args = new ArrayList ();
		args.Add ($1);

		$$ = args;
	  }
	| number_list COMMA INTEGER
	  {
		ArrayList args = (ArrayList) $1;
		args.Add ($3);

		$$ = args;
	  }
	;

module_operation
	: IGNORE
	  {
		$$ = ModuleOperation.Ignore;
	  }
	| UNIGNORE
	  {
		$$ = ModuleOperation.UnIgnore;
	  }
	| BANG IGNORE
	  {
		$$ = ModuleOperation.UnIgnore;
	  }
	| STEP
	  {
		$$ = ModuleOperation.Step;
	  }
	| BANG STEP
	  {
		$$ = ModuleOperation.DontStep;
	  }
	| SHOW BREAKPOINTS
	  {
		$$ = ModuleOperation.ShowBreakpoints;
	  }
	;

module_operations
	: module_operation_list
	  {
		ModuleOperation[] operations = new ModuleOperation [((ArrayList) $1).Count];
		((ArrayList) $1).CopyTo (operations, 0);

		$$ = new ModuleOperationListExpression (operations);
	  }
	;

module_operation_list
	: module_operation
	  {
		ArrayList args = new ArrayList ();
		args.Add ($1);

		$$ = args;
	  }
	| module_operation_list module_operation
	  {
		ArrayList args = (ArrayList) $1;
		args.Add ($2);

		$$ = args;
	  }
	;

binary_operator
	: STAR
	  {
		$$ = BinaryOperator.Kind.Mult;
	  }
	| PLUS
	  {
		$$ = BinaryOperator.Kind.Plus;
	  }
	| MINUS
	  {
		$$ = BinaryOperator.Kind.Minus;
	  }
	| DIV
	  {
		$$ = BinaryOperator.Kind.Div;
	  }
	;
%%

public Parser (ScriptingContext context, string name)
{
	this.name = name;
	this.reader = new MyTextReader ();
	this.current_context = context;

	lexer = new Tokenizer (context, reader, name);
}

public bool Parse (string text)
{
	try {
		reader.Text = text;
		lexer.restart ();
		if (yacc_verbose_flag)
			yyparse (lexer, new yydebug.yyDebugSimple ());
		else
			yyparse (lexer);
		return true;
	} catch (Exception e){
		// Please do not remove this, it is used during debugging
		// of the grammar
		//
		current_context.Error (lexer.location + "  : Parsing error ");
		current_context.Error (e.ToString ());
		return false;
	}
}

/* end end end */
}
