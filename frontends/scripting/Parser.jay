%{
using System.Text;
using System.IO;
using System.Collections;
using System;

namespace Mono.Debugger.Frontends.CommandLine
{
	public class Parser
	{
		string name;
		ScriptingContext current_context;
		MyTextReader reader;
		bool do_quit = false;

		protected bool yacc_verbose_flag = false;

		public bool yacc_verbose {
			set {
				yacc_verbose_flag = value;
			}

			get {
				return yacc_verbose_flag;
			}
		}

		public bool Quit {
			get {
				return do_quit;
			}
		}

		Tokenizer lexer;

		public Tokenizer Lexer {
			get {
				return lexer;
			}
		}		   

%}

%token QUIT
%token EOL
%token EOF
%token NONE	// This token is never returned by our lexer
%token ERROR	// This is used not by the parser, but by the tokenizer.
		// do not remove.

%token IDENTIFIER
%token INTEGER
%token NUMBER
%token STRING
%token HASH
%token AT
%token PERCENT
%token DOLLAR
%token DOT
%token BANG
%token COMMA
%token ASSIGN
%token STAR
%token PLUS
%token MINUS
%token DIV
%token OPEN_PARENS
%token CLOSE_PARENS
%token OPEN_BRACKET
%token CLOSE_BRACKET

%token PROCESSES
%token REGISTERS
%token PARAMETERS
%token LOCALS
%token TYPE
%token METHOD
%token PARENT
%token LENGTH
%token LOWER
%token UPPER

%token KIND
%token ACCESSIBLE
%token CONTENTS
%token LINE
%token NOT

%token UNKNOWN
%token FUNDAMENTAL
%token ARRAY
%token STRUCT
%token CLASS
%token POINTER
%token MODULES
%token BREAKPOINTS
%token THREADGROUPS
%token GLOBAL

%token FRAME
%token START
%token SHOW
%token PROCESS
%token CONTINUE
%token BACKTRACE
%token UP
%token DOWN
%token STEP
%token NEXT
%token STEPI
%token NEXTI
%token FINISH
%token BREAK
%token PRINT
%token DISASSEMBLE
%token SET
%token ASSERT
%token BREAKPOINT
%token SAVE
%token LOAD
%token KILL
%token THREADGROUP

%token SELECT
%token BACKGROUND
%token STOP

%token MODULE
%token IGNORE
%token UNIGNORE
%token ALL
%token ENABLE
%token DISABLE
%token DELETE
%token CREATE
%token ADD
%token REMOVE

%start command_loop
%%

command_loop
	: /* empty */
	| command_loop command EOL
	  {
		((Command) $2).Execute (current_context);
	  }
	| command_loop EOL
	| command_loop EOF
	| QUIT EOL
	  {
		do_quit = true;
		reader.Close ();
	  }
	;

command
	: CONTINUE opt_process
	  {
		$$ = new StepCommand ((ProcessExpression) $2, WhichStepCommand.Continue);
	  }
	| STEP opt_process
	  {
		$$ = new StepCommand ((ProcessExpression) $2, WhichStepCommand.Step);
	  }
	| NEXT opt_process
	  {
		$$ = new StepCommand ((ProcessExpression) $2, WhichStepCommand.Next);
	  }
	| STEPI opt_process
	  {
		$$ = new StepCommand ((ProcessExpression) $2, WhichStepCommand.StepInstruction);
	  }
	| NEXTI opt_process
	  {
		$$ = new StepCommand ((ProcessExpression) $2, WhichStepCommand.NextInstruction);
	  }
	| FINISH opt_process
	  {
		$$ = new StepCommand ((ProcessExpression) $2, WhichStepCommand.Finish);
	  }
	| BACKTRACE opt_process
	  {
		$$ = new BacktraceCommand ((ProcessExpression) $2);
	  }
	| UP opt_process
	  {
		$$ = new UpCommand ((ProcessExpression) $2);
	  }
	| DOWN opt_process
	  {
		$$ = new DownCommand ((ProcessExpression) $2);
	  }
	| KILL opt_process
	  {
		$$ = new KillProcessCommand ((ProcessExpression) $2);
	  }
	| SHOW PROCESSES
	  {
		$$ = new ShowProcessesCommand ();
	  }
	| SHOW REGISTERS opt_process opt_frame_number
	  {
		$$ = new ShowRegistersCommand ((ProcessExpression) $3, (int) $4);
	  }
	| SHOW PARAMETERS opt_process opt_frame_number
	  {
		$$ = new ShowParametersCommand ((ProcessExpression) $3, (int) $4);
	  }
	| SHOW LOCALS opt_process opt_frame_number
	  {
		$$ = new ShowLocalsCommand ((ProcessExpression) $3, (int) $4);
	  }
	| SHOW MODULES
	  {
		$$ = new ShowModulesCommand ();
	  }
	| SHOW BREAKPOINTS
	  {
		$$ = new ShowBreakpointsCommand ();
	  }
	| SHOW THREADGROUPS
	  {
		$$ = new ShowThreadGroupsCommand ();
	  }
	| SHOW TYPE variable_expression
	  {
		$$ = new ShowVariableTypeCommand ((VariableExpression) $3);
	  }
	| BREAK opt_thread_group function_name
	  {
		$$ = new BreakCommand ((ThreadGroupExpression) $2, (string) $3);
	  }
	| BREAK opt_thread_group STRING INTEGER
	  {
		$$ = new BreakCommand ((ThreadGroupExpression) $2, (string) $3, (int) $4);
	  }
	| BREAKPOINT INTEGER ENABLE
	  {
		$$ = new BreakpointEnableCommand ((int) $2);
	  }
	| BREAKPOINT INTEGER DISABLE
	  {
		$$ = new BreakpointDisableCommand ((int) $2);
	  }
	| BREAKPOINT INTEGER DELETE
	  {
		$$ = new BreakpointDeleteCommand ((int) $2);
	  }
	| PRINT expression
	  {
		$$ = new PrintCommand ((Expression) $2);
	  }
	| FRAME opt_process opt_frame_number
	  {
		$$ = new FrameCommand ((ProcessExpression) $2, (int) $3);
	  }
	| DISASSEMBLE opt_process opt_frame_number
	  {
		$$ = new DisassembleCommand ((ProcessExpression) $2, (int) $3);
	  }
	| DISASSEMBLE METHOD opt_process opt_frame_number
	  {
		$$ = new DisassembleMethodCommand ((ProcessExpression) $3, (int) $4);
	  }
	| START INTEGER program_arguments
	  {
		$$ = new StartCommand ((string []) $3, (int) $2);
	  }
	| START program_arguments
	  {
		$$ = new StartCommand ((string []) $2);
	  }
	| PROCESS opt_process
	  {
		$$ = new SelectProcessCommand ((ProcessExpression) $2);
	  }
	| BACKGROUND opt_process
	  {
		$$ = new BackgroundProcessCommand ((ProcessExpression) $2);
	  }
	| STOP opt_process
	  {
		$$ = new StopProcessCommand ((ProcessExpression) $2);
	  }
	| SET BANG IDENTIFIER ASSIGN variable_expression
	  {
		$$ = new ScriptingVariableAssignCommand ((string) $3, (VariableExpression) $5);
	  }
	| MODULE number_list module_operations
	  {
		int[] modules = new int [((ArrayList) $2).Count];
		((ArrayList) $2).CopyTo (modules, 0);
		ModuleOperation[] operations = new ModuleOperation [((ArrayList) $3).Count];
		((ArrayList) $3).CopyTo (operations, 0);
		$$ = new ModuleOperationCommand (modules, operations);
	  }
	| MODULE ALL module_operations
	  {
		ModuleOperation[] operations = new ModuleOperation [((ArrayList) $2).Count];
		((ArrayList) $2).CopyTo (operations, 0);
		$$ = new ModuleOperationCommand (operations);
	  }
	| assert_command
	  {
		$$ = $1;
	  }
	| SAVE STRING
	  {
		$$ = new SaveCommand ((string) $2);
	  }
	| LOAD STRING
	  {
		$$ = new LoadCommand ((string) $2);
	  }
	| THREADGROUP CREATE STRING opt_number_list
	  {
		int[] threads = new int [((ArrayList) $4).Count];
		((ArrayList) $4).CopyTo (threads, 0);

		$$ = new ThreadGroupCreateCommand ((string) $3, threads);
	  }
	| THREADGROUP ADD STRING opt_number_list
	  {
		int[] threads = new int [((ArrayList) $4).Count];
		((ArrayList) $4).CopyTo (threads, 0);

		$$ = new ThreadGroupAddCommand ((string) $3, threads);
	  }
	| THREADGROUP REMOVE STRING opt_number_list
	  {
		int[] threads = new int [((ArrayList) $4).Count];
		((ArrayList) $4).CopyTo (threads, 0);

		$$ = new ThreadGroupRemoveCommand ((string) $3, threads);
	  }
	;

kind
	: UNKNOWN
	  {
		$$ = TargetObjectKind.Unknown;
	  }
	| FUNDAMENTAL
	  {
		$$ = TargetObjectKind.Fundamental;
	  }
	| ARRAY
	  {
		$$ = TargetObjectKind.Array;
	  }
	| STRUCT
	  {
		$$ = TargetObjectKind.Struct;
	  }
	| CLASS
	  {
		$$ = TargetObjectKind.Class;
	  }
	| POINTER
	  {
		$$ = TargetObjectKind.Pointer;
	  }
	;

assert_command
	: ASSERT KIND kind variable_expression
	  {
		$$ = new AssertKindCommand ((TargetObjectKind) $3, (VariableExpression) $4);
	  }
	| ASSERT ACCESSIBLE variable_expression
	  {
		$$ = new AssertAccessibleCommand ((VariableExpression) $3, true);
	  }
	| ASSERT NOT ACCESSIBLE variable_expression
	  {
		$$ = new AssertAccessibleCommand ((VariableExpression) $4, false);
	  }
	| ASSERT TYPE STRING variable_expression
	  {
		$$ = new AssertTypeCommand ((string) $3, (VariableExpression) $4);
	  }
	| ASSERT CONTENTS STRING variable_expression
	  {
		$$ = new AssertContentsCommand ((string) $3, (VariableExpression) $4);
	  }
	| ASSERT LINE INTEGER
	  {
		$$ = new AssertLineCommand ((int) $3);
	  }
	;

expression
	: opt_process opt_frame_number PERCENT IDENTIFIER
	  {
		$$ = new RegisterExpression ((ProcessExpression) $1, (int) $2, (string) $4);
	  }
	| LENGTH OPEN_PARENS variable_expression CLOSE_PARENS
	  {
		$$ = new ArrayLengthExpression ((VariableExpression) $3);
	  }
	| LOWER OPEN_PARENS variable_expression CLOSE_PARENS
	  {
		$$ = new ArrayLowerBoundExpression ((VariableExpression) $3);
	  }
	| UPPER OPEN_PARENS variable_expression CLOSE_PARENS
	  {
		$$ = new ArrayUpperBoundExpression ((VariableExpression) $3);
	  }
	| NUMBER
	  {
		$$ = new NumberExpression ((int) $1);
	  }
	| INTEGER
	  {
		$$ = new NumberExpression ((int) $1);
	  }
	| expression binary_operator expression
	  {
		$$ = new BinaryOperator ((BinaryOperator.Kind) $2, (Expression) $1, (Expression) $3);
	  }
	| OPEN_PARENS expression CLOSE_PARENS
	  {
		$$ = new ExpressionGroup ((Expression) $2);
	  }
	| variable_expression
	  {
		$$ = $1;
	  }
	;

variable_expression
	: STAR variable_expression
	  {
		$$ = new VariableDereferenceExpression ((VariableExpression) $2);
	  }
	| BANG IDENTIFIER
	  {
		$$ = new ScriptingVariableReference ((string) $2);
	  }
	| opt_process opt_frame_number DOLLAR IDENTIFIER
	  {
		$$ = new VariableReferenceExpression ((ProcessExpression) $1, (int) $2, (string) $4);
	  }
	| variable_expression DOT IDENTIFIER
	  {
		$$ = new StructAccessExpression ((VariableExpression) $1, (string) $3);
	  }
	| variable_expression OPEN_BRACKET expression CLOSE_BRACKET
	  {
		$$ = new ArrayAccessExpression ((VariableExpression) $1, (Expression) $3);
	  }
	| PARENT OPEN_PARENS variable_expression CLOSE_PARENS
	  {
		$$ = new ParentClassExpression ((VariableExpression) $3);
	  }
	;

program_arguments
	: program_arglist
	  {
		ArrayList args = (ArrayList) $1;
		string[] retval = new string [args.Count];
		args.CopyTo (retval, 0);
		$$ = retval;
	  }
	;

program_arglist
	: STRING
	  {
		ArrayList args = new ArrayList ();
		args.Add ($1);

		$$ = args;
	  }
	| program_arglist STRING
	  {
		ArrayList args = (ArrayList) $1;
		args.Add ($2);

		$$ = args;
	  }
	;

opt_thread_group
	: /* empty */
	  {
		$$ = new ThreadGroupExpression ("main");
	  }
	| AT IDENTIFIER
	  {
		$$ = new ThreadGroupExpression ((string) $2);
	  }
	| AT GLOBAL
	  {
		$$ = new ThreadGroupExpression ("global");
	  }
	;

opt_process
	: /* empty */
	  {
		$$ = new ProcessExpression (-1);
	  }
	| AT INTEGER
	  {
		$$ = new ProcessExpression ((int) $2);
	  }
	;	

opt_frame_number
	: /* empty */
	  {
		$$ = -1;
	  }
	| HASH INTEGER
	  {
		$$ = $2;
	  }
	;

function_name
	: IDENTIFIER
	  {
		$$ = (string) $1;
	  }
	| STRING
	  {
		$$ = (string) $1;
	  }
	;

opt_number_list
	: /* empty */
	  {
		$$ = new ArrayList ();
	  }
	| number_list
	;

number_list
	: INTEGER
	  {
		ArrayList args = new ArrayList ();
		args.Add ($1);

		$$ = args;
	  }
	| number_list COMMA INTEGER
	  {
		ArrayList args = (ArrayList) $1;
		args.Add ($3);

		$$ = args;
	  }
	;

module_operation
	: IGNORE
	  {
		$$ = ModuleOperation.Ignore;
	  }
	| UNIGNORE
	  {
		$$ = ModuleOperation.UnIgnore;
	  }
	| BANG IGNORE
	  {
		$$ = ModuleOperation.UnIgnore;
	  }
	| STEP
	  {
		$$ = ModuleOperation.Step;
	  }
	| BANG STEP
	  {
		$$ = ModuleOperation.DontStep;
	  }
	| SHOW BREAKPOINTS
	  {
		$$ = ModuleOperation.ShowBreakpoints;
	  }
	;

module_operations
	: module_operation
	  {
		ArrayList args = new ArrayList ();
		args.Add ($1);

		$$ = args;
	  }
	| module_operations module_operation
	  {
		ArrayList args = (ArrayList) $1;
		args.Add ($2);

		$$ = args;
	  }
	;

binary_operator
	: STAR
	  {
		$$ = BinaryOperator.Kind.Mult;
	  }
	| PLUS
	  {
		$$ = BinaryOperator.Kind.Plus;
	  }
	| MINUS
	  {
		$$ = BinaryOperator.Kind.Minus;
	  }
	| DIV
	  {
		$$ = BinaryOperator.Kind.Div;
	  }
	;
%%

public Parser (ScriptingContext context, string name)
{
	this.name = name;
	this.reader = new MyTextReader ();
	this.current_context = context;

	lexer = new Tokenizer (context, reader, name);
}

public bool Parse (string text)
{
	try {
		reader.Text = text;
		lexer.restart ();
		if (yacc_verbose_flag)
			yyparse (lexer, new yydebug.yyDebugSimple ());
		else
			yyparse (lexer);
		return true;
	} catch (Exception e){
		// Please do not remove this, it is used during debugging
		// of the grammar
		//
		current_context.Error (lexer.location + "  : Parsing error ");
		current_context.Error (e.ToString ());
		return false;
	}
}

/* end end end */
}

