%{
using System.Text;
using System.IO;
using System.Collections;
using System;

namespace Mono.Debugger.Frontends.CommandLine
{
	public class Parser
	{
		string name;
		ScriptingContext current_context;
		MyTextReader reader;
		bool do_quit = false;
		string[] default_args;

		protected bool yacc_verbose_flag = false;

		public bool yacc_verbose {
			set {
				yacc_verbose_flag = value;
			}

			get {
				return yacc_verbose_flag;
			}
		}

		public bool Quit {
			get {
				return do_quit;
			}
		}

		Tokenizer lexer;

		public Tokenizer Lexer {
			get {
				return lexer;
			}
		}		   

%}

%token QUIT
%token EOL
%token EOF
%token NONE	// This token is never returned by our lexer
%token ERROR	// This is used not by the parser, but by the tokenizer.
		// do not remove.

%token IDENTIFIER
%token INTEGER
%token NUMBER
%token STRING
%token HASH
%token AT
%token PERCENT
%token DOLLAR
%token DOT

%token PROCESSES
%token REGISTERS
%token PARAMETERS
%token LOCALS
%token TYPE

%token FRAME
%token START
%token SHOW
%token PROCESS
%token CONTINUE
%token BACKTRACE
%token UP
%token DOWN
%token STEP
%token NEXT
%token STEPI
%token NEXTI
%token FINISH
%token BREAK
%token PRINT

%token SELECT
%token BACKGROUND
%token STOP

%start command_loop
%%

command_loop
	: /* empty */
	| command_loop command EOL
	  {
		((Command) $2).Execute (current_context);
	  }
	| command_loop EOL
	| command_loop EOF
	| QUIT EOL
	  {
		do_quit = true;
		reader.Close ();
	  }
	;

command
	: CONTINUE opt_process
	  {
		$$ = new StepCommand ((ProcessExpression) $2, WhichStepCommand.Continue);
	  }
	| STEP opt_process
	  {
		$$ = new StepCommand ((ProcessExpression) $2, WhichStepCommand.Step);
	  }
	| NEXT opt_process
	  {
		$$ = new StepCommand ((ProcessExpression) $2, WhichStepCommand.Next);
	  }
	| STEPI opt_process
	  {
		$$ = new StepCommand ((ProcessExpression) $2, WhichStepCommand.StepInstruction);
	  }
	| NEXTI opt_process
	  {
		$$ = new StepCommand ((ProcessExpression) $2, WhichStepCommand.NextInstruction);
	  }
	| FINISH opt_process
	  {
		$$ = new StepCommand ((ProcessExpression) $2, WhichStepCommand.Finish);
	  }
	| BACKTRACE opt_process
	  {
		$$ = new BacktraceCommand ((ProcessExpression) $2);
	  }
	| UP opt_process
	  {
		$$ = new UpCommand ((ProcessExpression) $2);
	  }
	| DOWN opt_process
	  {
		$$ = new DownCommand ((ProcessExpression) $2);
	  }
	| SHOW PROCESSES
	  {
		$$ = new ShowProcessesCommand ();
	  }
	| SHOW REGISTERS opt_process
	  {
		$$ = new ShowRegistersCommand ((ProcessExpression) $3);
	  }
	| SHOW PARAMETERS opt_process opt_frame_number
	  {
		$$ = new ShowParametersCommand ((ProcessExpression) $3, (int) $4);
	  }
	| SHOW LOCALS opt_process opt_frame_number
	  {
		$$ = new ShowLocalsCommand ((ProcessExpression) $3, (int) $4);
	  }
	| SHOW TYPE opt_process opt_frame_number DOLLAR IDENTIFIER
	  {
		$$ = new ShowVariableTypeCommand ((ProcessExpression) $3, (int) $4, (string) $6);
	  }
	| BREAK opt_process function_name
	  {
		$$ = new BreakCommand ((ProcessExpression) $2, (string) $3);
	  }
	| BREAK opt_process STRING INTEGER
	  {
		$$ = new BreakCommand ((ProcessExpression) $2, (string) $3, (int) $4);
	  }
	| PRINT expression
	  {
		$$ = new PrintCommand ((Expression) $2);
	  }
	| FRAME opt_process opt_frame_number
	  {
		$$ = new FrameCommand ((ProcessExpression) $2, (int) $3);
	  }
	| START INTEGER program_arguments
	  {
		$$ = new StartCommand ((string []) $3, (int) $2);
	  }
	| START program_arguments
	  {
		$$ = new StartCommand ((string []) $2);
	  }
	| PROCESS opt_process
	  {
		$$ = new SelectProcessCommand ((ProcessExpression) $2);
	  }
	| BACKGROUND opt_process
	  {
		$$ = new BackgroundProcessCommand ((ProcessExpression) $2);
	  }
	| STOP opt_process
	  {
		$$ = new StopProcessCommand ((ProcessExpression) $2);
	  }
	;

expression
	: AT INTEGER
	{
		$$ = new ProcessExpression ((int) $2);
	}
	| opt_process opt_frame_number PERCENT IDENTIFIER
	{
		$$ = new RegisterExpression ((ProcessExpression) $1, (int) $2, (string) $4);
	}
	| variable_expression
	;

variable_expression
	: opt_process opt_frame_number DOLLAR IDENTIFIER
	{
		$$ = new VariableExpression ((ProcessExpression) $1, (int) $2, (string) $4);
	}
	| variable_expression DOT IDENTIFIER
	{
		$$ = new StructAccessExpression ((VariableExpression) $1, (string) $3);
	}
	;

program_arguments
	: /* empty */
	  {
		$$ = default_args;
	  }
	| program_arglist
	  {
		ArrayList args = (ArrayList) $1;
		string[] retval = new string [args.Count];
		args.CopyTo (retval, 0);
		$$ = retval;
	  }
	;

program_arglist
	: STRING
	  {
		ArrayList args = new ArrayList ();
		args.Add ($1);

		$$ = args;
	  }
	| program_arguments STRING
	  {
		ArrayList args = (ArrayList) $1;
		args.Add ($2);

		$$ = args;
	  }
	;

opt_process
	: /* empty */
	{
		$$ = new ProcessExpression (-1);
	}
	| AT INTEGER
	{
		$$ = new ProcessExpression ((int) $2);
	}
	;	

opt_frame_number
	: /* empty */
	{
		$$ = -1;
	}
	| HASH INTEGER
	{
		$$ = $2;
	}
	;

function_name
	: IDENTIFIER
	{
		$$ = (string) $1;
	}
	| STRING
	{
		$$ = (string) $1;
	}
	;

%%

public Parser (ScriptingContext context, string name, string[] args)
{
	this.name = name;
	this.reader = new MyTextReader ();
	this.current_context = context;
	this.default_args = args;

	lexer = new Tokenizer (context, reader, name);
}

public bool Parse (string text)
{
	try {
		reader.Text = text;
		lexer.restart ();
		if (yacc_verbose_flag)
			yyparse (lexer, new yydebug.yyDebugSimple ());
		else
			yyparse (lexer);
		return true;
	} catch (Exception e){
		// Please do not remove this, it is used during debugging
		// of the grammar
		//
		current_context.Error (lexer.location + "  : Parsing error ");
		current_context.Error (e.ToString ());
		return false;
	}
}

/* end end end */
}

